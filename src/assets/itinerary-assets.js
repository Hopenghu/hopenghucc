/**
 * 行程規劃器靜態資產
 * 此檔案由 scripts/embed-itinerary-assets.js 自動生成
 * 請勿手動編輯
 */

export const itineraryAssets = {
  "App.js": "import * as En from \"react\";\nimport mt, { useLayoutEffect as fo, useEffect as B, useRef as j, useMemo as W, useCallback as lt, useState as L, createContext as Lt, memo as Pl, useReducer as Rl, useContext as q, useId as $s, useInsertionEffect as po, Children as Ml, isValidElement as El, Fragment as mo, createElement as Vl, forwardRef as Nl, Component as kl } from \"react\";\nimport { unstable_batchedUpdates as ln, createPortal as Il } from \"react-dom\";\nvar _n = { exports: {} }, Ie = {};\n/**\n * @license React\n * react-jsx-runtime.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\nvar Ii;\nfunction jl() {\n  if (Ii) return Ie;\n  Ii = 1;\n  var t = Symbol.for(\"react.transitional.element\"), e = Symbol.for(\"react.fragment\");\n  function n(s, i, r) {\n    var o = null;\n    if (r !== void 0 && (o = \"\" + r), i.key !== void 0 && (o = \"\" + i.key), \"key\" in i) {\n      r = {};\n      for (var a in i)\n        a !== \"key\" && (r[a] = i[a]);\n    } else r = i;\n    return i = r.ref, {\n      $$typeof: t,\n      type: s,\n      key: o,\n      ref: i !== void 0 ? i : null,\n      props: r\n    };\n  }\n  return Ie.Fragment = e, Ie.jsx = n, Ie.jsxs = n, Ie;\n}\nvar ji;\nfunction Ll() {\n  return ji || (ji = 1, _n.exports = jl()), _n.exports;\n}\nvar p = Ll();\nfunction Ol() {\n  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)\n    e[n] = arguments[n];\n  return W(\n    () => (s) => {\n      e.forEach((i) => i(s));\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    e\n  );\n}\nconst Vn = typeof window < \"u\" && typeof window.document < \"u\" && typeof window.document.createElement < \"u\";\nfunction De(t) {\n  const e = Object.prototype.toString.call(t);\n  return e === \"[object Window]\" || // In Electron context the Window object serializes to [object global]\n  e === \"[object global]\";\n}\nfunction _s(t) {\n  return \"nodeType\" in t;\n}\nfunction vt(t) {\n  var e, n;\n  return t ? De(t) ? t : _s(t) && (e = (n = t.ownerDocument) == null ? void 0 : n.defaultView) != null ? e : window : window;\n}\nfunction Us(t) {\n  const {\n    Document: e\n  } = vt(t);\n  return t instanceof e;\n}\nfunction Qe(t) {\n  return De(t) ? !1 : t instanceof vt(t).HTMLElement;\n}\nfunction go(t) {\n  return t instanceof vt(t).SVGElement;\n}\nfunction Ce(t) {\n  return t ? De(t) ? t.document : _s(t) ? Us(t) ? t : Qe(t) || go(t) ? t.ownerDocument : document : document : document;\n}\nconst Wt = Vn ? fo : B;\nfunction zs(t) {\n  const e = j(t);\n  return Wt(() => {\n    e.current = t;\n  }), lt(function() {\n    for (var n = arguments.length, s = new Array(n), i = 0; i < n; i++)\n      s[i] = arguments[i];\n    return e.current == null ? void 0 : e.current(...s);\n  }, []);\n}\nfunction Fl() {\n  const t = j(null), e = lt((s, i) => {\n    t.current = setInterval(s, i);\n  }, []), n = lt(() => {\n    t.current !== null && (clearInterval(t.current), t.current = null);\n  }, []);\n  return [e, n];\n}\nfunction We(t, e) {\n  e === void 0 && (e = [t]);\n  const n = j(t);\n  return Wt(() => {\n    n.current !== t && (n.current = t);\n  }, e), n;\n}\nfunction tn(t, e) {\n  const n = j();\n  return W(\n    () => {\n      const s = t(n.current);\n      return n.current = s, s;\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [...e]\n  );\n}\nfunction bn(t) {\n  const e = zs(t), n = j(null), s = lt(\n    (i) => {\n      i !== n.current && e?.(i, n.current), n.current = i;\n    },\n    //eslint-disable-next-line\n    []\n  );\n  return [n, s];\n}\nfunction fs(t) {\n  const e = j();\n  return B(() => {\n    e.current = t;\n  }, [t]), e.current;\n}\nlet Un = {};\nfunction en(t, e) {\n  return W(() => {\n    if (e)\n      return e;\n    const n = Un[t] == null ? 0 : Un[t] + 1;\n    return Un[t] = n, t + \"-\" + n;\n  }, [t, e]);\n}\nfunction yo(t) {\n  return function(e) {\n    for (var n = arguments.length, s = new Array(n > 1 ? n - 1 : 0), i = 1; i < n; i++)\n      s[i - 1] = arguments[i];\n    return s.reduce((r, o) => {\n      const a = Object.entries(o);\n      for (const [l, u] of a) {\n        const c = r[l];\n        c != null && (r[l] = c + t * u);\n      }\n      return r;\n    }, {\n      ...e\n    });\n  };\n}\nconst be = /* @__PURE__ */ yo(1), Ke = /* @__PURE__ */ yo(-1);\nfunction Bl(t) {\n  return \"clientX\" in t && \"clientY\" in t;\n}\nfunction Ws(t) {\n  if (!t)\n    return !1;\n  const {\n    KeyboardEvent: e\n  } = vt(t.target);\n  return e && t instanceof e;\n}\nfunction $l(t) {\n  if (!t)\n    return !1;\n  const {\n    TouchEvent: e\n  } = vt(t.target);\n  return e && t instanceof e;\n}\nfunction ps(t) {\n  if ($l(t)) {\n    if (t.touches && t.touches.length) {\n      const {\n        clientX: e,\n        clientY: n\n      } = t.touches[0];\n      return {\n        x: e,\n        y: n\n      };\n    } else if (t.changedTouches && t.changedTouches.length) {\n      const {\n        clientX: e,\n        clientY: n\n      } = t.changedTouches[0];\n      return {\n        x: e,\n        y: n\n      };\n    }\n  }\n  return Bl(t) ? {\n    x: t.clientX,\n    y: t.clientY\n  } : null;\n}\nconst Ge = /* @__PURE__ */ Object.freeze({\n  Translate: {\n    toString(t) {\n      if (!t)\n        return;\n      const {\n        x: e,\n        y: n\n      } = t;\n      return \"translate3d(\" + (e ? Math.round(e) : 0) + \"px, \" + (n ? Math.round(n) : 0) + \"px, 0)\";\n    }\n  },\n  Scale: {\n    toString(t) {\n      if (!t)\n        return;\n      const {\n        scaleX: e,\n        scaleY: n\n      } = t;\n      return \"scaleX(\" + e + \") scaleY(\" + n + \")\";\n    }\n  },\n  Transform: {\n    toString(t) {\n      if (t)\n        return [Ge.Translate.toString(t), Ge.Scale.toString(t)].join(\" \");\n    }\n  },\n  Transition: {\n    toString(t) {\n      let {\n        property: e,\n        duration: n,\n        easing: s\n      } = t;\n      return e + \" \" + n + \"ms \" + s;\n    }\n  }\n}), Li = \"a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]\";\nfunction _l(t) {\n  return t.matches(Li) ? t : t.querySelector(Li);\n}\nconst Ul = {\n  display: \"none\"\n};\nfunction zl(t) {\n  let {\n    id: e,\n    value: n\n  } = t;\n  return mt.createElement(\"div\", {\n    id: e,\n    style: Ul\n  }, n);\n}\nfunction Wl(t) {\n  let {\n    id: e,\n    announcement: n,\n    ariaLiveType: s = \"assertive\"\n  } = t;\n  const i = {\n    position: \"fixed\",\n    top: 0,\n    left: 0,\n    width: 1,\n    height: 1,\n    margin: -1,\n    border: 0,\n    padding: 0,\n    overflow: \"hidden\",\n    clip: \"rect(0 0 0 0)\",\n    clipPath: \"inset(100%)\",\n    whiteSpace: \"nowrap\"\n  };\n  return mt.createElement(\"div\", {\n    id: e,\n    style: i,\n    role: \"status\",\n    \"aria-live\": s,\n    \"aria-atomic\": !0\n  }, n);\n}\nfunction Kl() {\n  const [t, e] = L(\"\");\n  return {\n    announce: lt((s) => {\n      s != null && e(s);\n    }, []),\n    announcement: t\n  };\n}\nconst vo = /* @__PURE__ */ Lt(null);\nfunction Gl(t) {\n  const e = q(vo);\n  B(() => {\n    if (!e)\n      throw new Error(\"useDndMonitor must be used within a children of <DndContext>\");\n    return e(t);\n  }, [t, e]);\n}\nfunction Hl() {\n  const [t] = L(() => /* @__PURE__ */ new Set()), e = lt((s) => (t.add(s), () => t.delete(s)), [t]);\n  return [lt((s) => {\n    let {\n      type: i,\n      event: r\n    } = s;\n    t.forEach((o) => {\n      var a;\n      return (a = o[i]) == null ? void 0 : a.call(o, r);\n    });\n  }, [t]), e];\n}\nconst Xl = {\n  draggable: `\n    To pick up a draggable item, press the space bar.\n    While dragging, use the arrow keys to move the item.\n    Press space again to drop the item in its new position, or press escape to cancel.\n  `\n}, Yl = {\n  onDragStart(t) {\n    let {\n      active: e\n    } = t;\n    return \"Picked up draggable item \" + e.id + \".\";\n  },\n  onDragOver(t) {\n    let {\n      active: e,\n      over: n\n    } = t;\n    return n ? \"Draggable item \" + e.id + \" was moved over droppable area \" + n.id + \".\" : \"Draggable item \" + e.id + \" is no longer over a droppable area.\";\n  },\n  onDragEnd(t) {\n    let {\n      active: e,\n      over: n\n    } = t;\n    return n ? \"Draggable item \" + e.id + \" was dropped over droppable area \" + n.id : \"Draggable item \" + e.id + \" was dropped.\";\n  },\n  onDragCancel(t) {\n    let {\n      active: e\n    } = t;\n    return \"Dragging was cancelled. Draggable item \" + e.id + \" was dropped.\";\n  }\n};\nfunction ql(t) {\n  let {\n    announcements: e = Yl,\n    container: n,\n    hiddenTextDescribedById: s,\n    screenReaderInstructions: i = Xl\n  } = t;\n  const {\n    announce: r,\n    announcement: o\n  } = Kl(), a = en(\"DndLiveRegion\"), [l, u] = L(!1);\n  if (B(() => {\n    u(!0);\n  }, []), Gl(W(() => ({\n    onDragStart(d) {\n      let {\n        active: h\n      } = d;\n      r(e.onDragStart({\n        active: h\n      }));\n    },\n    onDragMove(d) {\n      let {\n        active: h,\n        over: f\n      } = d;\n      e.onDragMove && r(e.onDragMove({\n        active: h,\n        over: f\n      }));\n    },\n    onDragOver(d) {\n      let {\n        active: h,\n        over: f\n      } = d;\n      r(e.onDragOver({\n        active: h,\n        over: f\n      }));\n    },\n    onDragEnd(d) {\n      let {\n        active: h,\n        over: f\n      } = d;\n      r(e.onDragEnd({\n        active: h,\n        over: f\n      }));\n    },\n    onDragCancel(d) {\n      let {\n        active: h,\n        over: f\n      } = d;\n      r(e.onDragCancel({\n        active: h,\n        over: f\n      }));\n    }\n  }), [r, e])), !l)\n    return null;\n  const c = mt.createElement(mt.Fragment, null, mt.createElement(zl, {\n    id: s,\n    value: i.draggable\n  }), mt.createElement(Wl, {\n    id: a,\n    announcement: o\n  }));\n  return n ? Il(c, n) : c;\n}\nvar it;\n(function(t) {\n  t.DragStart = \"dragStart\", t.DragMove = \"dragMove\", t.DragEnd = \"dragEnd\", t.DragCancel = \"dragCancel\", t.DragOver = \"dragOver\", t.RegisterDroppable = \"registerDroppable\", t.SetDroppableDisabled = \"setDroppableDisabled\", t.UnregisterDroppable = \"unregisterDroppable\";\n})(it || (it = {}));\nfunction wn() {\n}\nfunction Oi(t, e) {\n  return W(\n    () => ({\n      sensor: t,\n      options: e ?? {}\n    }),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [t, e]\n  );\n}\nfunction Jl() {\n  for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)\n    e[n] = arguments[n];\n  return W(\n    () => [...e].filter((s) => s != null),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [...e]\n  );\n}\nconst jt = /* @__PURE__ */ Object.freeze({\n  x: 0,\n  y: 0\n});\nfunction xo(t, e) {\n  return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));\n}\nfunction bo(t, e) {\n  let {\n    data: {\n      value: n\n    }\n  } = t, {\n    data: {\n      value: s\n    }\n  } = e;\n  return n - s;\n}\nfunction Zl(t, e) {\n  let {\n    data: {\n      value: n\n    }\n  } = t, {\n    data: {\n      value: s\n    }\n  } = e;\n  return s - n;\n}\nfunction Fi(t) {\n  let {\n    left: e,\n    top: n,\n    height: s,\n    width: i\n  } = t;\n  return [{\n    x: e,\n    y: n\n  }, {\n    x: e + i,\n    y: n\n  }, {\n    x: e,\n    y: n + s\n  }, {\n    x: e + i,\n    y: n + s\n  }];\n}\nfunction wo(t, e) {\n  if (!t || t.length === 0)\n    return null;\n  const [n] = t;\n  return n[e];\n}\nfunction Bi(t, e, n) {\n  return e === void 0 && (e = t.left), n === void 0 && (n = t.top), {\n    x: e + t.width * 0.5,\n    y: n + t.height * 0.5\n  };\n}\nconst Ql = (t) => {\n  let {\n    collisionRect: e,\n    droppableRects: n,\n    droppableContainers: s\n  } = t;\n  const i = Bi(e, e.left, e.top), r = [];\n  for (const o of s) {\n    const {\n      id: a\n    } = o, l = n.get(a);\n    if (l) {\n      const u = xo(Bi(l), i);\n      r.push({\n        id: a,\n        data: {\n          droppableContainer: o,\n          value: u\n        }\n      });\n    }\n  }\n  return r.sort(bo);\n}, tc = (t) => {\n  let {\n    collisionRect: e,\n    droppableRects: n,\n    droppableContainers: s\n  } = t;\n  const i = Fi(e), r = [];\n  for (const o of s) {\n    const {\n      id: a\n    } = o, l = n.get(a);\n    if (l) {\n      const u = Fi(l), c = i.reduce((h, f, g) => h + xo(u[g], f), 0), d = Number((c / 4).toFixed(4));\n      r.push({\n        id: a,\n        data: {\n          droppableContainer: o,\n          value: d\n        }\n      });\n    }\n  }\n  return r.sort(bo);\n};\nfunction ec(t, e) {\n  const n = Math.max(e.top, t.top), s = Math.max(e.left, t.left), i = Math.min(e.left + e.width, t.left + t.width), r = Math.min(e.top + e.height, t.top + t.height), o = i - s, a = r - n;\n  if (s < i && n < r) {\n    const l = e.width * e.height, u = t.width * t.height, c = o * a, d = c / (l + u - c);\n    return Number(d.toFixed(4));\n  }\n  return 0;\n}\nconst nc = (t) => {\n  let {\n    collisionRect: e,\n    droppableRects: n,\n    droppableContainers: s\n  } = t;\n  const i = [];\n  for (const r of s) {\n    const {\n      id: o\n    } = r, a = n.get(o);\n    if (a) {\n      const l = ec(a, e);\n      l > 0 && i.push({\n        id: o,\n        data: {\n          droppableContainer: r,\n          value: l\n        }\n      });\n    }\n  }\n  return i.sort(Zl);\n};\nfunction sc(t, e, n) {\n  return {\n    ...t,\n    scaleX: e && n ? e.width / n.width : 1,\n    scaleY: e && n ? e.height / n.height : 1\n  };\n}\nfunction To(t, e) {\n  return t && e ? {\n    x: t.left - e.left,\n    y: t.top - e.top\n  } : jt;\n}\nfunction ic(t) {\n  return function(n) {\n    for (var s = arguments.length, i = new Array(s > 1 ? s - 1 : 0), r = 1; r < s; r++)\n      i[r - 1] = arguments[r];\n    return i.reduce((o, a) => ({\n      ...o,\n      top: o.top + t * a.y,\n      bottom: o.bottom + t * a.y,\n      left: o.left + t * a.x,\n      right: o.right + t * a.x\n    }), {\n      ...n\n    });\n  };\n}\nconst rc = /* @__PURE__ */ ic(1);\nfunction oc(t) {\n  if (t.startsWith(\"matrix3d(\")) {\n    const e = t.slice(9, -1).split(/, /);\n    return {\n      x: +e[12],\n      y: +e[13],\n      scaleX: +e[0],\n      scaleY: +e[5]\n    };\n  } else if (t.startsWith(\"matrix(\")) {\n    const e = t.slice(7, -1).split(/, /);\n    return {\n      x: +e[4],\n      y: +e[5],\n      scaleX: +e[0],\n      scaleY: +e[3]\n    };\n  }\n  return null;\n}\nfunction ac(t, e, n) {\n  const s = oc(e);\n  if (!s)\n    return t;\n  const {\n    scaleX: i,\n    scaleY: r,\n    x: o,\n    y: a\n  } = s, l = t.left - o - (1 - i) * parseFloat(n), u = t.top - a - (1 - r) * parseFloat(n.slice(n.indexOf(\" \") + 1)), c = i ? t.width / i : t.width, d = r ? t.height / r : t.height;\n  return {\n    width: c,\n    height: d,\n    top: u,\n    right: l + c,\n    bottom: u + d,\n    left: l\n  };\n}\nconst lc = {\n  ignoreTransform: !1\n};\nfunction Ae(t, e) {\n  e === void 0 && (e = lc);\n  let n = t.getBoundingClientRect();\n  if (e.ignoreTransform) {\n    const {\n      transform: u,\n      transformOrigin: c\n    } = vt(t).getComputedStyle(t);\n    u && (n = ac(n, u, c));\n  }\n  const {\n    top: s,\n    left: i,\n    width: r,\n    height: o,\n    bottom: a,\n    right: l\n  } = n;\n  return {\n    top: s,\n    left: i,\n    width: r,\n    height: o,\n    bottom: a,\n    right: l\n  };\n}\nfunction $i(t) {\n  return Ae(t, {\n    ignoreTransform: !0\n  });\n}\nfunction cc(t) {\n  const e = t.innerWidth, n = t.innerHeight;\n  return {\n    top: 0,\n    left: 0,\n    right: e,\n    bottom: n,\n    width: e,\n    height: n\n  };\n}\nfunction uc(t, e) {\n  return e === void 0 && (e = vt(t).getComputedStyle(t)), e.position === \"fixed\";\n}\nfunction dc(t, e) {\n  e === void 0 && (e = vt(t).getComputedStyle(t));\n  const n = /(auto|scroll|overlay)/;\n  return [\"overflow\", \"overflowX\", \"overflowY\"].some((i) => {\n    const r = e[i];\n    return typeof r == \"string\" ? n.test(r) : !1;\n  });\n}\nfunction Nn(t, e) {\n  const n = [];\n  function s(i) {\n    if (e != null && n.length >= e || !i)\n      return n;\n    if (Us(i) && i.scrollingElement != null && !n.includes(i.scrollingElement))\n      return n.push(i.scrollingElement), n;\n    if (!Qe(i) || go(i) || n.includes(i))\n      return n;\n    const r = vt(t).getComputedStyle(i);\n    return i !== t && dc(i, r) && n.push(i), uc(i, r) ? n : s(i.parentNode);\n  }\n  return t ? s(t) : n;\n}\nfunction So(t) {\n  const [e] = Nn(t, 1);\n  return e ?? null;\n}\nfunction zn(t) {\n  return !Vn || !t ? null : De(t) ? t : _s(t) ? Us(t) || t === Ce(t).scrollingElement ? window : Qe(t) ? t : null : null;\n}\nfunction Do(t) {\n  return De(t) ? t.scrollX : t.scrollLeft;\n}\nfunction Co(t) {\n  return De(t) ? t.scrollY : t.scrollTop;\n}\nfunction ms(t) {\n  return {\n    x: Do(t),\n    y: Co(t)\n  };\n}\nvar at;\n(function(t) {\n  t[t.Forward = 1] = \"Forward\", t[t.Backward = -1] = \"Backward\";\n})(at || (at = {}));\nfunction Ao(t) {\n  return !Vn || !t ? !1 : t === document.scrollingElement;\n}\nfunction Po(t) {\n  const e = {\n    x: 0,\n    y: 0\n  }, n = Ao(t) ? {\n    height: window.innerHeight,\n    width: window.innerWidth\n  } : {\n    height: t.clientHeight,\n    width: t.clientWidth\n  }, s = {\n    x: t.scrollWidth - n.width,\n    y: t.scrollHeight - n.height\n  }, i = t.scrollTop <= e.y, r = t.scrollLeft <= e.x, o = t.scrollTop >= s.y, a = t.scrollLeft >= s.x;\n  return {\n    isTop: i,\n    isLeft: r,\n    isBottom: o,\n    isRight: a,\n    maxScroll: s,\n    minScroll: e\n  };\n}\nconst hc = {\n  x: 0.2,\n  y: 0.2\n};\nfunction fc(t, e, n, s, i) {\n  let {\n    top: r,\n    left: o,\n    right: a,\n    bottom: l\n  } = n;\n  s === void 0 && (s = 10), i === void 0 && (i = hc);\n  const {\n    isTop: u,\n    isBottom: c,\n    isLeft: d,\n    isRight: h\n  } = Po(t), f = {\n    x: 0,\n    y: 0\n  }, g = {\n    x: 0,\n    y: 0\n  }, v = {\n    height: e.height * i.y,\n    width: e.width * i.x\n  };\n  return !u && r <= e.top + v.height ? (f.y = at.Backward, g.y = s * Math.abs((e.top + v.height - r) / v.height)) : !c && l >= e.bottom - v.height && (f.y = at.Forward, g.y = s * Math.abs((e.bottom - v.height - l) / v.height)), !h && a >= e.right - v.width ? (f.x = at.Forward, g.x = s * Math.abs((e.right - v.width - a) / v.width)) : !d && o <= e.left + v.width && (f.x = at.Backward, g.x = s * Math.abs((e.left + v.width - o) / v.width)), {\n    direction: f,\n    speed: g\n  };\n}\nfunction pc(t) {\n  if (t === document.scrollingElement) {\n    const {\n      innerWidth: r,\n      innerHeight: o\n    } = window;\n    return {\n      top: 0,\n      left: 0,\n      right: r,\n      bottom: o,\n      width: r,\n      height: o\n    };\n  }\n  const {\n    top: e,\n    left: n,\n    right: s,\n    bottom: i\n  } = t.getBoundingClientRect();\n  return {\n    top: e,\n    left: n,\n    right: s,\n    bottom: i,\n    width: t.clientWidth,\n    height: t.clientHeight\n  };\n}\nfunction Ro(t) {\n  return t.reduce((e, n) => be(e, ms(n)), jt);\n}\nfunction mc(t) {\n  return t.reduce((e, n) => e + Do(n), 0);\n}\nfunction gc(t) {\n  return t.reduce((e, n) => e + Co(n), 0);\n}\nfunction yc(t, e) {\n  if (e === void 0 && (e = Ae), !t)\n    return;\n  const {\n    top: n,\n    left: s,\n    bottom: i,\n    right: r\n  } = e(t);\n  So(t) && (i <= 0 || r <= 0 || n >= window.innerHeight || s >= window.innerWidth) && t.scrollIntoView({\n    block: \"center\",\n    inline: \"center\"\n  });\n}\nconst vc = [[\"x\", [\"left\", \"right\"], mc], [\"y\", [\"top\", \"bottom\"], gc]];\nclass Ks {\n  constructor(e, n) {\n    this.rect = void 0, this.width = void 0, this.height = void 0, this.top = void 0, this.bottom = void 0, this.right = void 0, this.left = void 0;\n    const s = Nn(n), i = Ro(s);\n    this.rect = {\n      ...e\n    }, this.width = e.width, this.height = e.height;\n    for (const [r, o, a] of vc)\n      for (const l of o)\n        Object.defineProperty(this, l, {\n          get: () => {\n            const u = a(s), c = i[r] - u;\n            return this.rect[l] + c;\n          },\n          enumerable: !0\n        });\n    Object.defineProperty(this, \"rect\", {\n      enumerable: !1\n    });\n  }\n}\nclass Oe {\n  constructor(e) {\n    this.target = void 0, this.listeners = [], this.removeAll = () => {\n      this.listeners.forEach((n) => {\n        var s;\n        return (s = this.target) == null ? void 0 : s.removeEventListener(...n);\n      });\n    }, this.target = e;\n  }\n  add(e, n, s) {\n    var i;\n    (i = this.target) == null || i.addEventListener(e, n, s), this.listeners.push([e, n, s]);\n  }\n}\nfunction xc(t) {\n  const {\n    EventTarget: e\n  } = vt(t);\n  return t instanceof e ? t : Ce(t);\n}\nfunction Wn(t, e) {\n  const n = Math.abs(t.x), s = Math.abs(t.y);\n  return typeof e == \"number\" ? Math.sqrt(n ** 2 + s ** 2) > e : \"x\" in e && \"y\" in e ? n > e.x && s > e.y : \"x\" in e ? n > e.x : \"y\" in e ? s > e.y : !1;\n}\nvar Pt;\n(function(t) {\n  t.Click = \"click\", t.DragStart = \"dragstart\", t.Keydown = \"keydown\", t.ContextMenu = \"contextmenu\", t.Resize = \"resize\", t.SelectionChange = \"selectionchange\", t.VisibilityChange = \"visibilitychange\";\n})(Pt || (Pt = {}));\nfunction _i(t) {\n  t.preventDefault();\n}\nfunction bc(t) {\n  t.stopPropagation();\n}\nvar $;\n(function(t) {\n  t.Space = \"Space\", t.Down = \"ArrowDown\", t.Right = \"ArrowRight\", t.Left = \"ArrowLeft\", t.Up = \"ArrowUp\", t.Esc = \"Escape\", t.Enter = \"Enter\", t.Tab = \"Tab\";\n})($ || ($ = {}));\nconst Mo = {\n  start: [$.Space, $.Enter],\n  cancel: [$.Esc],\n  end: [$.Space, $.Enter, $.Tab]\n}, wc = (t, e) => {\n  let {\n    currentCoordinates: n\n  } = e;\n  switch (t.code) {\n    case $.Right:\n      return {\n        ...n,\n        x: n.x + 25\n      };\n    case $.Left:\n      return {\n        ...n,\n        x: n.x - 25\n      };\n    case $.Down:\n      return {\n        ...n,\n        y: n.y + 25\n      };\n    case $.Up:\n      return {\n        ...n,\n        y: n.y - 25\n      };\n  }\n};\nclass Gs {\n  constructor(e) {\n    this.props = void 0, this.autoScrollEnabled = !1, this.referenceCoordinates = void 0, this.listeners = void 0, this.windowListeners = void 0, this.props = e;\n    const {\n      event: {\n        target: n\n      }\n    } = e;\n    this.props = e, this.listeners = new Oe(Ce(n)), this.windowListeners = new Oe(vt(n)), this.handleKeyDown = this.handleKeyDown.bind(this), this.handleCancel = this.handleCancel.bind(this), this.attach();\n  }\n  attach() {\n    this.handleStart(), this.windowListeners.add(Pt.Resize, this.handleCancel), this.windowListeners.add(Pt.VisibilityChange, this.handleCancel), setTimeout(() => this.listeners.add(Pt.Keydown, this.handleKeyDown));\n  }\n  handleStart() {\n    const {\n      activeNode: e,\n      onStart: n\n    } = this.props, s = e.node.current;\n    s && yc(s), n(jt);\n  }\n  handleKeyDown(e) {\n    if (Ws(e)) {\n      const {\n        active: n,\n        context: s,\n        options: i\n      } = this.props, {\n        keyboardCodes: r = Mo,\n        coordinateGetter: o = wc,\n        scrollBehavior: a = \"smooth\"\n      } = i, {\n        code: l\n      } = e;\n      if (r.end.includes(l)) {\n        this.handleEnd(e);\n        return;\n      }\n      if (r.cancel.includes(l)) {\n        this.handleCancel(e);\n        return;\n      }\n      const {\n        collisionRect: u\n      } = s.current, c = u ? {\n        x: u.left,\n        y: u.top\n      } : jt;\n      this.referenceCoordinates || (this.referenceCoordinates = c);\n      const d = o(e, {\n        active: n,\n        context: s.current,\n        currentCoordinates: c\n      });\n      if (d) {\n        const h = Ke(d, c), f = {\n          x: 0,\n          y: 0\n        }, {\n          scrollableAncestors: g\n        } = s.current;\n        for (const v of g) {\n          const y = e.code, {\n            isTop: x,\n            isRight: T,\n            isLeft: b,\n            isBottom: P,\n            maxScroll: D,\n            minScroll: R\n          } = Po(v), m = pc(v), w = {\n            x: Math.min(y === $.Right ? m.right - m.width / 2 : m.right, Math.max(y === $.Right ? m.left : m.left + m.width / 2, d.x)),\n            y: Math.min(y === $.Down ? m.bottom - m.height / 2 : m.bottom, Math.max(y === $.Down ? m.top : m.top + m.height / 2, d.y))\n          }, C = y === $.Right && !T || y === $.Left && !b, M = y === $.Down && !P || y === $.Up && !x;\n          if (C && w.x !== d.x) {\n            const S = v.scrollLeft + h.x, N = y === $.Right && S <= D.x || y === $.Left && S >= R.x;\n            if (N && !h.y) {\n              v.scrollTo({\n                left: S,\n                behavior: a\n              });\n              return;\n            }\n            N ? f.x = v.scrollLeft - S : f.x = y === $.Right ? v.scrollLeft - D.x : v.scrollLeft - R.x, f.x && v.scrollBy({\n              left: -f.x,\n              behavior: a\n            });\n            break;\n          } else if (M && w.y !== d.y) {\n            const S = v.scrollTop + h.y, N = y === $.Down && S <= D.y || y === $.Up && S >= R.y;\n            if (N && !h.x) {\n              v.scrollTo({\n                top: S,\n                behavior: a\n              });\n              return;\n            }\n            N ? f.y = v.scrollTop - S : f.y = y === $.Down ? v.scrollTop - D.y : v.scrollTop - R.y, f.y && v.scrollBy({\n              top: -f.y,\n              behavior: a\n            });\n            break;\n          }\n        }\n        this.handleMove(e, be(Ke(d, this.referenceCoordinates), f));\n      }\n    }\n  }\n  handleMove(e, n) {\n    const {\n      onMove: s\n    } = this.props;\n    e.preventDefault(), s(n);\n  }\n  handleEnd(e) {\n    const {\n      onEnd: n\n    } = this.props;\n    e.preventDefault(), this.detach(), n();\n  }\n  handleCancel(e) {\n    const {\n      onCancel: n\n    } = this.props;\n    e.preventDefault(), this.detach(), n();\n  }\n  detach() {\n    this.listeners.removeAll(), this.windowListeners.removeAll();\n  }\n}\nGs.activators = [{\n  eventName: \"onKeyDown\",\n  handler: (t, e, n) => {\n    let {\n      keyboardCodes: s = Mo,\n      onActivation: i\n    } = e, {\n      active: r\n    } = n;\n    const {\n      code: o\n    } = t.nativeEvent;\n    if (s.start.includes(o)) {\n      const a = r.activatorNode.current;\n      return a && t.target !== a ? !1 : (t.preventDefault(), i?.({\n        event: t.nativeEvent\n      }), !0);\n    }\n    return !1;\n  }\n}];\nfunction Ui(t) {\n  return !!(t && \"distance\" in t);\n}\nfunction zi(t) {\n  return !!(t && \"delay\" in t);\n}\nclass Hs {\n  constructor(e, n, s) {\n    var i;\n    s === void 0 && (s = xc(e.event.target)), this.props = void 0, this.events = void 0, this.autoScrollEnabled = !0, this.document = void 0, this.activated = !1, this.initialCoordinates = void 0, this.timeoutId = null, this.listeners = void 0, this.documentListeners = void 0, this.windowListeners = void 0, this.props = e, this.events = n;\n    const {\n      event: r\n    } = e, {\n      target: o\n    } = r;\n    this.props = e, this.events = n, this.document = Ce(o), this.documentListeners = new Oe(this.document), this.listeners = new Oe(s), this.windowListeners = new Oe(vt(o)), this.initialCoordinates = (i = ps(r)) != null ? i : jt, this.handleStart = this.handleStart.bind(this), this.handleMove = this.handleMove.bind(this), this.handleEnd = this.handleEnd.bind(this), this.handleCancel = this.handleCancel.bind(this), this.handleKeydown = this.handleKeydown.bind(this), this.removeTextSelection = this.removeTextSelection.bind(this), this.attach();\n  }\n  attach() {\n    const {\n      events: e,\n      props: {\n        options: {\n          activationConstraint: n,\n          bypassActivationConstraint: s\n        }\n      }\n    } = this;\n    if (this.listeners.add(e.move.name, this.handleMove, {\n      passive: !1\n    }), this.listeners.add(e.end.name, this.handleEnd), e.cancel && this.listeners.add(e.cancel.name, this.handleCancel), this.windowListeners.add(Pt.Resize, this.handleCancel), this.windowListeners.add(Pt.DragStart, _i), this.windowListeners.add(Pt.VisibilityChange, this.handleCancel), this.windowListeners.add(Pt.ContextMenu, _i), this.documentListeners.add(Pt.Keydown, this.handleKeydown), n) {\n      if (s != null && s({\n        event: this.props.event,\n        activeNode: this.props.activeNode,\n        options: this.props.options\n      }))\n        return this.handleStart();\n      if (zi(n)) {\n        this.timeoutId = setTimeout(this.handleStart, n.delay), this.handlePending(n);\n        return;\n      }\n      if (Ui(n)) {\n        this.handlePending(n);\n        return;\n      }\n    }\n    this.handleStart();\n  }\n  detach() {\n    this.listeners.removeAll(), this.windowListeners.removeAll(), setTimeout(this.documentListeners.removeAll, 50), this.timeoutId !== null && (clearTimeout(this.timeoutId), this.timeoutId = null);\n  }\n  handlePending(e, n) {\n    const {\n      active: s,\n      onPending: i\n    } = this.props;\n    i(s, e, this.initialCoordinates, n);\n  }\n  handleStart() {\n    const {\n      initialCoordinates: e\n    } = this, {\n      onStart: n\n    } = this.props;\n    e && (this.activated = !0, this.documentListeners.add(Pt.Click, bc, {\n      capture: !0\n    }), this.removeTextSelection(), this.documentListeners.add(Pt.SelectionChange, this.removeTextSelection), n(e));\n  }\n  handleMove(e) {\n    var n;\n    const {\n      activated: s,\n      initialCoordinates: i,\n      props: r\n    } = this, {\n      onMove: o,\n      options: {\n        activationConstraint: a\n      }\n    } = r;\n    if (!i)\n      return;\n    const l = (n = ps(e)) != null ? n : jt, u = Ke(i, l);\n    if (!s && a) {\n      if (Ui(a)) {\n        if (a.tolerance != null && Wn(u, a.tolerance))\n          return this.handleCancel();\n        if (Wn(u, a.distance))\n          return this.handleStart();\n      }\n      if (zi(a) && Wn(u, a.tolerance))\n        return this.handleCancel();\n      this.handlePending(a, u);\n      return;\n    }\n    e.cancelable && e.preventDefault(), o(l);\n  }\n  handleEnd() {\n    const {\n      onAbort: e,\n      onEnd: n\n    } = this.props;\n    this.detach(), this.activated || e(this.props.active), n();\n  }\n  handleCancel() {\n    const {\n      onAbort: e,\n      onCancel: n\n    } = this.props;\n    this.detach(), this.activated || e(this.props.active), n();\n  }\n  handleKeydown(e) {\n    e.code === $.Esc && this.handleCancel();\n  }\n  removeTextSelection() {\n    var e;\n    (e = this.document.getSelection()) == null || e.removeAllRanges();\n  }\n}\nconst Tc = {\n  cancel: {\n    name: \"pointercancel\"\n  },\n  move: {\n    name: \"pointermove\"\n  },\n  end: {\n    name: \"pointerup\"\n  }\n};\nclass Xs extends Hs {\n  constructor(e) {\n    const {\n      event: n\n    } = e, s = Ce(n.target);\n    super(e, Tc, s);\n  }\n}\nXs.activators = [{\n  eventName: \"onPointerDown\",\n  handler: (t, e) => {\n    let {\n      nativeEvent: n\n    } = t, {\n      onActivation: s\n    } = e;\n    return !n.isPrimary || n.button !== 0 ? !1 : (s?.({\n      event: n\n    }), !0);\n  }\n}];\nconst Sc = {\n  move: {\n    name: \"mousemove\"\n  },\n  end: {\n    name: \"mouseup\"\n  }\n};\nvar gs;\n(function(t) {\n  t[t.RightClick = 2] = \"RightClick\";\n})(gs || (gs = {}));\nclass Dc extends Hs {\n  constructor(e) {\n    super(e, Sc, Ce(e.event.target));\n  }\n}\nDc.activators = [{\n  eventName: \"onMouseDown\",\n  handler: (t, e) => {\n    let {\n      nativeEvent: n\n    } = t, {\n      onActivation: s\n    } = e;\n    return n.button === gs.RightClick ? !1 : (s?.({\n      event: n\n    }), !0);\n  }\n}];\nconst Kn = {\n  cancel: {\n    name: \"touchcancel\"\n  },\n  move: {\n    name: \"touchmove\"\n  },\n  end: {\n    name: \"touchend\"\n  }\n};\nclass Cc extends Hs {\n  constructor(e) {\n    super(e, Kn);\n  }\n  static setup() {\n    return window.addEventListener(Kn.move.name, e, {\n      capture: !1,\n      passive: !1\n    }), function() {\n      window.removeEventListener(Kn.move.name, e);\n    };\n    function e() {\n    }\n  }\n}\nCc.activators = [{\n  eventName: \"onTouchStart\",\n  handler: (t, e) => {\n    let {\n      nativeEvent: n\n    } = t, {\n      onActivation: s\n    } = e;\n    const {\n      touches: i\n    } = n;\n    return i.length > 1 ? !1 : (s?.({\n      event: n\n    }), !0);\n  }\n}];\nvar Fe;\n(function(t) {\n  t[t.Pointer = 0] = \"Pointer\", t[t.DraggableRect = 1] = \"DraggableRect\";\n})(Fe || (Fe = {}));\nvar Tn;\n(function(t) {\n  t[t.TreeOrder = 0] = \"TreeOrder\", t[t.ReversedTreeOrder = 1] = \"ReversedTreeOrder\";\n})(Tn || (Tn = {}));\nfunction Ac(t) {\n  let {\n    acceleration: e,\n    activator: n = Fe.Pointer,\n    canScroll: s,\n    draggingRect: i,\n    enabled: r,\n    interval: o = 5,\n    order: a = Tn.TreeOrder,\n    pointerCoordinates: l,\n    scrollableAncestors: u,\n    scrollableAncestorRects: c,\n    delta: d,\n    threshold: h\n  } = t;\n  const f = Rc({\n    delta: d,\n    disabled: !r\n  }), [g, v] = Fl(), y = j({\n    x: 0,\n    y: 0\n  }), x = j({\n    x: 0,\n    y: 0\n  }), T = W(() => {\n    switch (n) {\n      case Fe.Pointer:\n        return l ? {\n          top: l.y,\n          bottom: l.y,\n          left: l.x,\n          right: l.x\n        } : null;\n      case Fe.DraggableRect:\n        return i;\n    }\n  }, [n, i, l]), b = j(null), P = lt(() => {\n    const R = b.current;\n    if (!R)\n      return;\n    const m = y.current.x * x.current.x, w = y.current.y * x.current.y;\n    R.scrollBy(m, w);\n  }, []), D = W(() => a === Tn.TreeOrder ? [...u].reverse() : u, [a, u]);\n  B(\n    () => {\n      if (!r || !u.length || !T) {\n        v();\n        return;\n      }\n      for (const R of D) {\n        if (s?.(R) === !1)\n          continue;\n        const m = u.indexOf(R), w = c[m];\n        if (!w)\n          continue;\n        const {\n          direction: C,\n          speed: M\n        } = fc(R, w, T, e, h);\n        for (const S of [\"x\", \"y\"])\n          f[S][C[S]] || (M[S] = 0, C[S] = 0);\n        if (M.x > 0 || M.y > 0) {\n          v(), b.current = R, g(P, o), y.current = M, x.current = C;\n          return;\n        }\n      }\n      y.current = {\n        x: 0,\n        y: 0\n      }, x.current = {\n        x: 0,\n        y: 0\n      }, v();\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [\n      e,\n      P,\n      s,\n      v,\n      r,\n      o,\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      JSON.stringify(T),\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      JSON.stringify(f),\n      g,\n      u,\n      D,\n      c,\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n      JSON.stringify(h)\n    ]\n  );\n}\nconst Pc = {\n  x: {\n    [at.Backward]: !1,\n    [at.Forward]: !1\n  },\n  y: {\n    [at.Backward]: !1,\n    [at.Forward]: !1\n  }\n};\nfunction Rc(t) {\n  let {\n    delta: e,\n    disabled: n\n  } = t;\n  const s = fs(e);\n  return tn((i) => {\n    if (n || !s || !i)\n      return Pc;\n    const r = {\n      x: Math.sign(e.x - s.x),\n      y: Math.sign(e.y - s.y)\n    };\n    return {\n      x: {\n        [at.Backward]: i.x[at.Backward] || r.x === -1,\n        [at.Forward]: i.x[at.Forward] || r.x === 1\n      },\n      y: {\n        [at.Backward]: i.y[at.Backward] || r.y === -1,\n        [at.Forward]: i.y[at.Forward] || r.y === 1\n      }\n    };\n  }, [n, e, s]);\n}\nfunction Mc(t, e) {\n  const n = e != null ? t.get(e) : void 0, s = n ? n.node.current : null;\n  return tn((i) => {\n    var r;\n    return e == null ? null : (r = s ?? i) != null ? r : null;\n  }, [s, e]);\n}\nfunction Ec(t, e) {\n  return W(() => t.reduce((n, s) => {\n    const {\n      sensor: i\n    } = s, r = i.activators.map((o) => ({\n      eventName: o.eventName,\n      handler: e(o.handler, s)\n    }));\n    return [...n, ...r];\n  }, []), [t, e]);\n}\nvar He;\n(function(t) {\n  t[t.Always = 0] = \"Always\", t[t.BeforeDragging = 1] = \"BeforeDragging\", t[t.WhileDragging = 2] = \"WhileDragging\";\n})(He || (He = {}));\nvar ys;\n(function(t) {\n  t.Optimized = \"optimized\";\n})(ys || (ys = {}));\nconst Wi = /* @__PURE__ */ new Map();\nfunction Vc(t, e) {\n  let {\n    dragging: n,\n    dependencies: s,\n    config: i\n  } = e;\n  const [r, o] = L(null), {\n    frequency: a,\n    measure: l,\n    strategy: u\n  } = i, c = j(t), d = y(), h = We(d), f = lt(function(x) {\n    x === void 0 && (x = []), !h.current && o((T) => T === null ? x : T.concat(x.filter((b) => !T.includes(b))));\n  }, [h]), g = j(null), v = tn((x) => {\n    if (d && !n)\n      return Wi;\n    if (!x || x === Wi || c.current !== t || r != null) {\n      const T = /* @__PURE__ */ new Map();\n      for (let b of t) {\n        if (!b)\n          continue;\n        if (r && r.length > 0 && !r.includes(b.id) && b.rect.current) {\n          T.set(b.id, b.rect.current);\n          continue;\n        }\n        const P = b.node.current, D = P ? new Ks(l(P), P) : null;\n        b.rect.current = D, D && T.set(b.id, D);\n      }\n      return T;\n    }\n    return x;\n  }, [t, r, n, d, l]);\n  return B(() => {\n    c.current = t;\n  }, [t]), B(\n    () => {\n      d || f();\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [n, d]\n  ), B(\n    () => {\n      r && r.length > 0 && o(null);\n    },\n    //eslint-disable-next-line react-hooks/exhaustive-deps\n    [JSON.stringify(r)]\n  ), B(\n    () => {\n      d || typeof a != \"number\" || g.current !== null || (g.current = setTimeout(() => {\n        f(), g.current = null;\n      }, a));\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [a, d, f, ...s]\n  ), {\n    droppableRects: v,\n    measureDroppableContainers: f,\n    measuringScheduled: r != null\n  };\n  function y() {\n    switch (u) {\n      case He.Always:\n        return !1;\n      case He.BeforeDragging:\n        return n;\n      default:\n        return !n;\n    }\n  }\n}\nfunction Eo(t, e) {\n  return tn((n) => t ? n || (typeof e == \"function\" ? e(t) : t) : null, [e, t]);\n}\nfunction Nc(t, e) {\n  return Eo(t, e);\n}\nfunction kc(t) {\n  let {\n    callback: e,\n    disabled: n\n  } = t;\n  const s = zs(e), i = W(() => {\n    if (n || typeof window > \"u\" || typeof window.MutationObserver > \"u\")\n      return;\n    const {\n      MutationObserver: r\n    } = window;\n    return new r(s);\n  }, [s, n]);\n  return B(() => () => i?.disconnect(), [i]), i;\n}\nfunction kn(t) {\n  let {\n    callback: e,\n    disabled: n\n  } = t;\n  const s = zs(e), i = W(\n    () => {\n      if (n || typeof window > \"u\" || typeof window.ResizeObserver > \"u\")\n        return;\n      const {\n        ResizeObserver: r\n      } = window;\n      return new r(s);\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [n]\n  );\n  return B(() => () => i?.disconnect(), [i]), i;\n}\nfunction Ic(t) {\n  return new Ks(Ae(t), t);\n}\nfunction Ki(t, e, n) {\n  e === void 0 && (e = Ic);\n  const [s, i] = L(null);\n  function r() {\n    i((l) => {\n      if (!t)\n        return null;\n      if (t.isConnected === !1) {\n        var u;\n        return (u = l ?? n) != null ? u : null;\n      }\n      const c = e(t);\n      return JSON.stringify(l) === JSON.stringify(c) ? l : c;\n    });\n  }\n  const o = kc({\n    callback(l) {\n      if (t)\n        for (const u of l) {\n          const {\n            type: c,\n            target: d\n          } = u;\n          if (c === \"childList\" && d instanceof HTMLElement && d.contains(t)) {\n            r();\n            break;\n          }\n        }\n    }\n  }), a = kn({\n    callback: r\n  });\n  return Wt(() => {\n    r(), t ? (a?.observe(t), o?.observe(document.body, {\n      childList: !0,\n      subtree: !0\n    })) : (a?.disconnect(), o?.disconnect());\n  }, [t]), s;\n}\nfunction jc(t) {\n  const e = Eo(t);\n  return To(t, e);\n}\nconst Gi = [];\nfunction Lc(t) {\n  const e = j(t), n = tn((s) => t ? s && s !== Gi && t && e.current && t.parentNode === e.current.parentNode ? s : Nn(t) : Gi, [t]);\n  return B(() => {\n    e.current = t;\n  }, [t]), n;\n}\nfunction Oc(t) {\n  const [e, n] = L(null), s = j(t), i = lt((r) => {\n    const o = zn(r.target);\n    o && n((a) => a ? (a.set(o, ms(o)), new Map(a)) : null);\n  }, []);\n  return B(() => {\n    const r = s.current;\n    if (t !== r) {\n      o(r);\n      const a = t.map((l) => {\n        const u = zn(l);\n        return u ? (u.addEventListener(\"scroll\", i, {\n          passive: !0\n        }), [u, ms(u)]) : null;\n      }).filter((l) => l != null);\n      n(a.length ? new Map(a) : null), s.current = t;\n    }\n    return () => {\n      o(t), o(r);\n    };\n    function o(a) {\n      a.forEach((l) => {\n        const u = zn(l);\n        u?.removeEventListener(\"scroll\", i);\n      });\n    }\n  }, [i, t]), W(() => t.length ? e ? Array.from(e.values()).reduce((r, o) => be(r, o), jt) : Ro(t) : jt, [t, e]);\n}\nfunction Hi(t, e) {\n  e === void 0 && (e = []);\n  const n = j(null);\n  return B(\n    () => {\n      n.current = null;\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    e\n  ), B(() => {\n    const s = t !== jt;\n    s && !n.current && (n.current = t), !s && n.current && (n.current = null);\n  }, [t]), n.current ? Ke(t, n.current) : jt;\n}\nfunction Fc(t) {\n  B(\n    () => {\n      if (!Vn)\n        return;\n      const e = t.map((n) => {\n        let {\n          sensor: s\n        } = n;\n        return s.setup == null ? void 0 : s.setup();\n      });\n      return () => {\n        for (const n of e)\n          n?.();\n      };\n    },\n    // TO-DO: Sensors length could theoretically change which would not be a valid dependency\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    t.map((e) => {\n      let {\n        sensor: n\n      } = e;\n      return n;\n    })\n  );\n}\nfunction Bc(t, e) {\n  return W(() => t.reduce((n, s) => {\n    let {\n      eventName: i,\n      handler: r\n    } = s;\n    return n[i] = (o) => {\n      r(o, e);\n    }, n;\n  }, {}), [t, e]);\n}\nfunction Vo(t) {\n  return W(() => t ? cc(t) : null, [t]);\n}\nconst Xi = [];\nfunction $c(t, e) {\n  e === void 0 && (e = Ae);\n  const [n] = t, s = Vo(n ? vt(n) : null), [i, r] = L(Xi);\n  function o() {\n    r(() => t.length ? t.map((l) => Ao(l) ? s : new Ks(e(l), l)) : Xi);\n  }\n  const a = kn({\n    callback: o\n  });\n  return Wt(() => {\n    a?.disconnect(), o(), t.forEach((l) => a?.observe(l));\n  }, [t]), i;\n}\nfunction _c(t) {\n  if (!t)\n    return null;\n  if (t.children.length > 1)\n    return t;\n  const e = t.children[0];\n  return Qe(e) ? e : t;\n}\nfunction Uc(t) {\n  let {\n    measure: e\n  } = t;\n  const [n, s] = L(null), i = lt((u) => {\n    for (const {\n      target: c\n    } of u)\n      if (Qe(c)) {\n        s((d) => {\n          const h = e(c);\n          return d ? {\n            ...d,\n            width: h.width,\n            height: h.height\n          } : h;\n        });\n        break;\n      }\n  }, [e]), r = kn({\n    callback: i\n  }), o = lt((u) => {\n    const c = _c(u);\n    r?.disconnect(), c && r?.observe(c), s(c ? e(c) : null);\n  }, [e, r]), [a, l] = bn(o);\n  return W(() => ({\n    nodeRef: a,\n    rect: n,\n    setRef: l\n  }), [n, a, l]);\n}\nconst zc = [{\n  sensor: Xs,\n  options: {}\n}, {\n  sensor: Gs,\n  options: {}\n}], Wc = {\n  current: {}\n}, mn = {\n  draggable: {\n    measure: $i\n  },\n  droppable: {\n    measure: $i,\n    strategy: He.WhileDragging,\n    frequency: ys.Optimized\n  },\n  dragOverlay: {\n    measure: Ae\n  }\n};\nclass Be extends Map {\n  get(e) {\n    var n;\n    return e != null && (n = super.get(e)) != null ? n : void 0;\n  }\n  toArray() {\n    return Array.from(this.values());\n  }\n  getEnabled() {\n    return this.toArray().filter((e) => {\n      let {\n        disabled: n\n      } = e;\n      return !n;\n    });\n  }\n  getNodeFor(e) {\n    var n, s;\n    return (n = (s = this.get(e)) == null ? void 0 : s.node.current) != null ? n : void 0;\n  }\n}\nconst Kc = {\n  activatorEvent: null,\n  active: null,\n  activeNode: null,\n  activeNodeRect: null,\n  collisions: null,\n  containerNodeRect: null,\n  draggableNodes: /* @__PURE__ */ new Map(),\n  droppableRects: /* @__PURE__ */ new Map(),\n  droppableContainers: /* @__PURE__ */ new Be(),\n  over: null,\n  dragOverlay: {\n    nodeRef: {\n      current: null\n    },\n    rect: null,\n    setRef: wn\n  },\n  scrollableAncestors: [],\n  scrollableAncestorRects: [],\n  measuringConfiguration: mn,\n  measureDroppableContainers: wn,\n  windowRect: null,\n  measuringScheduled: !1\n}, Gc = {\n  activatorEvent: null,\n  activators: [],\n  active: null,\n  activeNodeRect: null,\n  ariaDescribedById: {\n    draggable: \"\"\n  },\n  dispatch: wn,\n  draggableNodes: /* @__PURE__ */ new Map(),\n  over: null,\n  measureDroppableContainers: wn\n}, In = /* @__PURE__ */ Lt(Gc), No = /* @__PURE__ */ Lt(Kc);\nfunction Hc() {\n  return {\n    draggable: {\n      active: null,\n      initialCoordinates: {\n        x: 0,\n        y: 0\n      },\n      nodes: /* @__PURE__ */ new Map(),\n      translate: {\n        x: 0,\n        y: 0\n      }\n    },\n    droppable: {\n      containers: new Be()\n    }\n  };\n}\nfunction Xc(t, e) {\n  switch (e.type) {\n    case it.DragStart:\n      return {\n        ...t,\n        draggable: {\n          ...t.draggable,\n          initialCoordinates: e.initialCoordinates,\n          active: e.active\n        }\n      };\n    case it.DragMove:\n      return t.draggable.active == null ? t : {\n        ...t,\n        draggable: {\n          ...t.draggable,\n          translate: {\n            x: e.coordinates.x - t.draggable.initialCoordinates.x,\n            y: e.coordinates.y - t.draggable.initialCoordinates.y\n          }\n        }\n      };\n    case it.DragEnd:\n    case it.DragCancel:\n      return {\n        ...t,\n        draggable: {\n          ...t.draggable,\n          active: null,\n          initialCoordinates: {\n            x: 0,\n            y: 0\n          },\n          translate: {\n            x: 0,\n            y: 0\n          }\n        }\n      };\n    case it.RegisterDroppable: {\n      const {\n        element: n\n      } = e, {\n        id: s\n      } = n, i = new Be(t.droppable.containers);\n      return i.set(s, n), {\n        ...t,\n        droppable: {\n          ...t.droppable,\n          containers: i\n        }\n      };\n    }\n    case it.SetDroppableDisabled: {\n      const {\n        id: n,\n        key: s,\n        disabled: i\n      } = e, r = t.droppable.containers.get(n);\n      if (!r || s !== r.key)\n        return t;\n      const o = new Be(t.droppable.containers);\n      return o.set(n, {\n        ...r,\n        disabled: i\n      }), {\n        ...t,\n        droppable: {\n          ...t.droppable,\n          containers: o\n        }\n      };\n    }\n    case it.UnregisterDroppable: {\n      const {\n        id: n,\n        key: s\n      } = e, i = t.droppable.containers.get(n);\n      if (!i || s !== i.key)\n        return t;\n      const r = new Be(t.droppable.containers);\n      return r.delete(n), {\n        ...t,\n        droppable: {\n          ...t.droppable,\n          containers: r\n        }\n      };\n    }\n    default:\n      return t;\n  }\n}\nfunction Yc(t) {\n  let {\n    disabled: e\n  } = t;\n  const {\n    active: n,\n    activatorEvent: s,\n    draggableNodes: i\n  } = q(In), r = fs(s), o = fs(n?.id);\n  return B(() => {\n    if (!e && !s && r && o != null) {\n      if (!Ws(r) || document.activeElement === r.target)\n        return;\n      const a = i.get(o);\n      if (!a)\n        return;\n      const {\n        activatorNode: l,\n        node: u\n      } = a;\n      if (!l.current && !u.current)\n        return;\n      requestAnimationFrame(() => {\n        for (const c of [l.current, u.current]) {\n          if (!c)\n            continue;\n          const d = _l(c);\n          if (d) {\n            d.focus();\n            break;\n          }\n        }\n      });\n    }\n  }, [s, e, i, o, r]), null;\n}\nfunction qc(t, e) {\n  let {\n    transform: n,\n    ...s\n  } = e;\n  return t != null && t.length ? t.reduce((i, r) => r({\n    transform: i,\n    ...s\n  }), n) : n;\n}\nfunction Jc(t) {\n  return W(\n    () => ({\n      draggable: {\n        ...mn.draggable,\n        ...t?.draggable\n      },\n      droppable: {\n        ...mn.droppable,\n        ...t?.droppable\n      },\n      dragOverlay: {\n        ...mn.dragOverlay,\n        ...t?.dragOverlay\n      }\n    }),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [t?.draggable, t?.droppable, t?.dragOverlay]\n  );\n}\nfunction Zc(t) {\n  let {\n    activeNode: e,\n    measure: n,\n    initialRect: s,\n    config: i = !0\n  } = t;\n  const r = j(!1), {\n    x: o,\n    y: a\n  } = typeof i == \"boolean\" ? {\n    x: i,\n    y: i\n  } : i;\n  Wt(() => {\n    if (!o && !a || !e) {\n      r.current = !1;\n      return;\n    }\n    if (r.current || !s)\n      return;\n    const u = e?.node.current;\n    if (!u || u.isConnected === !1)\n      return;\n    const c = n(u), d = To(c, s);\n    if (o || (d.x = 0), a || (d.y = 0), r.current = !0, Math.abs(d.x) > 0 || Math.abs(d.y) > 0) {\n      const h = So(u);\n      h && h.scrollBy({\n        top: d.y,\n        left: d.x\n      });\n    }\n  }, [e, o, a, s, n]);\n}\nconst ko = /* @__PURE__ */ Lt({\n  ...jt,\n  scaleX: 1,\n  scaleY: 1\n});\nvar te;\n(function(t) {\n  t[t.Uninitialized = 0] = \"Uninitialized\", t[t.Initializing = 1] = \"Initializing\", t[t.Initialized = 2] = \"Initialized\";\n})(te || (te = {}));\nconst Qc = /* @__PURE__ */ Pl(function(e) {\n  var n, s, i, r;\n  let {\n    id: o,\n    accessibility: a,\n    autoScroll: l = !0,\n    children: u,\n    sensors: c = zc,\n    collisionDetection: d = nc,\n    measuring: h,\n    modifiers: f,\n    ...g\n  } = e;\n  const v = Rl(Xc, void 0, Hc), [y, x] = v, [T, b] = Hl(), [P, D] = L(te.Uninitialized), R = P === te.Initialized, {\n    draggable: {\n      active: m,\n      nodes: w,\n      translate: C\n    },\n    droppable: {\n      containers: M\n    }\n  } = y, S = m != null ? w.get(m) : null, N = j({\n    initial: null,\n    translated: null\n  }), O = W(() => {\n    var ht;\n    return m != null ? {\n      id: m,\n      // It's possible for the active node to unmount while dragging\n      data: (ht = S?.data) != null ? ht : Wc,\n      rect: N\n    } : null;\n  }, [m, S]), F = j(null), [G, _] = L(null), [k, U] = L(null), H = We(g, Object.values(g)), tt = en(\"DndDescribedBy\", o), et = W(() => M.getEnabled(), [M]), X = Jc(h), {\n    droppableRects: dt,\n    measureDroppableContainers: xt,\n    measuringScheduled: Ot\n  } = Vc(et, {\n    dragging: R,\n    dependencies: [C.x, C.y],\n    config: X.droppable\n  }), pt = Mc(w, m), ie = W(() => k ? ps(k) : null, [k]), Ft = Al(), Et = Nc(pt, X.draggable.measure);\n  Zc({\n    activeNode: m != null ? w.get(m) : null,\n    config: Ft.layoutShiftCompensation,\n    initialRect: Et,\n    measure: X.draggable.measure\n  });\n  const K = Ki(pt, X.draggable.measure, Et), re = Ki(pt ? pt.parentElement : null), St = j({\n    activatorEvent: null,\n    active: null,\n    activeNode: pt,\n    collisionRect: null,\n    collisions: null,\n    droppableRects: dt,\n    draggableNodes: w,\n    draggingNode: null,\n    draggingNodeRect: null,\n    droppableContainers: M,\n    over: null,\n    scrollableAncestors: [],\n    scrollAdjustedTranslate: null\n  }), Xt = M.getNodeFor((n = St.current.over) == null ? void 0 : n.id), A = Uc({\n    measure: X.dragOverlay.measure\n  }), V = (s = A.nodeRef.current) != null ? s : pt, E = R ? (i = A.rect) != null ? i : K : null, z = !!(A.nodeRef.current && A.rect), Z = jc(z ? null : K), rt = Vo(V ? vt(V) : null), ot = Lc(R ? Xt ?? pt : null), Vt = $c(ot), Dt = qc(f, {\n    transform: {\n      x: C.x - Z.x,\n      y: C.y - Z.y,\n      scaleX: 1,\n      scaleY: 1\n    },\n    activatorEvent: k,\n    active: O,\n    activeNodeRect: K,\n    containerNodeRect: re,\n    draggingNodeRect: E,\n    over: St.current.over,\n    overlayNodeRect: A.rect,\n    scrollableAncestors: ot,\n    scrollableAncestorRects: Vt,\n    windowRect: rt\n  }), Nt = ie ? be(ie, C) : null, an = Oc(ot), xl = Hi(an), bl = Hi(an, [K]), he = be(Dt, xl), fe = E ? rc(E, Dt) : null, Ee = O && fe ? d({\n    active: O,\n    collisionRect: fe,\n    droppableRects: dt,\n    droppableContainers: et,\n    pointerCoordinates: Nt\n  }) : null, Ei = wo(Ee, \"id\"), [Yt, Vi] = L(null), wl = z ? Dt : be(Dt, bl), Tl = sc(wl, (r = Yt?.rect) != null ? r : null, K), Bn = j(null), Ni = lt(\n    (ht, bt) => {\n      let {\n        sensor: wt,\n        options: qt\n      } = bt;\n      if (F.current == null)\n        return;\n      const Ct = w.get(F.current);\n      if (!Ct)\n        return;\n      const Tt = ht.nativeEvent, Bt = new wt({\n        active: F.current,\n        activeNode: Ct,\n        event: Tt,\n        options: qt,\n        // Sensors need to be instantiated with refs for arguments that change over time\n        // otherwise they are frozen in time with the stale arguments\n        context: St,\n        onAbort(ct) {\n          if (!w.get(ct))\n            return;\n          const {\n            onDragAbort: $t\n          } = H.current, Kt = {\n            id: ct\n          };\n          $t?.(Kt), T({\n            type: \"onDragAbort\",\n            event: Kt\n          });\n        },\n        onPending(ct, Jt, $t, Kt) {\n          if (!w.get(ct))\n            return;\n          const {\n            onDragPending: Ne\n          } = H.current, Zt = {\n            id: ct,\n            constraint: Jt,\n            initialCoordinates: $t,\n            offset: Kt\n          };\n          Ne?.(Zt), T({\n            type: \"onDragPending\",\n            event: Zt\n          });\n        },\n        onStart(ct) {\n          const Jt = F.current;\n          if (Jt == null)\n            return;\n          const $t = w.get(Jt);\n          if (!$t)\n            return;\n          const {\n            onDragStart: Kt\n          } = H.current, Ve = {\n            activatorEvent: Tt,\n            active: {\n              id: Jt,\n              data: $t.data,\n              rect: N\n            }\n          };\n          ln(() => {\n            Kt?.(Ve), D(te.Initializing), x({\n              type: it.DragStart,\n              initialCoordinates: ct,\n              active: Jt\n            }), T({\n              type: \"onDragStart\",\n              event: Ve\n            }), _(Bn.current), U(Tt);\n          });\n        },\n        onMove(ct) {\n          x({\n            type: it.DragMove,\n            coordinates: ct\n          });\n        },\n        onEnd: pe(it.DragEnd),\n        onCancel: pe(it.DragCancel)\n      });\n      Bn.current = Bt;\n      function pe(ct) {\n        return async function() {\n          const {\n            active: $t,\n            collisions: Kt,\n            over: Ve,\n            scrollAdjustedTranslate: Ne\n          } = St.current;\n          let Zt = null;\n          if ($t && Ne) {\n            const {\n              cancelDrop: ke\n            } = H.current;\n            Zt = {\n              activatorEvent: Tt,\n              active: $t,\n              collisions: Kt,\n              delta: Ne,\n              over: Ve\n            }, ct === it.DragEnd && typeof ke == \"function\" && await Promise.resolve(ke(Zt)) && (ct = it.DragCancel);\n          }\n          F.current = null, ln(() => {\n            x({\n              type: ct\n            }), D(te.Uninitialized), Vi(null), _(null), U(null), Bn.current = null;\n            const ke = ct === it.DragEnd ? \"onDragEnd\" : \"onDragCancel\";\n            if (Zt) {\n              const $n = H.current[ke];\n              $n?.(Zt), T({\n                type: ke,\n                event: Zt\n              });\n            }\n          });\n        };\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [w]\n  ), Sl = lt((ht, bt) => (wt, qt) => {\n    const Ct = wt.nativeEvent, Tt = w.get(qt);\n    if (\n      // Another sensor is already instantiating\n      F.current !== null || // No active draggable\n      !Tt || // Event has already been captured\n      Ct.dndKit || Ct.defaultPrevented\n    )\n      return;\n    const Bt = {\n      active: Tt\n    };\n    ht(wt, bt.options, Bt) === !0 && (Ct.dndKit = {\n      capturedBy: bt.sensor\n    }, F.current = qt, Ni(wt, bt));\n  }, [w, Ni]), ki = Ec(c, Sl);\n  Fc(c), Wt(() => {\n    K && P === te.Initializing && D(te.Initialized);\n  }, [K, P]), B(\n    () => {\n      const {\n        onDragMove: ht\n      } = H.current, {\n        active: bt,\n        activatorEvent: wt,\n        collisions: qt,\n        over: Ct\n      } = St.current;\n      if (!bt || !wt)\n        return;\n      const Tt = {\n        active: bt,\n        activatorEvent: wt,\n        collisions: qt,\n        delta: {\n          x: he.x,\n          y: he.y\n        },\n        over: Ct\n      };\n      ln(() => {\n        ht?.(Tt), T({\n          type: \"onDragMove\",\n          event: Tt\n        });\n      });\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [he.x, he.y]\n  ), B(\n    () => {\n      const {\n        active: ht,\n        activatorEvent: bt,\n        collisions: wt,\n        droppableContainers: qt,\n        scrollAdjustedTranslate: Ct\n      } = St.current;\n      if (!ht || F.current == null || !bt || !Ct)\n        return;\n      const {\n        onDragOver: Tt\n      } = H.current, Bt = qt.get(Ei), pe = Bt && Bt.rect.current ? {\n        id: Bt.id,\n        rect: Bt.rect.current,\n        data: Bt.data,\n        disabled: Bt.disabled\n      } : null, ct = {\n        active: ht,\n        activatorEvent: bt,\n        collisions: wt,\n        delta: {\n          x: Ct.x,\n          y: Ct.y\n        },\n        over: pe\n      };\n      ln(() => {\n        Vi(pe), Tt?.(ct), T({\n          type: \"onDragOver\",\n          event: ct\n        });\n      });\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [Ei]\n  ), Wt(() => {\n    St.current = {\n      activatorEvent: k,\n      active: O,\n      activeNode: pt,\n      collisionRect: fe,\n      collisions: Ee,\n      droppableRects: dt,\n      draggableNodes: w,\n      draggingNode: V,\n      draggingNodeRect: E,\n      droppableContainers: M,\n      over: Yt,\n      scrollableAncestors: ot,\n      scrollAdjustedTranslate: he\n    }, N.current = {\n      initial: E,\n      translated: fe\n    };\n  }, [O, pt, Ee, fe, w, V, E, dt, M, Yt, ot, he]), Ac({\n    ...Ft,\n    delta: C,\n    draggingRect: fe,\n    pointerCoordinates: Nt,\n    scrollableAncestors: ot,\n    scrollableAncestorRects: Vt\n  });\n  const Dl = W(() => ({\n    active: O,\n    activeNode: pt,\n    activeNodeRect: K,\n    activatorEvent: k,\n    collisions: Ee,\n    containerNodeRect: re,\n    dragOverlay: A,\n    draggableNodes: w,\n    droppableContainers: M,\n    droppableRects: dt,\n    over: Yt,\n    measureDroppableContainers: xt,\n    scrollableAncestors: ot,\n    scrollableAncestorRects: Vt,\n    measuringConfiguration: X,\n    measuringScheduled: Ot,\n    windowRect: rt\n  }), [O, pt, K, k, Ee, re, A, w, M, dt, Yt, xt, ot, Vt, X, Ot, rt]), Cl = W(() => ({\n    activatorEvent: k,\n    activators: ki,\n    active: O,\n    activeNodeRect: K,\n    ariaDescribedById: {\n      draggable: tt\n    },\n    dispatch: x,\n    draggableNodes: w,\n    over: Yt,\n    measureDroppableContainers: xt\n  }), [k, ki, O, K, x, tt, w, Yt, xt]);\n  return mt.createElement(vo.Provider, {\n    value: b\n  }, mt.createElement(In.Provider, {\n    value: Cl\n  }, mt.createElement(No.Provider, {\n    value: Dl\n  }, mt.createElement(ko.Provider, {\n    value: Tl\n  }, u)), mt.createElement(Yc, {\n    disabled: a?.restoreFocus === !1\n  })), mt.createElement(ql, {\n    ...a,\n    hiddenTextDescribedById: tt\n  }));\n  function Al() {\n    const ht = G?.autoScrollEnabled === !1, bt = typeof l == \"object\" ? l.enabled === !1 : l === !1, wt = R && !ht && !bt;\n    return typeof l == \"object\" ? {\n      ...l,\n      enabled: wt\n    } : {\n      enabled: wt\n    };\n  }\n}), tu = /* @__PURE__ */ Lt(null), Yi = \"button\", eu = \"Draggable\";\nfunction nu(t) {\n  let {\n    id: e,\n    data: n,\n    disabled: s = !1,\n    attributes: i\n  } = t;\n  const r = en(eu), {\n    activators: o,\n    activatorEvent: a,\n    active: l,\n    activeNodeRect: u,\n    ariaDescribedById: c,\n    draggableNodes: d,\n    over: h\n  } = q(In), {\n    role: f = Yi,\n    roleDescription: g = \"draggable\",\n    tabIndex: v = 0\n  } = i ?? {}, y = l?.id === e, x = q(y ? ko : tu), [T, b] = bn(), [P, D] = bn(), R = Bc(o, e), m = We(n);\n  Wt(\n    () => (d.set(e, {\n      id: e,\n      key: r,\n      node: T,\n      activatorNode: P,\n      data: m\n    }), () => {\n      const C = d.get(e);\n      C && C.key === r && d.delete(e);\n    }),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [d, e]\n  );\n  const w = W(() => ({\n    role: f,\n    tabIndex: v,\n    \"aria-disabled\": s,\n    \"aria-pressed\": y && f === Yi ? !0 : void 0,\n    \"aria-roledescription\": g,\n    \"aria-describedby\": c.draggable\n  }), [s, f, v, y, g, c.draggable]);\n  return {\n    active: l,\n    activatorEvent: a,\n    activeNodeRect: u,\n    attributes: w,\n    isDragging: y,\n    listeners: s ? void 0 : R,\n    node: T,\n    over: h,\n    setNodeRef: b,\n    setActivatorNodeRef: D,\n    transform: x\n  };\n}\nfunction su() {\n  return q(No);\n}\nconst iu = \"Droppable\", ru = {\n  timeout: 25\n};\nfunction ou(t) {\n  let {\n    data: e,\n    disabled: n = !1,\n    id: s,\n    resizeObserverConfig: i\n  } = t;\n  const r = en(iu), {\n    active: o,\n    dispatch: a,\n    over: l,\n    measureDroppableContainers: u\n  } = q(In), c = j({\n    disabled: n\n  }), d = j(!1), h = j(null), f = j(null), {\n    disabled: g,\n    updateMeasurementsFor: v,\n    timeout: y\n  } = {\n    ...ru,\n    ...i\n  }, x = We(v ?? s), T = lt(\n    () => {\n      if (!d.current) {\n        d.current = !0;\n        return;\n      }\n      f.current != null && clearTimeout(f.current), f.current = setTimeout(() => {\n        u(Array.isArray(x.current) ? x.current : [x.current]), f.current = null;\n      }, y);\n    },\n    //eslint-disable-next-line react-hooks/exhaustive-deps\n    [y]\n  ), b = kn({\n    callback: T,\n    disabled: g || !o\n  }), P = lt((w, C) => {\n    b && (C && (b.unobserve(C), d.current = !1), w && b.observe(w));\n  }, [b]), [D, R] = bn(P), m = We(e);\n  return B(() => {\n    !b || !D.current || (b.disconnect(), d.current = !1, b.observe(D.current));\n  }, [D, b]), B(\n    () => (a({\n      type: it.RegisterDroppable,\n      element: {\n        id: s,\n        key: r,\n        disabled: n,\n        node: D,\n        rect: h,\n        data: m\n      }\n    }), () => a({\n      type: it.UnregisterDroppable,\n      key: r,\n      id: s\n    })),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [s]\n  ), B(() => {\n    n !== c.current.disabled && (a({\n      type: it.SetDroppableDisabled,\n      id: s,\n      key: r,\n      disabled: n\n    }), c.current.disabled = n);\n  }, [s, r, n, a]), {\n    active: o,\n    rect: h,\n    isOver: l?.id === s,\n    node: D,\n    over: l,\n    setNodeRef: R\n  };\n}\nfunction Ys(t, e, n) {\n  const s = t.slice();\n  return s.splice(n < 0 ? s.length + n : n, 0, s.splice(e, 1)[0]), s;\n}\nfunction au(t, e) {\n  return t.reduce((n, s, i) => {\n    const r = e.get(s);\n    return r && (n[i] = r), n;\n  }, Array(t.length));\n}\nfunction cn(t) {\n  return t !== null && t >= 0;\n}\nfunction lu(t, e) {\n  if (t === e)\n    return !0;\n  if (t.length !== e.length)\n    return !1;\n  for (let n = 0; n < t.length; n++)\n    if (t[n] !== e[n])\n      return !1;\n  return !0;\n}\nfunction cu(t) {\n  return typeof t == \"boolean\" ? {\n    draggable: t,\n    droppable: t\n  } : t;\n}\nconst Io = (t) => {\n  let {\n    rects: e,\n    activeIndex: n,\n    overIndex: s,\n    index: i\n  } = t;\n  const r = Ys(e, s, n), o = e[i], a = r[i];\n  return !a || !o ? null : {\n    x: a.left - o.left,\n    y: a.top - o.top,\n    scaleX: a.width / o.width,\n    scaleY: a.height / o.height\n  };\n}, un = {\n  scaleX: 1,\n  scaleY: 1\n}, uu = (t) => {\n  var e;\n  let {\n    activeIndex: n,\n    activeNodeRect: s,\n    index: i,\n    rects: r,\n    overIndex: o\n  } = t;\n  const a = (e = r[n]) != null ? e : s;\n  if (!a)\n    return null;\n  if (i === n) {\n    const u = r[o];\n    return u ? {\n      x: 0,\n      y: n < o ? u.top + u.height - (a.top + a.height) : u.top - a.top,\n      ...un\n    } : null;\n  }\n  const l = du(r, i, n);\n  return i > n && i <= o ? {\n    x: 0,\n    y: -a.height - l,\n    ...un\n  } : i < n && i >= o ? {\n    x: 0,\n    y: a.height + l,\n    ...un\n  } : {\n    x: 0,\n    y: 0,\n    ...un\n  };\n};\nfunction du(t, e, n) {\n  const s = t[e], i = t[e - 1], r = t[e + 1];\n  return s ? n < e ? i ? s.top - (i.top + i.height) : r ? r.top - (s.top + s.height) : 0 : r ? r.top - (s.top + s.height) : i ? s.top - (i.top + i.height) : 0 : 0;\n}\nconst jo = \"Sortable\", Lo = /* @__PURE__ */ mt.createContext({\n  activeIndex: -1,\n  containerId: jo,\n  disableTransforms: !1,\n  items: [],\n  overIndex: -1,\n  useDragOverlay: !1,\n  sortedRects: [],\n  strategy: Io,\n  disabled: {\n    draggable: !1,\n    droppable: !1\n  }\n});\nfunction hu(t) {\n  let {\n    children: e,\n    id: n,\n    items: s,\n    strategy: i = Io,\n    disabled: r = !1\n  } = t;\n  const {\n    active: o,\n    dragOverlay: a,\n    droppableRects: l,\n    over: u,\n    measureDroppableContainers: c\n  } = su(), d = en(jo, n), h = a.rect !== null, f = W(() => s.map((R) => typeof R == \"object\" && \"id\" in R ? R.id : R), [s]), g = o != null, v = o ? f.indexOf(o.id) : -1, y = u ? f.indexOf(u.id) : -1, x = j(f), T = !lu(f, x.current), b = y !== -1 && v === -1 || T, P = cu(r);\n  Wt(() => {\n    T && g && c(f);\n  }, [T, f, g, c]), B(() => {\n    x.current = f;\n  }, [f]);\n  const D = W(\n    () => ({\n      activeIndex: v,\n      containerId: d,\n      disabled: P,\n      disableTransforms: b,\n      items: f,\n      overIndex: y,\n      useDragOverlay: h,\n      sortedRects: au(f, l),\n      strategy: i\n    }),\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [v, d, P.draggable, P.droppable, b, f, y, l, h, i]\n  );\n  return mt.createElement(Lo.Provider, {\n    value: D\n  }, e);\n}\nconst fu = (t) => {\n  let {\n    id: e,\n    items: n,\n    activeIndex: s,\n    overIndex: i\n  } = t;\n  return Ys(n, s, i).indexOf(e);\n}, pu = (t) => {\n  let {\n    containerId: e,\n    isSorting: n,\n    wasDragging: s,\n    index: i,\n    items: r,\n    newIndex: o,\n    previousItems: a,\n    previousContainerId: l,\n    transition: u\n  } = t;\n  return !u || !s || a !== r && i === o ? !1 : n ? !0 : o !== i && e === l;\n}, mu = {\n  duration: 200,\n  easing: \"ease\"\n}, Oo = \"transform\", gu = /* @__PURE__ */ Ge.Transition.toString({\n  property: Oo,\n  duration: 0,\n  easing: \"linear\"\n}), yu = {\n  roleDescription: \"sortable\"\n};\nfunction vu(t) {\n  let {\n    disabled: e,\n    index: n,\n    node: s,\n    rect: i\n  } = t;\n  const [r, o] = L(null), a = j(n);\n  return Wt(() => {\n    if (!e && n !== a.current && s.current) {\n      const l = i.current;\n      if (l) {\n        const u = Ae(s.current, {\n          ignoreTransform: !0\n        }), c = {\n          x: l.left - u.left,\n          y: l.top - u.top,\n          scaleX: l.width / u.width,\n          scaleY: l.height / u.height\n        };\n        (c.x || c.y) && o(c);\n      }\n    }\n    n !== a.current && (a.current = n);\n  }, [e, n, s, i]), B(() => {\n    r && o(null);\n  }, [r]), r;\n}\nfunction xu(t) {\n  let {\n    animateLayoutChanges: e = pu,\n    attributes: n,\n    disabled: s,\n    data: i,\n    getNewIndex: r = fu,\n    id: o,\n    strategy: a,\n    resizeObserverConfig: l,\n    transition: u = mu\n  } = t;\n  const {\n    items: c,\n    containerId: d,\n    activeIndex: h,\n    disabled: f,\n    disableTransforms: g,\n    sortedRects: v,\n    overIndex: y,\n    useDragOverlay: x,\n    strategy: T\n  } = q(Lo), b = bu(s, f), P = c.indexOf(o), D = W(() => ({\n    sortable: {\n      containerId: d,\n      index: P,\n      items: c\n    },\n    ...i\n  }), [d, i, P, c]), R = W(() => c.slice(c.indexOf(o)), [c, o]), {\n    rect: m,\n    node: w,\n    isOver: C,\n    setNodeRef: M\n  } = ou({\n    id: o,\n    data: D,\n    disabled: b.droppable,\n    resizeObserverConfig: {\n      updateMeasurementsFor: R,\n      ...l\n    }\n  }), {\n    active: S,\n    activatorEvent: N,\n    activeNodeRect: O,\n    attributes: F,\n    setNodeRef: G,\n    listeners: _,\n    isDragging: k,\n    over: U,\n    setActivatorNodeRef: H,\n    transform: tt\n  } = nu({\n    id: o,\n    data: D,\n    attributes: {\n      ...yu,\n      ...n\n    },\n    disabled: b.draggable\n  }), et = Ol(M, G), X = !!S, dt = X && !g && cn(h) && cn(y), xt = !x && k, Ot = xt && dt ? tt : null, ie = dt ? Ot ?? (a ?? T)({\n    rects: v,\n    activeNodeRect: O,\n    activeIndex: h,\n    overIndex: y,\n    index: P\n  }) : null, Ft = cn(h) && cn(y) ? r({\n    id: o,\n    items: c,\n    activeIndex: h,\n    overIndex: y\n  }) : P, Et = S?.id, K = j({\n    activeId: Et,\n    items: c,\n    newIndex: Ft,\n    containerId: d\n  }), re = c !== K.current.items, St = e({\n    active: S,\n    containerId: d,\n    isDragging: k,\n    isSorting: X,\n    id: o,\n    index: P,\n    items: c,\n    newIndex: K.current.newIndex,\n    previousItems: K.current.items,\n    previousContainerId: K.current.containerId,\n    transition: u,\n    wasDragging: K.current.activeId != null\n  }), Xt = vu({\n    disabled: !St,\n    index: P,\n    node: w,\n    rect: m\n  });\n  return B(() => {\n    X && K.current.newIndex !== Ft && (K.current.newIndex = Ft), d !== K.current.containerId && (K.current.containerId = d), c !== K.current.items && (K.current.items = c);\n  }, [X, Ft, d, c]), B(() => {\n    if (Et === K.current.activeId)\n      return;\n    if (Et != null && K.current.activeId == null) {\n      K.current.activeId = Et;\n      return;\n    }\n    const V = setTimeout(() => {\n      K.current.activeId = Et;\n    }, 50);\n    return () => clearTimeout(V);\n  }, [Et]), {\n    active: S,\n    activeIndex: h,\n    attributes: F,\n    data: D,\n    rect: m,\n    index: P,\n    newIndex: Ft,\n    items: c,\n    isOver: C,\n    isSorting: X,\n    isDragging: k,\n    listeners: _,\n    node: w,\n    overIndex: y,\n    over: U,\n    setNodeRef: et,\n    setActivatorNodeRef: H,\n    setDroppableNodeRef: M,\n    setDraggableNodeRef: G,\n    transform: Xt ?? ie,\n    transition: A()\n  };\n  function A() {\n    if (\n      // Temporarily disable transitions for a single frame to set up derived transforms\n      Xt || // Or to prevent items jumping to back to their \"new\" position when items change\n      re && K.current.newIndex === P\n    )\n      return gu;\n    if (!(xt && !Ws(N) || !u) && (X || St))\n      return Ge.Transition.toString({\n        ...u,\n        property: Oo\n      });\n  }\n}\nfunction bu(t, e) {\n  var n, s;\n  return typeof t == \"boolean\" ? {\n    draggable: t,\n    // Backwards compatibility\n    droppable: !1\n  } : {\n    draggable: (n = t?.draggable) != null ? n : e.draggable,\n    droppable: (s = t?.droppable) != null ? s : e.droppable\n  };\n}\nfunction Sn(t) {\n  if (!t)\n    return !1;\n  const e = t.data.current;\n  return !!(e && \"sortable\" in e && typeof e.sortable == \"object\" && \"containerId\" in e.sortable && \"items\" in e.sortable && \"index\" in e.sortable);\n}\nconst wu = [$.Down, $.Right, $.Up, $.Left], Tu = (t, e) => {\n  let {\n    context: {\n      active: n,\n      collisionRect: s,\n      droppableRects: i,\n      droppableContainers: r,\n      over: o,\n      scrollableAncestors: a\n    }\n  } = e;\n  if (wu.includes(t.code)) {\n    if (t.preventDefault(), !n || !s)\n      return;\n    const l = [];\n    r.getEnabled().forEach((d) => {\n      if (!d || d != null && d.disabled)\n        return;\n      const h = i.get(d.id);\n      if (h)\n        switch (t.code) {\n          case $.Down:\n            s.top < h.top && l.push(d);\n            break;\n          case $.Up:\n            s.top > h.top && l.push(d);\n            break;\n          case $.Left:\n            s.left > h.left && l.push(d);\n            break;\n          case $.Right:\n            s.left < h.left && l.push(d);\n            break;\n        }\n    });\n    const u = tc({\n      collisionRect: s,\n      droppableRects: i,\n      droppableContainers: l\n    });\n    let c = wo(u, \"id\");\n    if (c === o?.id && u.length > 1 && (c = u[1].id), c != null) {\n      const d = r.get(n.id), h = r.get(c), f = h ? i.get(h.id) : null, g = h?.node.current;\n      if (g && f && d && h) {\n        const y = Nn(g).some((R, m) => a[m] !== R), x = Fo(d, h), T = Su(d, h), b = y || !x ? {\n          x: 0,\n          y: 0\n        } : {\n          x: T ? s.width - f.width : 0,\n          y: T ? s.height - f.height : 0\n        }, P = {\n          x: f.left,\n          y: f.top\n        };\n        return b.x && b.y ? P : Ke(P, b);\n      }\n    }\n  }\n};\nfunction Fo(t, e) {\n  return !Sn(t) || !Sn(e) ? !1 : t.data.current.sortable.containerId === e.data.current.sortable.containerId;\n}\nfunction Su(t, e) {\n  return !Sn(t) || !Sn(e) || !Fo(t, e) ? !1 : t.data.current.sortable.index < e.data.current.sortable.index;\n}\nconst qs = Lt({});\nfunction Js(t) {\n  const e = j(null);\n  return e.current === null && (e.current = t()), e.current;\n}\nconst Zs = typeof window < \"u\", Bo = Zs ? fo : B, jn = /* @__PURE__ */ Lt(null);\nfunction Qs(t, e) {\n  t.indexOf(e) === -1 && t.push(e);\n}\nfunction ti(t, e) {\n  const n = t.indexOf(e);\n  n > -1 && t.splice(n, 1);\n}\nconst Gt = (t, e, n) => n > e ? e : n < t ? t : n;\nlet ei = () => {\n};\nconst Ht = {}, $o = (t) => /^-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)$/u.test(t);\nfunction _o(t) {\n  return typeof t == \"object\" && t !== null;\n}\nconst Uo = (t) => /^0[^.\\s]+$/u.test(t);\n// @__NO_SIDE_EFFECTS__\nfunction ni(t) {\n  let e;\n  return () => (e === void 0 && (e = t()), e);\n}\nconst Mt = /* @__NO_SIDE_EFFECTS__ */ (t) => t, Du = (t, e) => (n) => e(t(n)), nn = (...t) => t.reduce(Du), Xe = /* @__NO_SIDE_EFFECTS__ */ (t, e, n) => {\n  const s = e - t;\n  return s === 0 ? 1 : (n - t) / s;\n};\nclass si {\n  constructor() {\n    this.subscriptions = [];\n  }\n  add(e) {\n    return Qs(this.subscriptions, e), () => ti(this.subscriptions, e);\n  }\n  notify(e, n, s) {\n    const i = this.subscriptions.length;\n    if (i)\n      if (i === 1)\n        this.subscriptions[0](e, n, s);\n      else\n        for (let r = 0; r < i; r++) {\n          const o = this.subscriptions[r];\n          o && o(e, n, s);\n        }\n  }\n  getSize() {\n    return this.subscriptions.length;\n  }\n  clear() {\n    this.subscriptions.length = 0;\n  }\n}\nconst Ut = /* @__NO_SIDE_EFFECTS__ */ (t) => t * 1e3, Rt = /* @__NO_SIDE_EFFECTS__ */ (t) => t / 1e3;\nfunction zo(t, e) {\n  return e ? t * (1e3 / e) : 0;\n}\nconst Wo = (t, e, n) => (((1 - 3 * n + 3 * e) * t + (3 * n - 6 * e)) * t + 3 * e) * t, Cu = 1e-7, Au = 12;\nfunction Pu(t, e, n, s, i) {\n  let r, o, a = 0;\n  do\n    o = e + (n - e) / 2, r = Wo(o, s, i) - t, r > 0 ? n = o : e = o;\n  while (Math.abs(r) > Cu && ++a < Au);\n  return o;\n}\nfunction sn(t, e, n, s) {\n  if (t === e && n === s)\n    return Mt;\n  const i = (r) => Pu(r, 0, 1, t, n);\n  return (r) => r === 0 || r === 1 ? r : Wo(i(r), e, s);\n}\nconst Ko = (t) => (e) => e <= 0.5 ? t(2 * e) / 2 : (2 - t(2 * (1 - e))) / 2, Go = (t) => (e) => 1 - t(1 - e), Ho = /* @__PURE__ */ sn(0.33, 1.53, 0.69, 0.99), ii = /* @__PURE__ */ Go(Ho), Xo = /* @__PURE__ */ Ko(ii), Yo = (t) => (t *= 2) < 1 ? 0.5 * ii(t) : 0.5 * (2 - Math.pow(2, -10 * (t - 1))), ri = (t) => 1 - Math.sin(Math.acos(t)), qo = Go(ri), Jo = Ko(ri), Ru = /* @__PURE__ */ sn(0.42, 0, 1, 1), Mu = /* @__PURE__ */ sn(0, 0, 0.58, 1), Zo = /* @__PURE__ */ sn(0.42, 0, 0.58, 1), Eu = (t) => Array.isArray(t) && typeof t[0] != \"number\", Qo = (t) => Array.isArray(t) && typeof t[0] == \"number\", Vu = {\n  linear: Mt,\n  easeIn: Ru,\n  easeInOut: Zo,\n  easeOut: Mu,\n  circIn: ri,\n  circInOut: Jo,\n  circOut: qo,\n  backIn: ii,\n  backInOut: Xo,\n  backOut: Ho,\n  anticipate: Yo\n}, Nu = (t) => typeof t == \"string\", qi = (t) => {\n  if (Qo(t)) {\n    ei(t.length === 4);\n    const [e, n, s, i] = t;\n    return sn(e, n, s, i);\n  } else if (Nu(t))\n    return Vu[t];\n  return t;\n}, dn = [\n  \"setup\",\n  // Compute\n  \"read\",\n  // Read\n  \"resolveKeyframes\",\n  // Write/Read/Write/Read\n  \"preUpdate\",\n  // Compute\n  \"update\",\n  // Compute\n  \"preRender\",\n  // Compute\n  \"render\",\n  // Write\n  \"postRender\"\n  // Compute\n];\nfunction ku(t, e) {\n  let n = /* @__PURE__ */ new Set(), s = /* @__PURE__ */ new Set(), i = !1, r = !1;\n  const o = /* @__PURE__ */ new WeakSet();\n  let a = {\n    delta: 0,\n    timestamp: 0,\n    isProcessing: !1\n  };\n  function l(c) {\n    o.has(c) && (u.schedule(c), t()), c(a);\n  }\n  const u = {\n    /**\n     * Schedule a process to run on the next frame.\n     */\n    schedule: (c, d = !1, h = !1) => {\n      const g = h && i ? n : s;\n      return d && o.add(c), g.has(c) || g.add(c), c;\n    },\n    /**\n     * Cancel the provided callback from running on the next frame.\n     */\n    cancel: (c) => {\n      s.delete(c), o.delete(c);\n    },\n    /**\n     * Execute all schedule callbacks.\n     */\n    process: (c) => {\n      if (a = c, i) {\n        r = !0;\n        return;\n      }\n      i = !0, [n, s] = [s, n], n.forEach(l), n.clear(), i = !1, r && (r = !1, u.process(c));\n    }\n  };\n  return u;\n}\nconst Iu = 40;\nfunction ta(t, e) {\n  let n = !1, s = !0;\n  const i = {\n    delta: 0,\n    timestamp: 0,\n    isProcessing: !1\n  }, r = () => n = !0, o = dn.reduce((b, P) => (b[P] = ku(r), b), {}), { setup: a, read: l, resolveKeyframes: u, preUpdate: c, update: d, preRender: h, render: f, postRender: g } = o, v = () => {\n    const b = Ht.useManualTiming ? i.timestamp : performance.now();\n    n = !1, Ht.useManualTiming || (i.delta = s ? 1e3 / 60 : Math.max(Math.min(b - i.timestamp, Iu), 1)), i.timestamp = b, i.isProcessing = !0, a.process(i), l.process(i), u.process(i), c.process(i), d.process(i), h.process(i), f.process(i), g.process(i), i.isProcessing = !1, n && e && (s = !1, t(v));\n  }, y = () => {\n    n = !0, s = !0, i.isProcessing || t(v);\n  };\n  return { schedule: dn.reduce((b, P) => {\n    const D = o[P];\n    return b[P] = (R, m = !1, w = !1) => (n || y(), D.schedule(R, m, w)), b;\n  }, {}), cancel: (b) => {\n    for (let P = 0; P < dn.length; P++)\n      o[dn[P]].cancel(b);\n  }, state: i, steps: o };\n}\nconst { schedule: Y, cancel: ee, state: ut, steps: Gn } = /* @__PURE__ */ ta(typeof requestAnimationFrame < \"u\" ? requestAnimationFrame : Mt, !0);\nlet gn;\nfunction ju() {\n  gn = void 0;\n}\nconst yt = {\n  now: () => (gn === void 0 && yt.set(ut.isProcessing || Ht.useManualTiming ? ut.timestamp : performance.now()), gn),\n  set: (t) => {\n    gn = t, queueMicrotask(ju);\n  }\n}, ea = (t) => (e) => typeof e == \"string\" && e.startsWith(t), na = /* @__PURE__ */ ea(\"--\"), Lu = /* @__PURE__ */ ea(\"var(--\"), oi = (t) => Lu(t) ? Ou.test(t.split(\"/*\")[0].trim()) : !1, Ou = /var\\(--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)$/iu, Pe = {\n  test: (t) => typeof t == \"number\",\n  parse: parseFloat,\n  transform: (t) => t\n}, Ye = {\n  ...Pe,\n  transform: (t) => Gt(0, 1, t)\n}, hn = {\n  ...Pe,\n  default: 1\n}, $e = (t) => Math.round(t * 1e5) / 1e5, ai = /-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/gu;\nfunction Fu(t) {\n  return t == null;\n}\nconst Bu = /^(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))$/iu, li = (t, e) => (n) => !!(typeof n == \"string\" && Bu.test(n) && n.startsWith(t) || e && !Fu(n) && Object.prototype.hasOwnProperty.call(n, e)), sa = (t, e, n) => (s) => {\n  if (typeof s != \"string\")\n    return s;\n  const [i, r, o, a] = s.match(ai);\n  return {\n    [t]: parseFloat(i),\n    [e]: parseFloat(r),\n    [n]: parseFloat(o),\n    alpha: a !== void 0 ? parseFloat(a) : 1\n  };\n}, $u = (t) => Gt(0, 255, t), Hn = {\n  ...Pe,\n  transform: (t) => Math.round($u(t))\n}, le = {\n  test: /* @__PURE__ */ li(\"rgb\", \"red\"),\n  parse: /* @__PURE__ */ sa(\"red\", \"green\", \"blue\"),\n  transform: ({ red: t, green: e, blue: n, alpha: s = 1 }) => \"rgba(\" + Hn.transform(t) + \", \" + Hn.transform(e) + \", \" + Hn.transform(n) + \", \" + $e(Ye.transform(s)) + \")\"\n};\nfunction _u(t) {\n  let e = \"\", n = \"\", s = \"\", i = \"\";\n  return t.length > 5 ? (e = t.substring(1, 3), n = t.substring(3, 5), s = t.substring(5, 7), i = t.substring(7, 9)) : (e = t.substring(1, 2), n = t.substring(2, 3), s = t.substring(3, 4), i = t.substring(4, 5), e += e, n += n, s += s, i += i), {\n    red: parseInt(e, 16),\n    green: parseInt(n, 16),\n    blue: parseInt(s, 16),\n    alpha: i ? parseInt(i, 16) / 255 : 1\n  };\n}\nconst vs = {\n  test: /* @__PURE__ */ li(\"#\"),\n  parse: _u,\n  transform: le.transform\n}, rn = /* @__NO_SIDE_EFFECTS__ */ (t) => ({\n  test: (e) => typeof e == \"string\" && e.endsWith(t) && e.split(\" \").length === 1,\n  parse: parseFloat,\n  transform: (e) => `${e}${t}`\n}), Qt = /* @__PURE__ */ rn(\"deg\"), zt = /* @__PURE__ */ rn(\"%\"), I = /* @__PURE__ */ rn(\"px\"), Uu = /* @__PURE__ */ rn(\"vh\"), zu = /* @__PURE__ */ rn(\"vw\"), Ji = {\n  ...zt,\n  parse: (t) => zt.parse(t) / 100,\n  transform: (t) => zt.transform(t * 100)\n}, me = {\n  test: /* @__PURE__ */ li(\"hsl\", \"hue\"),\n  parse: /* @__PURE__ */ sa(\"hue\", \"saturation\", \"lightness\"),\n  transform: ({ hue: t, saturation: e, lightness: n, alpha: s = 1 }) => \"hsla(\" + Math.round(t) + \", \" + zt.transform($e(e)) + \", \" + zt.transform($e(n)) + \", \" + $e(Ye.transform(s)) + \")\"\n}, nt = {\n  test: (t) => le.test(t) || vs.test(t) || me.test(t),\n  parse: (t) => le.test(t) ? le.parse(t) : me.test(t) ? me.parse(t) : vs.parse(t),\n  transform: (t) => typeof t == \"string\" ? t : t.hasOwnProperty(\"red\") ? le.transform(t) : me.transform(t),\n  getAnimatableNone: (t) => {\n    const e = nt.parse(t);\n    return e.alpha = 0, nt.transform(e);\n  }\n}, Wu = /(?:#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\))/giu;\nfunction Ku(t) {\n  return isNaN(t) && typeof t == \"string\" && (t.match(ai)?.length || 0) + (t.match(Wu)?.length || 0) > 0;\n}\nconst ia = \"number\", ra = \"color\", Gu = \"var\", Hu = \"var(\", Zi = \"${}\", Xu = /var\\s*\\(\\s*--(?:[\\w-]+\\s*|[\\w-]+\\s*,(?:\\s*[^)(\\s]|\\s*\\((?:[^)(]|\\([^)(]*\\))*\\))+\\s*)\\)|#[\\da-f]{3,8}|(?:rgb|hsl)a?\\((?:-?[\\d.]+%?[,\\s]+){2}-?[\\d.]+%?\\s*(?:[,/]\\s*)?(?:\\b\\d+(?:\\.\\d+)?|\\.\\d+)?%?\\)|-?(?:\\d+(?:\\.\\d+)?|\\.\\d+)/giu;\nfunction qe(t) {\n  const e = t.toString(), n = [], s = {\n    color: [],\n    number: [],\n    var: []\n  }, i = [];\n  let r = 0;\n  const a = e.replace(Xu, (l) => (nt.test(l) ? (s.color.push(r), i.push(ra), n.push(nt.parse(l))) : l.startsWith(Hu) ? (s.var.push(r), i.push(Gu), n.push(l)) : (s.number.push(r), i.push(ia), n.push(parseFloat(l))), ++r, Zi)).split(Zi);\n  return { values: n, split: a, indexes: s, types: i };\n}\nfunction oa(t) {\n  return qe(t).values;\n}\nfunction aa(t) {\n  const { split: e, types: n } = qe(t), s = e.length;\n  return (i) => {\n    let r = \"\";\n    for (let o = 0; o < s; o++)\n      if (r += e[o], i[o] !== void 0) {\n        const a = n[o];\n        a === ia ? r += $e(i[o]) : a === ra ? r += nt.transform(i[o]) : r += i[o];\n      }\n    return r;\n  };\n}\nconst Yu = (t) => typeof t == \"number\" ? 0 : nt.test(t) ? nt.getAnimatableNone(t) : t;\nfunction qu(t) {\n  const e = oa(t);\n  return aa(t)(e.map(Yu));\n}\nconst ne = {\n  test: Ku,\n  parse: oa,\n  createTransformer: aa,\n  getAnimatableNone: qu\n};\nfunction Xn(t, e, n) {\n  return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? t + (e - t) * 6 * n : n < 1 / 2 ? e : n < 2 / 3 ? t + (e - t) * (2 / 3 - n) * 6 : t;\n}\nfunction Ju({ hue: t, saturation: e, lightness: n, alpha: s }) {\n  t /= 360, e /= 100, n /= 100;\n  let i = 0, r = 0, o = 0;\n  if (!e)\n    i = r = o = n;\n  else {\n    const a = n < 0.5 ? n * (1 + e) : n + e - n * e, l = 2 * n - a;\n    i = Xn(l, a, t + 1 / 3), r = Xn(l, a, t), o = Xn(l, a, t - 1 / 3);\n  }\n  return {\n    red: Math.round(i * 255),\n    green: Math.round(r * 255),\n    blue: Math.round(o * 255),\n    alpha: s\n  };\n}\nfunction Dn(t, e) {\n  return (n) => n > 0 ? e : t;\n}\nconst J = (t, e, n) => t + (e - t) * n, Yn = (t, e, n) => {\n  const s = t * t, i = n * (e * e - s) + s;\n  return i < 0 ? 0 : Math.sqrt(i);\n}, Zu = [vs, le, me], Qu = (t) => Zu.find((e) => e.test(t));\nfunction Qi(t) {\n  const e = Qu(t);\n  if (!e)\n    return !1;\n  let n = e.parse(t);\n  return e === me && (n = Ju(n)), n;\n}\nconst tr = (t, e) => {\n  const n = Qi(t), s = Qi(e);\n  if (!n || !s)\n    return Dn(t, e);\n  const i = { ...n };\n  return (r) => (i.red = Yn(n.red, s.red, r), i.green = Yn(n.green, s.green, r), i.blue = Yn(n.blue, s.blue, r), i.alpha = J(n.alpha, s.alpha, r), le.transform(i));\n}, xs = /* @__PURE__ */ new Set([\"none\", \"hidden\"]);\nfunction td(t, e) {\n  return xs.has(t) ? (n) => n <= 0 ? t : e : (n) => n >= 1 ? e : t;\n}\nfunction ed(t, e) {\n  return (n) => J(t, e, n);\n}\nfunction ci(t) {\n  return typeof t == \"number\" ? ed : typeof t == \"string\" ? oi(t) ? Dn : nt.test(t) ? tr : id : Array.isArray(t) ? la : typeof t == \"object\" ? nt.test(t) ? tr : nd : Dn;\n}\nfunction la(t, e) {\n  const n = [...t], s = n.length, i = t.map((r, o) => ci(r)(r, e[o]));\n  return (r) => {\n    for (let o = 0; o < s; o++)\n      n[o] = i[o](r);\n    return n;\n  };\n}\nfunction nd(t, e) {\n  const n = { ...t, ...e }, s = {};\n  for (const i in n)\n    t[i] !== void 0 && e[i] !== void 0 && (s[i] = ci(t[i])(t[i], e[i]));\n  return (i) => {\n    for (const r in s)\n      n[r] = s[r](i);\n    return n;\n  };\n}\nfunction sd(t, e) {\n  const n = [], s = { color: 0, var: 0, number: 0 };\n  for (let i = 0; i < e.values.length; i++) {\n    const r = e.types[i], o = t.indexes[r][s[r]], a = t.values[o] ?? 0;\n    n[i] = a, s[r]++;\n  }\n  return n;\n}\nconst id = (t, e) => {\n  const n = ne.createTransformer(e), s = qe(t), i = qe(e);\n  return s.indexes.var.length === i.indexes.var.length && s.indexes.color.length === i.indexes.color.length && s.indexes.number.length >= i.indexes.number.length ? xs.has(t) && !i.values.length || xs.has(e) && !s.values.length ? td(t, e) : nn(la(sd(s, i), i.values), n) : Dn(t, e);\n};\nfunction ca(t, e, n) {\n  return typeof t == \"number\" && typeof e == \"number\" && typeof n == \"number\" ? J(t, e, n) : ci(t)(t, e);\n}\nconst rd = (t) => {\n  const e = ({ timestamp: n }) => t(n);\n  return {\n    start: (n = !0) => Y.update(e, n),\n    stop: () => ee(e),\n    /**\n     * If we're processing this frame we can use the\n     * framelocked timestamp to keep things in sync.\n     */\n    now: () => ut.isProcessing ? ut.timestamp : yt.now()\n  };\n}, ua = (t, e, n = 10) => {\n  let s = \"\";\n  const i = Math.max(Math.round(e / n), 2);\n  for (let r = 0; r < i; r++)\n    s += Math.round(t(r / (i - 1)) * 1e4) / 1e4 + \", \";\n  return `linear(${s.substring(0, s.length - 2)})`;\n}, Cn = 2e4;\nfunction ui(t) {\n  let e = 0;\n  const n = 50;\n  let s = t.next(e);\n  for (; !s.done && e < Cn; )\n    e += n, s = t.next(e);\n  return e >= Cn ? 1 / 0 : e;\n}\nfunction od(t, e = 100, n) {\n  const s = n({ ...t, keyframes: [0, e] }), i = Math.min(ui(s), Cn);\n  return {\n    type: \"keyframes\",\n    ease: (r) => s.next(i * r).value / e,\n    duration: /* @__PURE__ */ Rt(i)\n  };\n}\nconst ad = 5;\nfunction da(t, e, n) {\n  const s = Math.max(e - ad, 0);\n  return zo(n - t(s), e - s);\n}\nconst Q = {\n  // Default spring physics\n  stiffness: 100,\n  damping: 10,\n  mass: 1,\n  velocity: 0,\n  // Default duration/bounce-based options\n  duration: 800,\n  // in ms\n  bounce: 0.3,\n  visualDuration: 0.3,\n  // in seconds\n  // Rest thresholds\n  restSpeed: {\n    granular: 0.01,\n    default: 2\n  },\n  restDelta: {\n    granular: 5e-3,\n    default: 0.5\n  },\n  // Limits\n  minDuration: 0.01,\n  // in seconds\n  maxDuration: 10,\n  // in seconds\n  minDamping: 0.05,\n  maxDamping: 1\n}, qn = 1e-3;\nfunction ld({ duration: t = Q.duration, bounce: e = Q.bounce, velocity: n = Q.velocity, mass: s = Q.mass }) {\n  let i, r, o = 1 - e;\n  o = Gt(Q.minDamping, Q.maxDamping, o), t = Gt(Q.minDuration, Q.maxDuration, /* @__PURE__ */ Rt(t)), o < 1 ? (i = (u) => {\n    const c = u * o, d = c * t, h = c - n, f = bs(u, o), g = Math.exp(-d);\n    return qn - h / f * g;\n  }, r = (u) => {\n    const d = u * o * t, h = d * n + n, f = Math.pow(o, 2) * Math.pow(u, 2) * t, g = Math.exp(-d), v = bs(Math.pow(u, 2), o);\n    return (-i(u) + qn > 0 ? -1 : 1) * ((h - f) * g) / v;\n  }) : (i = (u) => {\n    const c = Math.exp(-u * t), d = (u - n) * t + 1;\n    return -qn + c * d;\n  }, r = (u) => {\n    const c = Math.exp(-u * t), d = (n - u) * (t * t);\n    return c * d;\n  });\n  const a = 5 / t, l = ud(i, r, a);\n  if (t = /* @__PURE__ */ Ut(t), isNaN(l))\n    return {\n      stiffness: Q.stiffness,\n      damping: Q.damping,\n      duration: t\n    };\n  {\n    const u = Math.pow(l, 2) * s;\n    return {\n      stiffness: u,\n      damping: o * 2 * Math.sqrt(s * u),\n      duration: t\n    };\n  }\n}\nconst cd = 12;\nfunction ud(t, e, n) {\n  let s = n;\n  for (let i = 1; i < cd; i++)\n    s = s - t(s) / e(s);\n  return s;\n}\nfunction bs(t, e) {\n  return t * Math.sqrt(1 - e * e);\n}\nconst dd = [\"duration\", \"bounce\"], hd = [\"stiffness\", \"damping\", \"mass\"];\nfunction er(t, e) {\n  return e.some((n) => t[n] !== void 0);\n}\nfunction fd(t) {\n  let e = {\n    velocity: Q.velocity,\n    stiffness: Q.stiffness,\n    damping: Q.damping,\n    mass: Q.mass,\n    isResolvedFromDuration: !1,\n    ...t\n  };\n  if (!er(t, hd) && er(t, dd))\n    if (t.visualDuration) {\n      const n = t.visualDuration, s = 2 * Math.PI / (n * 1.2), i = s * s, r = 2 * Gt(0.05, 1, 1 - (t.bounce || 0)) * Math.sqrt(i);\n      e = {\n        ...e,\n        mass: Q.mass,\n        stiffness: i,\n        damping: r\n      };\n    } else {\n      const n = ld(t);\n      e = {\n        ...e,\n        ...n,\n        mass: Q.mass\n      }, e.isResolvedFromDuration = !0;\n    }\n  return e;\n}\nfunction An(t = Q.visualDuration, e = Q.bounce) {\n  const n = typeof t != \"object\" ? {\n    visualDuration: t,\n    keyframes: [0, 1],\n    bounce: e\n  } : t;\n  let { restSpeed: s, restDelta: i } = n;\n  const r = n.keyframes[0], o = n.keyframes[n.keyframes.length - 1], a = { done: !1, value: r }, { stiffness: l, damping: u, mass: c, duration: d, velocity: h, isResolvedFromDuration: f } = fd({\n    ...n,\n    velocity: -/* @__PURE__ */ Rt(n.velocity || 0)\n  }), g = h || 0, v = u / (2 * Math.sqrt(l * c)), y = o - r, x = /* @__PURE__ */ Rt(Math.sqrt(l / c)), T = Math.abs(y) < 5;\n  s || (s = T ? Q.restSpeed.granular : Q.restSpeed.default), i || (i = T ? Q.restDelta.granular : Q.restDelta.default);\n  let b;\n  if (v < 1) {\n    const D = bs(x, v);\n    b = (R) => {\n      const m = Math.exp(-v * x * R);\n      return o - m * ((g + v * x * y) / D * Math.sin(D * R) + y * Math.cos(D * R));\n    };\n  } else if (v === 1)\n    b = (D) => o - Math.exp(-x * D) * (y + (g + x * y) * D);\n  else {\n    const D = x * Math.sqrt(v * v - 1);\n    b = (R) => {\n      const m = Math.exp(-v * x * R), w = Math.min(D * R, 300);\n      return o - m * ((g + v * x * y) * Math.sinh(w) + D * y * Math.cosh(w)) / D;\n    };\n  }\n  const P = {\n    calculatedDuration: f && d || null,\n    next: (D) => {\n      const R = b(D);\n      if (f)\n        a.done = D >= d;\n      else {\n        let m = D === 0 ? g : 0;\n        v < 1 && (m = D === 0 ? /* @__PURE__ */ Ut(g) : da(b, D, R));\n        const w = Math.abs(m) <= s, C = Math.abs(o - R) <= i;\n        a.done = w && C;\n      }\n      return a.value = a.done ? o : R, a;\n    },\n    toString: () => {\n      const D = Math.min(ui(P), Cn), R = ua((m) => P.next(D * m).value, D, 30);\n      return D + \"ms \" + R;\n    },\n    toTransition: () => {\n    }\n  };\n  return P;\n}\nAn.applyToOptions = (t) => {\n  const e = od(t, 100, An);\n  return t.ease = e.ease, t.duration = /* @__PURE__ */ Ut(e.duration), t.type = \"keyframes\", t;\n};\nfunction ws({ keyframes: t, velocity: e = 0, power: n = 0.8, timeConstant: s = 325, bounceDamping: i = 10, bounceStiffness: r = 500, modifyTarget: o, min: a, max: l, restDelta: u = 0.5, restSpeed: c }) {\n  const d = t[0], h = {\n    done: !1,\n    value: d\n  }, f = (w) => a !== void 0 && w < a || l !== void 0 && w > l, g = (w) => a === void 0 ? l : l === void 0 || Math.abs(a - w) < Math.abs(l - w) ? a : l;\n  let v = n * e;\n  const y = d + v, x = o === void 0 ? y : o(y);\n  x !== y && (v = x - d);\n  const T = (w) => -v * Math.exp(-w / s), b = (w) => x + T(w), P = (w) => {\n    const C = T(w), M = b(w);\n    h.done = Math.abs(C) <= u, h.value = h.done ? x : M;\n  };\n  let D, R;\n  const m = (w) => {\n    f(h.value) && (D = w, R = An({\n      keyframes: [h.value, g(h.value)],\n      velocity: da(b, w, h.value),\n      // TODO: This should be passing * 1000\n      damping: i,\n      stiffness: r,\n      restDelta: u,\n      restSpeed: c\n    }));\n  };\n  return m(0), {\n    calculatedDuration: null,\n    next: (w) => {\n      let C = !1;\n      return !R && D === void 0 && (C = !0, P(w), m(w)), D !== void 0 && w >= D ? R.next(w - D) : (!C && P(w), h);\n    }\n  };\n}\nfunction pd(t, e, n) {\n  const s = [], i = n || Ht.mix || ca, r = t.length - 1;\n  for (let o = 0; o < r; o++) {\n    let a = i(t[o], t[o + 1]);\n    if (e) {\n      const l = Array.isArray(e) ? e[o] || Mt : e;\n      a = nn(l, a);\n    }\n    s.push(a);\n  }\n  return s;\n}\nfunction md(t, e, { clamp: n = !0, ease: s, mixer: i } = {}) {\n  const r = t.length;\n  if (ei(r === e.length), r === 1)\n    return () => e[0];\n  if (r === 2 && e[0] === e[1])\n    return () => e[1];\n  const o = t[0] === t[1];\n  t[0] > t[r - 1] && (t = [...t].reverse(), e = [...e].reverse());\n  const a = pd(e, s, i), l = a.length, u = (c) => {\n    if (o && c < t[0])\n      return e[0];\n    let d = 0;\n    if (l > 1)\n      for (; d < t.length - 2 && !(c < t[d + 1]); d++)\n        ;\n    const h = /* @__PURE__ */ Xe(t[d], t[d + 1], c);\n    return a[d](h);\n  };\n  return n ? (c) => u(Gt(t[0], t[r - 1], c)) : u;\n}\nfunction gd(t, e) {\n  const n = t[t.length - 1];\n  for (let s = 1; s <= e; s++) {\n    const i = /* @__PURE__ */ Xe(0, e, s);\n    t.push(J(n, 1, i));\n  }\n}\nfunction yd(t) {\n  const e = [0];\n  return gd(e, t.length - 1), e;\n}\nfunction vd(t, e) {\n  return t.map((n) => n * e);\n}\nfunction xd(t, e) {\n  return t.map(() => e || Zo).splice(0, t.length - 1);\n}\nfunction _e({ duration: t = 300, keyframes: e, times: n, ease: s = \"easeInOut\" }) {\n  const i = Eu(s) ? s.map(qi) : qi(s), r = {\n    done: !1,\n    value: e[0]\n  }, o = vd(\n    // Only use the provided offsets if they're the correct length\n    // TODO Maybe we should warn here if there's a length mismatch\n    n && n.length === e.length ? n : yd(e),\n    t\n  ), a = md(o, e, {\n    ease: Array.isArray(i) ? i : xd(e, i)\n  });\n  return {\n    calculatedDuration: t,\n    next: (l) => (r.value = a(l), r.done = l >= t, r)\n  };\n}\nconst bd = (t) => t !== null;\nfunction di(t, { repeat: e, repeatType: n = \"loop\" }, s, i = 1) {\n  const r = t.filter(bd), a = i < 0 || e && n !== \"loop\" && e % 2 === 1 ? 0 : r.length - 1;\n  return !a || s === void 0 ? r[a] : s;\n}\nconst wd = {\n  decay: ws,\n  inertia: ws,\n  tween: _e,\n  keyframes: _e,\n  spring: An\n};\nfunction ha(t) {\n  typeof t.type == \"string\" && (t.type = wd[t.type]);\n}\nclass hi {\n  constructor() {\n    this.updateFinished();\n  }\n  get finished() {\n    return this._finished;\n  }\n  updateFinished() {\n    this._finished = new Promise((e) => {\n      this.resolve = e;\n    });\n  }\n  notifyFinished() {\n    this.resolve();\n  }\n  /**\n   * Allows the animation to be awaited.\n   *\n   * @deprecated Use `finished` instead.\n   */\n  then(e, n) {\n    return this.finished.then(e, n);\n  }\n}\nconst Td = (t) => t / 100;\nclass fi extends hi {\n  constructor(e) {\n    super(), this.state = \"idle\", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => {\n      const { motionValue: n } = this.options;\n      n && n.updatedAt !== yt.now() && this.tick(yt.now()), this.isStopped = !0, this.state !== \"idle\" && (this.teardown(), this.options.onStop?.());\n    }, this.options = e, this.initAnimation(), this.play(), e.autoplay === !1 && this.pause();\n  }\n  initAnimation() {\n    const { options: e } = this;\n    ha(e);\n    const { type: n = _e, repeat: s = 0, repeatDelay: i = 0, repeatType: r, velocity: o = 0 } = e;\n    let { keyframes: a } = e;\n    const l = n || _e;\n    l !== _e && typeof a[0] != \"number\" && (this.mixKeyframes = nn(Td, ca(a[0], a[1])), a = [0, 100]);\n    const u = l({ ...e, keyframes: a });\n    r === \"mirror\" && (this.mirroredGenerator = l({\n      ...e,\n      keyframes: [...a].reverse(),\n      velocity: -o\n    })), u.calculatedDuration === null && (u.calculatedDuration = ui(u));\n    const { calculatedDuration: c } = u;\n    this.calculatedDuration = c, this.resolvedDuration = c + i, this.totalDuration = this.resolvedDuration * (s + 1) - i, this.generator = u;\n  }\n  updateTime(e) {\n    const n = Math.round(e - this.startTime) * this.playbackSpeed;\n    this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = n;\n  }\n  tick(e, n = !1) {\n    const { generator: s, totalDuration: i, mixKeyframes: r, mirroredGenerator: o, resolvedDuration: a, calculatedDuration: l } = this;\n    if (this.startTime === null)\n      return s.next(0);\n    const { delay: u = 0, keyframes: c, repeat: d, repeatType: h, repeatDelay: f, type: g, onUpdate: v, finalKeyframe: y } = this.options;\n    this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - i / this.speed, this.startTime)), n ? this.currentTime = e : this.updateTime(e);\n    const x = this.currentTime - u * (this.playbackSpeed >= 0 ? 1 : -1), T = this.playbackSpeed >= 0 ? x < 0 : x > i;\n    this.currentTime = Math.max(x, 0), this.state === \"finished\" && this.holdTime === null && (this.currentTime = i);\n    let b = this.currentTime, P = s;\n    if (d) {\n      const w = Math.min(this.currentTime, i) / a;\n      let C = Math.floor(w), M = w % 1;\n      !M && w >= 1 && (M = 1), M === 1 && C--, C = Math.min(C, d + 1), !!(C % 2) && (h === \"reverse\" ? (M = 1 - M, f && (M -= f / a)) : h === \"mirror\" && (P = o)), b = Gt(0, 1, M) * a;\n    }\n    const D = T ? { done: !1, value: c[0] } : P.next(b);\n    r && (D.value = r(D.value));\n    let { done: R } = D;\n    !T && l !== null && (R = this.playbackSpeed >= 0 ? this.currentTime >= i : this.currentTime <= 0);\n    const m = this.holdTime === null && (this.state === \"finished\" || this.state === \"running\" && R);\n    return m && g !== ws && (D.value = di(c, this.options, y, this.speed)), v && v(D.value), m && this.finish(), D;\n  }\n  /**\n   * Allows the returned animation to be awaited or promise-chained. Currently\n   * resolves when the animation finishes at all but in a future update could/should\n   * reject if its cancels.\n   */\n  then(e, n) {\n    return this.finished.then(e, n);\n  }\n  get duration() {\n    return /* @__PURE__ */ Rt(this.calculatedDuration);\n  }\n  get iterationDuration() {\n    const { delay: e = 0 } = this.options || {};\n    return this.duration + /* @__PURE__ */ Rt(e);\n  }\n  get time() {\n    return /* @__PURE__ */ Rt(this.currentTime);\n  }\n  set time(e) {\n    e = /* @__PURE__ */ Ut(e), this.currentTime = e, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.playbackSpeed), this.driver?.start(!1);\n  }\n  get speed() {\n    return this.playbackSpeed;\n  }\n  set speed(e) {\n    this.updateTime(yt.now());\n    const n = this.playbackSpeed !== e;\n    this.playbackSpeed = e, n && (this.time = /* @__PURE__ */ Rt(this.currentTime));\n  }\n  play() {\n    if (this.isStopped)\n      return;\n    const { driver: e = rd, startTime: n } = this.options;\n    this.driver || (this.driver = e((i) => this.tick(i))), this.options.onPlay?.();\n    const s = this.driver.now();\n    this.state === \"finished\" ? (this.updateFinished(), this.startTime = s) : this.holdTime !== null ? this.startTime = s - this.holdTime : this.startTime || (this.startTime = n ?? s), this.state === \"finished\" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = \"running\", this.driver.start();\n  }\n  pause() {\n    this.state = \"paused\", this.updateTime(yt.now()), this.holdTime = this.currentTime;\n  }\n  complete() {\n    this.state !== \"running\" && this.play(), this.state = \"finished\", this.holdTime = null;\n  }\n  finish() {\n    this.notifyFinished(), this.teardown(), this.state = \"finished\", this.options.onComplete?.();\n  }\n  cancel() {\n    this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), this.options.onCancel?.();\n  }\n  teardown() {\n    this.state = \"idle\", this.stopDriver(), this.startTime = this.holdTime = null;\n  }\n  stopDriver() {\n    this.driver && (this.driver.stop(), this.driver = void 0);\n  }\n  sample(e) {\n    return this.startTime = 0, this.tick(e, !0);\n  }\n  attachTimeline(e) {\n    return this.options.allowFlatten && (this.options.type = \"keyframes\", this.options.ease = \"linear\", this.initAnimation()), this.driver?.stop(), e.observe(this);\n  }\n}\nfunction Sd(t) {\n  for (let e = 1; e < t.length; e++)\n    t[e] ?? (t[e] = t[e - 1]);\n}\nconst ce = (t) => t * 180 / Math.PI, Ts = (t) => {\n  const e = ce(Math.atan2(t[1], t[0]));\n  return Ss(e);\n}, Dd = {\n  x: 4,\n  y: 5,\n  translateX: 4,\n  translateY: 5,\n  scaleX: 0,\n  scaleY: 3,\n  scale: (t) => (Math.abs(t[0]) + Math.abs(t[3])) / 2,\n  rotate: Ts,\n  rotateZ: Ts,\n  skewX: (t) => ce(Math.atan(t[1])),\n  skewY: (t) => ce(Math.atan(t[2])),\n  skew: (t) => (Math.abs(t[1]) + Math.abs(t[2])) / 2\n}, Ss = (t) => (t = t % 360, t < 0 && (t += 360), t), nr = Ts, sr = (t) => Math.sqrt(t[0] * t[0] + t[1] * t[1]), ir = (t) => Math.sqrt(t[4] * t[4] + t[5] * t[5]), Cd = {\n  x: 12,\n  y: 13,\n  z: 14,\n  translateX: 12,\n  translateY: 13,\n  translateZ: 14,\n  scaleX: sr,\n  scaleY: ir,\n  scale: (t) => (sr(t) + ir(t)) / 2,\n  rotateX: (t) => Ss(ce(Math.atan2(t[6], t[5]))),\n  rotateY: (t) => Ss(ce(Math.atan2(-t[2], t[0]))),\n  rotateZ: nr,\n  rotate: nr,\n  skewX: (t) => ce(Math.atan(t[4])),\n  skewY: (t) => ce(Math.atan(t[1])),\n  skew: (t) => (Math.abs(t[1]) + Math.abs(t[4])) / 2\n};\nfunction Ds(t) {\n  return t.includes(\"scale\") ? 1 : 0;\n}\nfunction Cs(t, e) {\n  if (!t || t === \"none\")\n    return Ds(e);\n  const n = t.match(/^matrix3d\\(([-\\d.e\\s,]+)\\)$/u);\n  let s, i;\n  if (n)\n    s = Cd, i = n;\n  else {\n    const a = t.match(/^matrix\\(([-\\d.e\\s,]+)\\)$/u);\n    s = Dd, i = a;\n  }\n  if (!i)\n    return Ds(e);\n  const r = s[e], o = i[1].split(\",\").map(Pd);\n  return typeof r == \"function\" ? r(o) : o[r];\n}\nconst Ad = (t, e) => {\n  const { transform: n = \"none\" } = getComputedStyle(t);\n  return Cs(n, e);\n};\nfunction Pd(t) {\n  return parseFloat(t.trim());\n}\nconst Re = [\n  \"transformPerspective\",\n  \"x\",\n  \"y\",\n  \"z\",\n  \"translateX\",\n  \"translateY\",\n  \"translateZ\",\n  \"scale\",\n  \"scaleX\",\n  \"scaleY\",\n  \"rotate\",\n  \"rotateX\",\n  \"rotateY\",\n  \"rotateZ\",\n  \"skew\",\n  \"skewX\",\n  \"skewY\"\n], Me = new Set(Re), rr = (t) => t === Pe || t === I, Rd = /* @__PURE__ */ new Set([\"x\", \"y\", \"z\"]), Md = Re.filter((t) => !Rd.has(t));\nfunction Ed(t) {\n  const e = [];\n  return Md.forEach((n) => {\n    const s = t.getValue(n);\n    s !== void 0 && (e.push([n, s.get()]), s.set(n.startsWith(\"scale\") ? 1 : 0));\n  }), e;\n}\nconst ue = {\n  // Dimensions\n  width: ({ x: t }, { paddingLeft: e = \"0\", paddingRight: n = \"0\" }) => t.max - t.min - parseFloat(e) - parseFloat(n),\n  height: ({ y: t }, { paddingTop: e = \"0\", paddingBottom: n = \"0\" }) => t.max - t.min - parseFloat(e) - parseFloat(n),\n  top: (t, { top: e }) => parseFloat(e),\n  left: (t, { left: e }) => parseFloat(e),\n  bottom: ({ y: t }, { top: e }) => parseFloat(e) + (t.max - t.min),\n  right: ({ x: t }, { left: e }) => parseFloat(e) + (t.max - t.min),\n  // Transform\n  x: (t, { transform: e }) => Cs(e, \"x\"),\n  y: (t, { transform: e }) => Cs(e, \"y\")\n};\nue.translateX = ue.x;\nue.translateY = ue.y;\nconst de = /* @__PURE__ */ new Set();\nlet As = !1, Ps = !1, Rs = !1;\nfunction fa() {\n  if (Ps) {\n    const t = Array.from(de).filter((s) => s.needsMeasurement), e = new Set(t.map((s) => s.element)), n = /* @__PURE__ */ new Map();\n    e.forEach((s) => {\n      const i = Ed(s);\n      i.length && (n.set(s, i), s.render());\n    }), t.forEach((s) => s.measureInitialState()), e.forEach((s) => {\n      s.render();\n      const i = n.get(s);\n      i && i.forEach(([r, o]) => {\n        s.getValue(r)?.set(o);\n      });\n    }), t.forEach((s) => s.measureEndState()), t.forEach((s) => {\n      s.suspendedScrollY !== void 0 && window.scrollTo(0, s.suspendedScrollY);\n    });\n  }\n  Ps = !1, As = !1, de.forEach((t) => t.complete(Rs)), de.clear();\n}\nfunction pa() {\n  de.forEach((t) => {\n    t.readKeyframes(), t.needsMeasurement && (Ps = !0);\n  });\n}\nfunction Vd() {\n  Rs = !0, pa(), fa(), Rs = !1;\n}\nclass pi {\n  constructor(e, n, s, i, r, o = !1) {\n    this.state = \"pending\", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...e], this.onComplete = n, this.name = s, this.motionValue = i, this.element = r, this.isAsync = o;\n  }\n  scheduleResolve() {\n    this.state = \"scheduled\", this.isAsync ? (de.add(this), As || (As = !0, Y.read(pa), Y.resolveKeyframes(fa))) : (this.readKeyframes(), this.complete());\n  }\n  readKeyframes() {\n    const { unresolvedKeyframes: e, name: n, element: s, motionValue: i } = this;\n    if (e[0] === null) {\n      const r = i?.get(), o = e[e.length - 1];\n      if (r !== void 0)\n        e[0] = r;\n      else if (s && n) {\n        const a = s.readValue(n, o);\n        a != null && (e[0] = a);\n      }\n      e[0] === void 0 && (e[0] = o), i && r === void 0 && i.set(e[0]);\n    }\n    Sd(e);\n  }\n  setFinalKeyframe() {\n  }\n  measureInitialState() {\n  }\n  renderEndStyles() {\n  }\n  measureEndState() {\n  }\n  complete(e = !1) {\n    this.state = \"complete\", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, e), de.delete(this);\n  }\n  cancel() {\n    this.state === \"scheduled\" && (de.delete(this), this.state = \"pending\");\n  }\n  resume() {\n    this.state === \"pending\" && this.scheduleResolve();\n  }\n}\nconst Nd = (t) => t.startsWith(\"--\");\nfunction kd(t, e, n) {\n  Nd(e) ? t.style.setProperty(e, n) : t.style[e] = n;\n}\nconst Id = /* @__PURE__ */ ni(() => window.ScrollTimeline !== void 0), jd = {};\nfunction Ld(t, e) {\n  const n = /* @__PURE__ */ ni(t);\n  return () => jd[e] ?? n();\n}\nconst ma = /* @__PURE__ */ Ld(() => {\n  try {\n    document.createElement(\"div\").animate({ opacity: 0 }, { easing: \"linear(0, 1)\" });\n  } catch {\n    return !1;\n  }\n  return !0;\n}, \"linearEasing\"), Le = ([t, e, n, s]) => `cubic-bezier(${t}, ${e}, ${n}, ${s})`, or = {\n  linear: \"linear\",\n  ease: \"ease\",\n  easeIn: \"ease-in\",\n  easeOut: \"ease-out\",\n  easeInOut: \"ease-in-out\",\n  circIn: /* @__PURE__ */ Le([0, 0.65, 0.55, 1]),\n  circOut: /* @__PURE__ */ Le([0.55, 0, 1, 0.45]),\n  backIn: /* @__PURE__ */ Le([0.31, 0.01, 0.66, -0.59]),\n  backOut: /* @__PURE__ */ Le([0.33, 1.53, 0.69, 0.99])\n};\nfunction ga(t, e) {\n  if (t)\n    return typeof t == \"function\" ? ma() ? ua(t, e) : \"ease-out\" : Qo(t) ? Le(t) : Array.isArray(t) ? t.map((n) => ga(n, e) || or.easeOut) : or[t];\n}\nfunction Od(t, e, n, { delay: s = 0, duration: i = 300, repeat: r = 0, repeatType: o = \"loop\", ease: a = \"easeOut\", times: l } = {}, u = void 0) {\n  const c = {\n    [e]: n\n  };\n  l && (c.offset = l);\n  const d = ga(a, i);\n  Array.isArray(d) && (c.easing = d);\n  const h = {\n    delay: s,\n    duration: i,\n    easing: Array.isArray(d) ? \"linear\" : d,\n    fill: \"both\",\n    iterations: r + 1,\n    direction: o === \"reverse\" ? \"alternate\" : \"normal\"\n  };\n  return u && (h.pseudoElement = u), t.animate(c, h);\n}\nfunction ya(t) {\n  return typeof t == \"function\" && \"applyToOptions\" in t;\n}\nfunction Fd({ type: t, ...e }) {\n  return ya(t) && ma() ? t.applyToOptions(e) : (e.duration ?? (e.duration = 300), e.ease ?? (e.ease = \"easeOut\"), e);\n}\nclass Bd extends hi {\n  constructor(e) {\n    if (super(), this.finishedTime = null, this.isStopped = !1, !e)\n      return;\n    const { element: n, name: s, keyframes: i, pseudoElement: r, allowFlatten: o = !1, finalKeyframe: a, onComplete: l } = e;\n    this.isPseudoElement = !!r, this.allowFlatten = o, this.options = e, ei(typeof e.type != \"string\");\n    const u = Fd(e);\n    this.animation = Od(n, s, i, u, r), u.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => {\n      if (this.finishedTime = this.time, !r) {\n        const c = di(i, this.options, a, this.speed);\n        this.updateMotionValue ? this.updateMotionValue(c) : kd(n, s, c), this.animation.cancel();\n      }\n      l?.(), this.notifyFinished();\n    };\n  }\n  play() {\n    this.isStopped || (this.animation.play(), this.state === \"finished\" && this.updateFinished());\n  }\n  pause() {\n    this.animation.pause();\n  }\n  complete() {\n    this.animation.finish?.();\n  }\n  cancel() {\n    try {\n      this.animation.cancel();\n    } catch {\n    }\n  }\n  stop() {\n    if (this.isStopped)\n      return;\n    this.isStopped = !0;\n    const { state: e } = this;\n    e === \"idle\" || e === \"finished\" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel());\n  }\n  /**\n   * WAAPI doesn't natively have any interruption capabilities.\n   *\n   * In this method, we commit styles back to the DOM before cancelling\n   * the animation.\n   *\n   * This is designed to be overridden by NativeAnimationExtended, which\n   * will create a renderless JS animation and sample it twice to calculate\n   * its current value, \"previous\" value, and therefore allow\n   * Motion to also correctly calculate velocity for any subsequent animation\n   * while deferring the commit until the next animation frame.\n   */\n  commitStyles() {\n    this.isPseudoElement || this.animation.commitStyles?.();\n  }\n  get duration() {\n    const e = this.animation.effect?.getComputedTiming?.().duration || 0;\n    return /* @__PURE__ */ Rt(Number(e));\n  }\n  get iterationDuration() {\n    const { delay: e = 0 } = this.options || {};\n    return this.duration + /* @__PURE__ */ Rt(e);\n  }\n  get time() {\n    return /* @__PURE__ */ Rt(Number(this.animation.currentTime) || 0);\n  }\n  set time(e) {\n    this.finishedTime = null, this.animation.currentTime = /* @__PURE__ */ Ut(e);\n  }\n  /**\n   * The playback speed of the animation.\n   * 1 = normal speed, 2 = double speed, 0.5 = half speed.\n   */\n  get speed() {\n    return this.animation.playbackRate;\n  }\n  set speed(e) {\n    e < 0 && (this.finishedTime = null), this.animation.playbackRate = e;\n  }\n  get state() {\n    return this.finishedTime !== null ? \"finished\" : this.animation.playState;\n  }\n  get startTime() {\n    return Number(this.animation.startTime);\n  }\n  set startTime(e) {\n    this.animation.startTime = e;\n  }\n  /**\n   * Attaches a timeline to the animation, for instance the `ScrollTimeline`.\n   */\n  attachTimeline({ timeline: e, observe: n }) {\n    return this.allowFlatten && this.animation.effect?.updateTiming({ easing: \"linear\" }), this.animation.onfinish = null, e && Id() ? (this.animation.timeline = e, Mt) : n(this);\n  }\n}\nconst va = {\n  anticipate: Yo,\n  backInOut: Xo,\n  circInOut: Jo\n};\nfunction $d(t) {\n  return t in va;\n}\nfunction _d(t) {\n  typeof t.ease == \"string\" && $d(t.ease) && (t.ease = va[t.ease]);\n}\nconst ar = 10;\nclass Ud extends Bd {\n  constructor(e) {\n    _d(e), ha(e), super(e), e.startTime && (this.startTime = e.startTime), this.options = e;\n  }\n  /**\n   * WAAPI doesn't natively have any interruption capabilities.\n   *\n   * Rather than read commited styles back out of the DOM, we can\n   * create a renderless JS animation and sample it twice to calculate\n   * its current value, \"previous\" value, and therefore allow\n   * Motion to calculate velocity for any subsequent animation.\n   */\n  updateMotionValue(e) {\n    const { motionValue: n, onUpdate: s, onComplete: i, element: r, ...o } = this.options;\n    if (!n)\n      return;\n    if (e !== void 0) {\n      n.set(e);\n      return;\n    }\n    const a = new fi({\n      ...o,\n      autoplay: !1\n    }), l = /* @__PURE__ */ Ut(this.finishedTime ?? this.time);\n    n.setWithVelocity(a.sample(l - ar).value, a.sample(l).value, ar), a.stop();\n  }\n}\nconst lr = (t, e) => e === \"zIndex\" ? !1 : !!(typeof t == \"number\" || Array.isArray(t) || typeof t == \"string\" && // It's animatable if we have a string\n(ne.test(t) || t === \"0\") && // And it contains numbers and/or colors\n!t.startsWith(\"url(\"));\nfunction zd(t) {\n  const e = t[0];\n  if (t.length === 1)\n    return !0;\n  for (let n = 0; n < t.length; n++)\n    if (t[n] !== e)\n      return !0;\n}\nfunction Wd(t, e, n, s) {\n  const i = t[0];\n  if (i === null)\n    return !1;\n  if (e === \"display\" || e === \"visibility\")\n    return !0;\n  const r = t[t.length - 1], o = lr(i, e), a = lr(r, e);\n  return !o || !a ? !1 : zd(t) || (n === \"spring\" || ya(n)) && s;\n}\nfunction Ms(t) {\n  t.duration = 0, t.type = \"keyframes\";\n}\nconst Kd = /* @__PURE__ */ new Set([\n  \"opacity\",\n  \"clipPath\",\n  \"filter\",\n  \"transform\"\n  // TODO: Could be re-enabled now we have support for linear() easing\n  // \"background-color\"\n]), Gd = /* @__PURE__ */ ni(() => Object.hasOwnProperty.call(Element.prototype, \"animate\"));\nfunction Hd(t) {\n  const { motionValue: e, name: n, repeatDelay: s, repeatType: i, damping: r, type: o } = t;\n  if (!(e?.owner?.current instanceof HTMLElement))\n    return !1;\n  const { onUpdate: l, transformTemplate: u } = e.owner.getProps();\n  return Gd() && n && Kd.has(n) && (n !== \"transform\" || !u) && /**\n   * If we're outputting values to onUpdate then we can't use WAAPI as there's\n   * no way to read the value from WAAPI every frame.\n   */\n  !l && !s && i !== \"mirror\" && r !== 0 && o !== \"inertia\";\n}\nconst Xd = 40;\nclass Yd extends hi {\n  constructor({ autoplay: e = !0, delay: n = 0, type: s = \"keyframes\", repeat: i = 0, repeatDelay: r = 0, repeatType: o = \"loop\", keyframes: a, name: l, motionValue: u, element: c, ...d }) {\n    super(), this.stop = () => {\n      this._animation && (this._animation.stop(), this.stopTimeline?.()), this.keyframeResolver?.cancel();\n    }, this.createdAt = yt.now();\n    const h = {\n      autoplay: e,\n      delay: n,\n      type: s,\n      repeat: i,\n      repeatDelay: r,\n      repeatType: o,\n      name: l,\n      motionValue: u,\n      element: c,\n      ...d\n    }, f = c?.KeyframeResolver || pi;\n    this.keyframeResolver = new f(a, (g, v, y) => this.onKeyframesResolved(g, v, h, !y), l, u, c), this.keyframeResolver?.scheduleResolve();\n  }\n  onKeyframesResolved(e, n, s, i) {\n    this.keyframeResolver = void 0;\n    const { name: r, type: o, velocity: a, delay: l, isHandoff: u, onUpdate: c } = s;\n    this.resolvedAt = yt.now(), Wd(e, r, o, a) || ((Ht.instantAnimations || !l) && c?.(di(e, s, n)), e[0] = e[e.length - 1], Ms(s), s.repeat = 0);\n    const h = {\n      startTime: i ? this.resolvedAt ? this.resolvedAt - this.createdAt > Xd ? this.resolvedAt : this.createdAt : this.createdAt : void 0,\n      finalKeyframe: n,\n      ...s,\n      keyframes: e\n    }, f = !u && Hd(h) ? new Ud({\n      ...h,\n      element: h.motionValue.owner.current\n    }) : new fi(h);\n    f.finished.then(() => this.notifyFinished()).catch(Mt), this.pendingTimeline && (this.stopTimeline = f.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = f;\n  }\n  get finished() {\n    return this._animation ? this.animation.finished : this._finished;\n  }\n  then(e, n) {\n    return this.finished.finally(e).then(() => {\n    });\n  }\n  get animation() {\n    return this._animation || (this.keyframeResolver?.resume(), Vd()), this._animation;\n  }\n  get duration() {\n    return this.animation.duration;\n  }\n  get iterationDuration() {\n    return this.animation.iterationDuration;\n  }\n  get time() {\n    return this.animation.time;\n  }\n  set time(e) {\n    this.animation.time = e;\n  }\n  get speed() {\n    return this.animation.speed;\n  }\n  get state() {\n    return this.animation.state;\n  }\n  set speed(e) {\n    this.animation.speed = e;\n  }\n  get startTime() {\n    return this.animation.startTime;\n  }\n  attachTimeline(e) {\n    return this._animation ? this.stopTimeline = this.animation.attachTimeline(e) : this.pendingTimeline = e, () => this.stop();\n  }\n  play() {\n    this.animation.play();\n  }\n  pause() {\n    this.animation.pause();\n  }\n  complete() {\n    this.animation.complete();\n  }\n  cancel() {\n    this._animation && this.animation.cancel(), this.keyframeResolver?.cancel();\n  }\n}\nconst qd = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive, as it can match a lot of words\n  /^var\\(--(?:([\\w-]+)|([\\w-]+), ?([a-zA-Z\\d ()%#.,-]+))\\)/u\n);\nfunction Jd(t) {\n  const e = qd.exec(t);\n  if (!e)\n    return [,];\n  const [, n, s, i] = e;\n  return [`--${n ?? s}`, i];\n}\nfunction xa(t, e, n = 1) {\n  const [s, i] = Jd(t);\n  if (!s)\n    return;\n  const r = window.getComputedStyle(e).getPropertyValue(s);\n  if (r) {\n    const o = r.trim();\n    return $o(o) ? parseFloat(o) : o;\n  }\n  return oi(i) ? xa(i, e, n + 1) : i;\n}\nfunction mi(t, e) {\n  return t?.[e] ?? t?.default ?? t;\n}\nconst ba = /* @__PURE__ */ new Set([\n  \"width\",\n  \"height\",\n  \"top\",\n  \"left\",\n  \"right\",\n  \"bottom\",\n  ...Re\n]), Zd = {\n  test: (t) => t === \"auto\",\n  parse: (t) => t\n}, wa = (t) => (e) => e.test(t), Ta = [Pe, I, zt, Qt, zu, Uu, Zd], cr = (t) => Ta.find(wa(t));\nfunction Qd(t) {\n  return typeof t == \"number\" ? t === 0 : t !== null ? t === \"none\" || t === \"0\" || Uo(t) : !0;\n}\nconst th = /* @__PURE__ */ new Set([\"brightness\", \"contrast\", \"saturate\", \"opacity\"]);\nfunction eh(t) {\n  const [e, n] = t.slice(0, -1).split(\"(\");\n  if (e === \"drop-shadow\")\n    return t;\n  const [s] = n.match(ai) || [];\n  if (!s)\n    return t;\n  const i = n.replace(s, \"\");\n  let r = th.has(e) ? 1 : 0;\n  return s !== n && (r *= 100), e + \"(\" + r + i + \")\";\n}\nconst nh = /\\b([a-z-]*)\\(.*?\\)/gu, Es = {\n  ...ne,\n  getAnimatableNone: (t) => {\n    const e = t.match(nh);\n    return e ? e.map(eh).join(\" \") : t;\n  }\n}, ur = {\n  ...Pe,\n  transform: Math.round\n}, sh = {\n  rotate: Qt,\n  rotateX: Qt,\n  rotateY: Qt,\n  rotateZ: Qt,\n  scale: hn,\n  scaleX: hn,\n  scaleY: hn,\n  scaleZ: hn,\n  skew: Qt,\n  skewX: Qt,\n  skewY: Qt,\n  distance: I,\n  translateX: I,\n  translateY: I,\n  translateZ: I,\n  x: I,\n  y: I,\n  z: I,\n  perspective: I,\n  transformPerspective: I,\n  opacity: Ye,\n  originX: Ji,\n  originY: Ji,\n  originZ: I\n}, gi = {\n  // Border props\n  borderWidth: I,\n  borderTopWidth: I,\n  borderRightWidth: I,\n  borderBottomWidth: I,\n  borderLeftWidth: I,\n  borderRadius: I,\n  radius: I,\n  borderTopLeftRadius: I,\n  borderTopRightRadius: I,\n  borderBottomRightRadius: I,\n  borderBottomLeftRadius: I,\n  // Positioning props\n  width: I,\n  maxWidth: I,\n  height: I,\n  maxHeight: I,\n  top: I,\n  right: I,\n  bottom: I,\n  left: I,\n  // Spacing props\n  padding: I,\n  paddingTop: I,\n  paddingRight: I,\n  paddingBottom: I,\n  paddingLeft: I,\n  margin: I,\n  marginTop: I,\n  marginRight: I,\n  marginBottom: I,\n  marginLeft: I,\n  // Misc\n  backgroundPositionX: I,\n  backgroundPositionY: I,\n  ...sh,\n  zIndex: ur,\n  // SVG\n  fillOpacity: Ye,\n  strokeOpacity: Ye,\n  numOctaves: ur\n}, ih = {\n  ...gi,\n  // Color props\n  color: nt,\n  backgroundColor: nt,\n  outlineColor: nt,\n  fill: nt,\n  stroke: nt,\n  // Border props\n  borderColor: nt,\n  borderTopColor: nt,\n  borderRightColor: nt,\n  borderBottomColor: nt,\n  borderLeftColor: nt,\n  filter: Es,\n  WebkitFilter: Es\n}, Sa = (t) => ih[t];\nfunction Da(t, e) {\n  let n = Sa(t);\n  return n !== Es && (n = ne), n.getAnimatableNone ? n.getAnimatableNone(e) : void 0;\n}\nconst rh = /* @__PURE__ */ new Set([\"auto\", \"none\", \"0\"]);\nfunction oh(t, e, n) {\n  let s = 0, i;\n  for (; s < t.length && !i; ) {\n    const r = t[s];\n    typeof r == \"string\" && !rh.has(r) && qe(r).values.length && (i = t[s]), s++;\n  }\n  if (i && n)\n    for (const r of e)\n      t[r] = Da(n, i);\n}\nclass ah extends pi {\n  constructor(e, n, s, i, r) {\n    super(e, n, s, i, r, !0);\n  }\n  readKeyframes() {\n    const { unresolvedKeyframes: e, element: n, name: s } = this;\n    if (!n || !n.current)\n      return;\n    super.readKeyframes();\n    for (let l = 0; l < e.length; l++) {\n      let u = e[l];\n      if (typeof u == \"string\" && (u = u.trim(), oi(u))) {\n        const c = xa(u, n.current);\n        c !== void 0 && (e[l] = c), l === e.length - 1 && (this.finalKeyframe = u);\n      }\n    }\n    if (this.resolveNoneKeyframes(), !ba.has(s) || e.length !== 2)\n      return;\n    const [i, r] = e, o = cr(i), a = cr(r);\n    if (o !== a)\n      if (rr(o) && rr(a))\n        for (let l = 0; l < e.length; l++) {\n          const u = e[l];\n          typeof u == \"string\" && (e[l] = parseFloat(u));\n        }\n      else ue[s] && (this.needsMeasurement = !0);\n  }\n  resolveNoneKeyframes() {\n    const { unresolvedKeyframes: e, name: n } = this, s = [];\n    for (let i = 0; i < e.length; i++)\n      (e[i] === null || Qd(e[i])) && s.push(i);\n    s.length && oh(e, s, n);\n  }\n  measureInitialState() {\n    const { element: e, unresolvedKeyframes: n, name: s } = this;\n    if (!e || !e.current)\n      return;\n    s === \"height\" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = ue[s](e.measureViewportBox(), window.getComputedStyle(e.current)), n[0] = this.measuredOrigin;\n    const i = n[n.length - 1];\n    i !== void 0 && e.getValue(s, i).jump(i, !1);\n  }\n  measureEndState() {\n    const { element: e, name: n, unresolvedKeyframes: s } = this;\n    if (!e || !e.current)\n      return;\n    const i = e.getValue(n);\n    i && i.jump(this.measuredOrigin, !1);\n    const r = s.length - 1, o = s[r];\n    s[r] = ue[n](e.measureViewportBox(), window.getComputedStyle(e.current)), o !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = o), this.removedTransforms?.length && this.removedTransforms.forEach(([a, l]) => {\n      e.getValue(a).set(l);\n    }), this.resolveNoneKeyframes();\n  }\n}\nfunction lh(t, e, n) {\n  if (t instanceof EventTarget)\n    return [t];\n  if (typeof t == \"string\") {\n    let s = document;\n    const i = n?.[t] ?? s.querySelectorAll(t);\n    return i ? Array.from(i) : [];\n  }\n  return Array.from(t);\n}\nconst Ca = (t, e) => e && typeof t == \"number\" ? e.transform(t) : t;\nfunction Aa(t) {\n  return _o(t) && \"offsetHeight\" in t;\n}\nconst dr = 30, ch = (t) => !isNaN(parseFloat(t));\nclass uh {\n  /**\n   * @param init - The initiating value\n   * @param config - Optional configuration options\n   *\n   * -  `transformer`: A function to transform incoming values with.\n   */\n  constructor(e, n = {}) {\n    this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (s) => {\n      const i = yt.now();\n      if (this.updatedAt !== i && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(s), this.current !== this.prev && (this.events.change?.notify(this.current), this.dependents))\n        for (const r of this.dependents)\n          r.dirty();\n    }, this.hasAnimated = !1, this.setCurrent(e), this.owner = n.owner;\n  }\n  setCurrent(e) {\n    this.current = e, this.updatedAt = yt.now(), this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = ch(this.current));\n  }\n  setPrevFrameValue(e = this.current) {\n    this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt;\n  }\n  /**\n   * Adds a function that will be notified when the `MotionValue` is updated.\n   *\n   * It returns a function that, when called, will cancel the subscription.\n   *\n   * When calling `onChange` inside a React component, it should be wrapped with the\n   * `useEffect` hook. As it returns an unsubscribe function, this should be returned\n   * from the `useEffect` function to ensure you don't add duplicate subscribers..\n   *\n   * ```jsx\n   * export const MyComponent = () => {\n   *   const x = useMotionValue(0)\n   *   const y = useMotionValue(0)\n   *   const opacity = useMotionValue(1)\n   *\n   *   useEffect(() => {\n   *     function updateOpacity() {\n   *       const maxXY = Math.max(x.get(), y.get())\n   *       const newOpacity = transform(maxXY, [0, 100], [1, 0])\n   *       opacity.set(newOpacity)\n   *     }\n   *\n   *     const unsubscribeX = x.on(\"change\", updateOpacity)\n   *     const unsubscribeY = y.on(\"change\", updateOpacity)\n   *\n   *     return () => {\n   *       unsubscribeX()\n   *       unsubscribeY()\n   *     }\n   *   }, [])\n   *\n   *   return <motion.div style={{ x }} />\n   * }\n   * ```\n   *\n   * @param subscriber - A function that receives the latest value.\n   * @returns A function that, when called, will cancel this subscription.\n   *\n   * @deprecated\n   */\n  onChange(e) {\n    return this.on(\"change\", e);\n  }\n  on(e, n) {\n    this.events[e] || (this.events[e] = new si());\n    const s = this.events[e].add(n);\n    return e === \"change\" ? () => {\n      s(), Y.read(() => {\n        this.events.change.getSize() || this.stop();\n      });\n    } : s;\n  }\n  clearListeners() {\n    for (const e in this.events)\n      this.events[e].clear();\n  }\n  /**\n   * Attaches a passive effect to the `MotionValue`.\n   */\n  attach(e, n) {\n    this.passiveEffect = e, this.stopPassiveEffect = n;\n  }\n  /**\n   * Sets the state of the `MotionValue`.\n   *\n   * @remarks\n   *\n   * ```jsx\n   * const x = useMotionValue(0)\n   * x.set(10)\n   * ```\n   *\n   * @param latest - Latest value to set.\n   * @param render - Whether to notify render subscribers. Defaults to `true`\n   *\n   * @public\n   */\n  set(e) {\n    this.passiveEffect ? this.passiveEffect(e, this.updateAndNotify) : this.updateAndNotify(e);\n  }\n  setWithVelocity(e, n, s) {\n    this.set(n), this.prev = void 0, this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt - s;\n  }\n  /**\n   * Set the state of the `MotionValue`, stopping any active animations,\n   * effects, and resets velocity to `0`.\n   */\n  jump(e, n = !0) {\n    this.updateAndNotify(e), this.prev = e, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();\n  }\n  dirty() {\n    this.events.change?.notify(this.current);\n  }\n  addDependent(e) {\n    this.dependents || (this.dependents = /* @__PURE__ */ new Set()), this.dependents.add(e);\n  }\n  removeDependent(e) {\n    this.dependents && this.dependents.delete(e);\n  }\n  /**\n   * Returns the latest state of `MotionValue`\n   *\n   * @returns - The latest state of `MotionValue`\n   *\n   * @public\n   */\n  get() {\n    return this.current;\n  }\n  /**\n   * @public\n   */\n  getPrevious() {\n    return this.prev;\n  }\n  /**\n   * Returns the latest velocity of `MotionValue`\n   *\n   * @returns - The latest velocity of `MotionValue`. Returns `0` if the state is non-numerical.\n   *\n   * @public\n   */\n  getVelocity() {\n    const e = yt.now();\n    if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > dr)\n      return 0;\n    const n = Math.min(this.updatedAt - this.prevUpdatedAt, dr);\n    return zo(parseFloat(this.current) - parseFloat(this.prevFrameValue), n);\n  }\n  /**\n   * Registers a new animation to control this `MotionValue`. Only one\n   * animation can drive a `MotionValue` at one time.\n   *\n   * ```jsx\n   * value.start()\n   * ```\n   *\n   * @param animation - A function that starts the provided animation\n   */\n  start(e) {\n    return this.stop(), new Promise((n) => {\n      this.hasAnimated = !0, this.animation = e(n), this.events.animationStart && this.events.animationStart.notify();\n    }).then(() => {\n      this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation();\n    });\n  }\n  /**\n   * Stop the currently active animation.\n   *\n   * @public\n   */\n  stop() {\n    this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation();\n  }\n  /**\n   * Returns `true` if this value is currently animating.\n   *\n   * @public\n   */\n  isAnimating() {\n    return !!this.animation;\n  }\n  clearAnimation() {\n    delete this.animation;\n  }\n  /**\n   * Destroy and clean up subscribers to this `MotionValue`.\n   *\n   * The `MotionValue` hooks like `useMotionValue` and `useTransform` automatically\n   * handle the lifecycle of the returned `MotionValue`, so this method is only necessary if you've manually\n   * created a `MotionValue` via the `motionValue` function.\n   *\n   * @public\n   */\n  destroy() {\n    this.dependents?.clear(), this.events.destroy?.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect();\n  }\n}\nfunction Te(t, e) {\n  return new uh(t, e);\n}\nconst { schedule: yi } = /* @__PURE__ */ ta(queueMicrotask, !1), It = {\n  x: !1,\n  y: !1\n};\nfunction Pa() {\n  return It.x || It.y;\n}\nfunction dh(t) {\n  return t === \"x\" || t === \"y\" ? It[t] ? null : (It[t] = !0, () => {\n    It[t] = !1;\n  }) : It.x || It.y ? null : (It.x = It.y = !0, () => {\n    It.x = It.y = !1;\n  });\n}\nfunction Ra(t, e) {\n  const n = lh(t), s = new AbortController(), i = {\n    passive: !0,\n    ...e,\n    signal: s.signal\n  };\n  return [n, i, () => s.abort()];\n}\nfunction hr(t) {\n  return !(t.pointerType === \"touch\" || Pa());\n}\nfunction hh(t, e, n = {}) {\n  const [s, i, r] = Ra(t, n), o = (a) => {\n    if (!hr(a))\n      return;\n    const { target: l } = a, u = e(l, a);\n    if (typeof u != \"function\" || !l)\n      return;\n    const c = (d) => {\n      hr(d) && (u(d), l.removeEventListener(\"pointerleave\", c));\n    };\n    l.addEventListener(\"pointerleave\", c, i);\n  };\n  return s.forEach((a) => {\n    a.addEventListener(\"pointerenter\", o, i);\n  }), r;\n}\nconst Ma = (t, e) => e ? t === e ? !0 : Ma(t, e.parentElement) : !1, vi = (t) => t.pointerType === \"mouse\" ? typeof t.button != \"number\" || t.button <= 0 : t.isPrimary !== !1, fh = /* @__PURE__ */ new Set([\n  \"BUTTON\",\n  \"INPUT\",\n  \"SELECT\",\n  \"TEXTAREA\",\n  \"A\"\n]);\nfunction ph(t) {\n  return fh.has(t.tagName) || t.tabIndex !== -1;\n}\nconst yn = /* @__PURE__ */ new WeakSet();\nfunction fr(t) {\n  return (e) => {\n    e.key === \"Enter\" && t(e);\n  };\n}\nfunction Jn(t, e) {\n  t.dispatchEvent(new PointerEvent(\"pointer\" + e, { isPrimary: !0, bubbles: !0 }));\n}\nconst mh = (t, e) => {\n  const n = t.currentTarget;\n  if (!n)\n    return;\n  const s = fr(() => {\n    if (yn.has(n))\n      return;\n    Jn(n, \"down\");\n    const i = fr(() => {\n      Jn(n, \"up\");\n    }), r = () => Jn(n, \"cancel\");\n    n.addEventListener(\"keyup\", i, e), n.addEventListener(\"blur\", r, e);\n  });\n  n.addEventListener(\"keydown\", s, e), n.addEventListener(\"blur\", () => n.removeEventListener(\"keydown\", s), e);\n};\nfunction pr(t) {\n  return vi(t) && !Pa();\n}\nfunction gh(t, e, n = {}) {\n  const [s, i, r] = Ra(t, n), o = (a) => {\n    const l = a.currentTarget;\n    if (!pr(a))\n      return;\n    yn.add(l);\n    const u = e(l, a), c = (f, g) => {\n      window.removeEventListener(\"pointerup\", d), window.removeEventListener(\"pointercancel\", h), yn.has(l) && yn.delete(l), pr(f) && typeof u == \"function\" && u(f, { success: g });\n    }, d = (f) => {\n      c(f, l === window || l === document || n.useGlobalTarget || Ma(l, f.target));\n    }, h = (f) => {\n      c(f, !1);\n    };\n    window.addEventListener(\"pointerup\", d, i), window.addEventListener(\"pointercancel\", h, i);\n  };\n  return s.forEach((a) => {\n    (n.useGlobalTarget ? window : a).addEventListener(\"pointerdown\", o, i), Aa(a) && (a.addEventListener(\"focus\", (u) => mh(u, i)), !ph(a) && !a.hasAttribute(\"tabindex\") && (a.tabIndex = 0));\n  }), r;\n}\nfunction Ea(t) {\n  return _o(t) && \"ownerSVGElement\" in t;\n}\nfunction yh(t) {\n  return Ea(t) && t.tagName === \"svg\";\n}\nconst ft = (t) => !!(t && t.getVelocity), vh = [...Ta, nt, ne], xh = (t) => vh.find(wa(t)), xi = Lt({\n  transformPagePoint: (t) => t,\n  isStatic: !1,\n  reducedMotion: \"never\"\n});\nfunction mr(t, e) {\n  if (typeof t == \"function\")\n    return t(e);\n  t != null && (t.current = e);\n}\nfunction bh(...t) {\n  return (e) => {\n    let n = !1;\n    const s = t.map((i) => {\n      const r = mr(i, e);\n      return !n && typeof r == \"function\" && (n = !0), r;\n    });\n    if (n)\n      return () => {\n        for (let i = 0; i < s.length; i++) {\n          const r = s[i];\n          typeof r == \"function\" ? r() : mr(t[i], null);\n        }\n      };\n  };\n}\nfunction wh(...t) {\n  return En.useCallback(bh(...t), t);\n}\nclass Th extends En.Component {\n  getSnapshotBeforeUpdate(e) {\n    const n = this.props.childRef.current;\n    if (n && e.isPresent && !this.props.isPresent) {\n      const s = n.offsetParent, i = Aa(s) && s.offsetWidth || 0, r = this.props.sizeRef.current;\n      r.height = n.offsetHeight || 0, r.width = n.offsetWidth || 0, r.top = n.offsetTop, r.left = n.offsetLeft, r.right = i - r.width - r.left;\n    }\n    return null;\n  }\n  /**\n   * Required with getSnapshotBeforeUpdate to stop React complaining.\n   */\n  componentDidUpdate() {\n  }\n  render() {\n    return this.props.children;\n  }\n}\nfunction Sh({ children: t, isPresent: e, anchorX: n, root: s }) {\n  const i = $s(), r = j(null), o = j({\n    width: 0,\n    height: 0,\n    top: 0,\n    left: 0,\n    right: 0\n  }), { nonce: a } = q(xi), l = wh(r, t?.ref);\n  return po(() => {\n    const { width: u, height: c, top: d, left: h, right: f } = o.current;\n    if (e || !r.current || !u || !c)\n      return;\n    const g = n === \"left\" ? `left: ${h}` : `right: ${f}`;\n    r.current.dataset.motionPopId = i;\n    const v = document.createElement(\"style\");\n    a && (v.nonce = a);\n    const y = s ?? document.head;\n    return y.appendChild(v), v.sheet && v.sheet.insertRule(`\n          [data-motion-pop-id=\"${i}\"] {\n            position: absolute !important;\n            width: ${u}px !important;\n            height: ${c}px !important;\n            ${g}px !important;\n            top: ${d}px !important;\n          }\n        `), () => {\n      y.contains(v) && y.removeChild(v);\n    };\n  }, [e]), p.jsx(Th, { isPresent: e, childRef: r, sizeRef: o, children: En.cloneElement(t, { ref: l }) });\n}\nconst Dh = ({ children: t, initial: e, isPresent: n, onExitComplete: s, custom: i, presenceAffectsLayout: r, mode: o, anchorX: a, root: l }) => {\n  const u = Js(Ch), c = $s();\n  let d = !0, h = W(() => (d = !1, {\n    id: c,\n    initial: e,\n    isPresent: n,\n    custom: i,\n    onExitComplete: (f) => {\n      u.set(f, !0);\n      for (const g of u.values())\n        if (!g)\n          return;\n      s && s();\n    },\n    register: (f) => (u.set(f, !1), () => u.delete(f))\n  }), [n, u, s]);\n  return r && d && (h = { ...h }), W(() => {\n    u.forEach((f, g) => u.set(g, !1));\n  }, [n]), En.useEffect(() => {\n    !n && !u.size && s && s();\n  }, [n]), o === \"popLayout\" && (t = p.jsx(Sh, { isPresent: n, anchorX: a, root: l, children: t })), p.jsx(jn.Provider, { value: h, children: t });\n};\nfunction Ch() {\n  return /* @__PURE__ */ new Map();\n}\nfunction Va(t = !0) {\n  const e = q(jn);\n  if (e === null)\n    return [!0, null];\n  const { isPresent: n, onExitComplete: s, register: i } = e, r = $s();\n  B(() => {\n    if (t)\n      return i(r);\n  }, [t]);\n  const o = lt(() => t && s && s(r), [r, s, t]);\n  return !n && s ? [!1, o] : [!0];\n}\nconst fn = (t) => t.key || \"\";\nfunction gr(t) {\n  const e = [];\n  return Ml.forEach(t, (n) => {\n    El(n) && e.push(n);\n  }), e;\n}\nconst Ah = ({ children: t, custom: e, initial: n = !0, onExitComplete: s, presenceAffectsLayout: i = !0, mode: r = \"sync\", propagate: o = !1, anchorX: a = \"left\", root: l }) => {\n  const [u, c] = Va(o), d = W(() => gr(t), [t]), h = o && !u ? [] : d.map(fn), f = j(!0), g = j(d), v = Js(() => /* @__PURE__ */ new Map()), [y, x] = L(d), [T, b] = L(d);\n  Bo(() => {\n    f.current = !1, g.current = d;\n    for (let R = 0; R < T.length; R++) {\n      const m = fn(T[R]);\n      h.includes(m) ? v.delete(m) : v.get(m) !== !0 && v.set(m, !1);\n    }\n  }, [T, h.length, h.join(\"-\")]);\n  const P = [];\n  if (d !== y) {\n    let R = [...d];\n    for (let m = 0; m < T.length; m++) {\n      const w = T[m], C = fn(w);\n      h.includes(C) || (R.splice(m, 0, w), P.push(w));\n    }\n    return r === \"wait\" && P.length && (R = P), b(gr(R)), x(d), null;\n  }\n  const { forceRender: D } = q(qs);\n  return p.jsx(p.Fragment, { children: T.map((R) => {\n    const m = fn(R), w = o && !u ? !1 : d === T || h.includes(m), C = () => {\n      if (v.has(m))\n        v.set(m, !0);\n      else\n        return;\n      let M = !0;\n      v.forEach((S) => {\n        S || (M = !1);\n      }), M && (D?.(), b(g.current), o && c?.(), s && s());\n    };\n    return p.jsx(Dh, { isPresent: w, initial: !f.current || n ? void 0 : !1, custom: e, presenceAffectsLayout: i, mode: r, root: l, onExitComplete: w ? void 0 : C, anchorX: a, children: R }, m);\n  }) });\n}, Na = Lt({ strict: !1 }), yr = {\n  animation: [\n    \"animate\",\n    \"variants\",\n    \"whileHover\",\n    \"whileTap\",\n    \"exit\",\n    \"whileInView\",\n    \"whileFocus\",\n    \"whileDrag\"\n  ],\n  exit: [\"exit\"],\n  drag: [\"drag\", \"dragControls\"],\n  focus: [\"whileFocus\"],\n  hover: [\"whileHover\", \"onHoverStart\", \"onHoverEnd\"],\n  tap: [\"whileTap\", \"onTap\", \"onTapStart\", \"onTapCancel\"],\n  pan: [\"onPan\", \"onPanStart\", \"onPanSessionStart\", \"onPanEnd\"],\n  inView: [\"whileInView\", \"onViewportEnter\", \"onViewportLeave\"],\n  layout: [\"layout\", \"layoutId\"]\n}, Se = {};\nfor (const t in yr)\n  Se[t] = {\n    isEnabled: (e) => yr[t].some((n) => !!e[n])\n  };\nfunction Ph(t) {\n  for (const e in t)\n    Se[e] = {\n      ...Se[e],\n      ...t[e]\n    };\n}\nconst Rh = /* @__PURE__ */ new Set([\n  \"animate\",\n  \"exit\",\n  \"variants\",\n  \"initial\",\n  \"style\",\n  \"values\",\n  \"variants\",\n  \"transition\",\n  \"transformTemplate\",\n  \"custom\",\n  \"inherit\",\n  \"onBeforeLayoutMeasure\",\n  \"onAnimationStart\",\n  \"onAnimationComplete\",\n  \"onUpdate\",\n  \"onDragStart\",\n  \"onDrag\",\n  \"onDragEnd\",\n  \"onMeasureDragConstraints\",\n  \"onDirectionLock\",\n  \"onDragTransitionEnd\",\n  \"_dragX\",\n  \"_dragY\",\n  \"onHoverStart\",\n  \"onHoverEnd\",\n  \"onViewportEnter\",\n  \"onViewportLeave\",\n  \"globalTapTarget\",\n  \"ignoreStrict\",\n  \"viewport\"\n]);\nfunction Pn(t) {\n  return t.startsWith(\"while\") || t.startsWith(\"drag\") && t !== \"draggable\" || t.startsWith(\"layout\") || t.startsWith(\"onTap\") || t.startsWith(\"onPan\") || t.startsWith(\"onLayout\") || Rh.has(t);\n}\nlet ka = (t) => !Pn(t);\nfunction Mh(t) {\n  typeof t == \"function\" && (ka = (e) => e.startsWith(\"on\") ? !Pn(e) : t(e));\n}\ntry {\n  Mh(require(\"@emotion/is-prop-valid\").default);\n} catch {\n}\nfunction Eh(t, e, n) {\n  const s = {};\n  for (const i in t)\n    i === \"values\" && typeof t.values == \"object\" || (ka(i) || n === !0 && Pn(i) || !e && !Pn(i) || // If trying to use native HTML drag events, forward drag listeners\n    t.draggable && i.startsWith(\"onDrag\")) && (s[i] = t[i]);\n  return s;\n}\nconst Ln = /* @__PURE__ */ Lt({});\nfunction On(t) {\n  return t !== null && typeof t == \"object\" && typeof t.start == \"function\";\n}\nfunction Je(t) {\n  return typeof t == \"string\" || Array.isArray(t);\n}\nconst bi = [\n  \"animate\",\n  \"whileInView\",\n  \"whileFocus\",\n  \"whileHover\",\n  \"whileTap\",\n  \"whileDrag\",\n  \"exit\"\n], wi = [\"initial\", ...bi];\nfunction Fn(t) {\n  return On(t.animate) || wi.some((e) => Je(t[e]));\n}\nfunction Ia(t) {\n  return !!(Fn(t) || t.variants);\n}\nfunction Vh(t, e) {\n  if (Fn(t)) {\n    const { initial: n, animate: s } = t;\n    return {\n      initial: n === !1 || Je(n) ? n : void 0,\n      animate: Je(s) ? s : void 0\n    };\n  }\n  return t.inherit !== !1 ? e : {};\n}\nfunction Nh(t) {\n  const { initial: e, animate: n } = Vh(t, q(Ln));\n  return W(() => ({ initial: e, animate: n }), [vr(e), vr(n)]);\n}\nfunction vr(t) {\n  return Array.isArray(t) ? t.join(\" \") : t;\n}\nfunction xr(t, e) {\n  return e.max === e.min ? 0 : t / (e.max - e.min) * 100;\n}\nconst je = {\n  correct: (t, e) => {\n    if (!e.target)\n      return t;\n    if (typeof t == \"string\")\n      if (I.test(t))\n        t = parseFloat(t);\n      else\n        return t;\n    const n = xr(t, e.target.x), s = xr(t, e.target.y);\n    return `${n}% ${s}%`;\n  }\n}, kh = {\n  correct: (t, { treeScale: e, projectionDelta: n }) => {\n    const s = t, i = ne.parse(t);\n    if (i.length > 5)\n      return s;\n    const r = ne.createTransformer(t), o = typeof i[0] != \"number\" ? 1 : 0, a = n.x.scale * e.x, l = n.y.scale * e.y;\n    i[0 + o] /= a, i[1 + o] /= l;\n    const u = J(a, l, 0.5);\n    return typeof i[2 + o] == \"number\" && (i[2 + o] /= u), typeof i[3 + o] == \"number\" && (i[3 + o] /= u), r(i);\n  }\n}, Vs = {\n  borderRadius: {\n    ...je,\n    applyTo: [\n      \"borderTopLeftRadius\",\n      \"borderTopRightRadius\",\n      \"borderBottomLeftRadius\",\n      \"borderBottomRightRadius\"\n    ]\n  },\n  borderTopLeftRadius: je,\n  borderTopRightRadius: je,\n  borderBottomLeftRadius: je,\n  borderBottomRightRadius: je,\n  boxShadow: kh\n};\nfunction ja(t, { layout: e, layoutId: n }) {\n  return Me.has(t) || t.startsWith(\"origin\") || (e || n !== void 0) && (!!Vs[t] || t === \"opacity\");\n}\nconst Ih = {\n  x: \"translateX\",\n  y: \"translateY\",\n  z: \"translateZ\",\n  transformPerspective: \"perspective\"\n}, jh = Re.length;\nfunction Lh(t, e, n) {\n  let s = \"\", i = !0;\n  for (let r = 0; r < jh; r++) {\n    const o = Re[r], a = t[o];\n    if (a === void 0)\n      continue;\n    let l = !0;\n    if (typeof a == \"number\" ? l = a === (o.startsWith(\"scale\") ? 1 : 0) : l = parseFloat(a) === 0, !l || n) {\n      const u = Ca(a, gi[o]);\n      if (!l) {\n        i = !1;\n        const c = Ih[o] || o;\n        s += `${c}(${u}) `;\n      }\n      n && (e[o] = u);\n    }\n  }\n  return s = s.trim(), n ? s = n(e, i ? \"\" : s) : i && (s = \"none\"), s;\n}\nfunction Ti(t, e, n) {\n  const { style: s, vars: i, transformOrigin: r } = t;\n  let o = !1, a = !1;\n  for (const l in e) {\n    const u = e[l];\n    if (Me.has(l)) {\n      o = !0;\n      continue;\n    } else if (na(l)) {\n      i[l] = u;\n      continue;\n    } else {\n      const c = Ca(u, gi[l]);\n      l.startsWith(\"origin\") ? (a = !0, r[l] = c) : s[l] = c;\n    }\n  }\n  if (e.transform || (o || n ? s.transform = Lh(e, t.transform, n) : s.transform && (s.transform = \"none\")), a) {\n    const { originX: l = \"50%\", originY: u = \"50%\", originZ: c = 0 } = r;\n    s.transformOrigin = `${l} ${u} ${c}`;\n  }\n}\nconst Si = () => ({\n  style: {},\n  transform: {},\n  transformOrigin: {},\n  vars: {}\n});\nfunction La(t, e, n) {\n  for (const s in e)\n    !ft(e[s]) && !ja(s, n) && (t[s] = e[s]);\n}\nfunction Oh({ transformTemplate: t }, e) {\n  return W(() => {\n    const n = Si();\n    return Ti(n, e, t), Object.assign({}, n.vars, n.style);\n  }, [e]);\n}\nfunction Fh(t, e) {\n  const n = t.style || {}, s = {};\n  return La(s, n, t), Object.assign(s, Oh(t, e)), s;\n}\nfunction Bh(t, e) {\n  const n = {}, s = Fh(t, e);\n  return t.drag && t.dragListener !== !1 && (n.draggable = !1, s.userSelect = s.WebkitUserSelect = s.WebkitTouchCallout = \"none\", s.touchAction = t.drag === !0 ? \"none\" : `pan-${t.drag === \"x\" ? \"y\" : \"x\"}`), t.tabIndex === void 0 && (t.onTap || t.onTapStart || t.whileTap) && (n.tabIndex = 0), n.style = s, n;\n}\nconst $h = {\n  offset: \"stroke-dashoffset\",\n  array: \"stroke-dasharray\"\n}, _h = {\n  offset: \"strokeDashoffset\",\n  array: \"strokeDasharray\"\n};\nfunction Uh(t, e, n = 1, s = 0, i = !0) {\n  t.pathLength = 1;\n  const r = i ? $h : _h;\n  t[r.offset] = I.transform(-s);\n  const o = I.transform(e), a = I.transform(n);\n  t[r.array] = `${o} ${a}`;\n}\nfunction Oa(t, {\n  attrX: e,\n  attrY: n,\n  attrScale: s,\n  pathLength: i,\n  pathSpacing: r = 1,\n  pathOffset: o = 0,\n  // This is object creation, which we try to avoid per-frame.\n  ...a\n}, l, u, c) {\n  if (Ti(t, a, u), l) {\n    t.style.viewBox && (t.attrs.viewBox = t.style.viewBox);\n    return;\n  }\n  t.attrs = t.style, t.style = {};\n  const { attrs: d, style: h } = t;\n  d.transform && (h.transform = d.transform, delete d.transform), (h.transform || d.transformOrigin) && (h.transformOrigin = d.transformOrigin ?? \"50% 50%\", delete d.transformOrigin), h.transform && (h.transformBox = c?.transformBox ?? \"fill-box\", delete d.transformBox), e !== void 0 && (d.x = e), n !== void 0 && (d.y = n), s !== void 0 && (d.scale = s), i !== void 0 && Uh(d, i, r, o, !1);\n}\nconst Fa = () => ({\n  ...Si(),\n  attrs: {}\n}), Ba = (t) => typeof t == \"string\" && t.toLowerCase() === \"svg\";\nfunction zh(t, e, n, s) {\n  const i = W(() => {\n    const r = Fa();\n    return Oa(r, e, Ba(s), t.transformTemplate, t.style), {\n      ...r.attrs,\n      style: { ...r.style }\n    };\n  }, [e]);\n  if (t.style) {\n    const r = {};\n    La(r, t.style, t), i.style = { ...r, ...i.style };\n  }\n  return i;\n}\nconst Wh = [\n  \"animate\",\n  \"circle\",\n  \"defs\",\n  \"desc\",\n  \"ellipse\",\n  \"g\",\n  \"image\",\n  \"line\",\n  \"filter\",\n  \"marker\",\n  \"mask\",\n  \"metadata\",\n  \"path\",\n  \"pattern\",\n  \"polygon\",\n  \"polyline\",\n  \"rect\",\n  \"stop\",\n  \"switch\",\n  \"symbol\",\n  \"svg\",\n  \"text\",\n  \"tspan\",\n  \"use\",\n  \"view\"\n];\nfunction Di(t) {\n  return (\n    /**\n     * If it's not a string, it's a custom React component. Currently we only support\n     * HTML custom React components.\n     */\n    typeof t != \"string\" || /**\n     * If it contains a dash, the element is a custom HTML webcomponent.\n     */\n    t.includes(\"-\") ? !1 : (\n      /**\n       * If it's in our list of lowercase SVG tags, it's an SVG component\n       */\n      !!(Wh.indexOf(t) > -1 || /**\n       * If it contains a capital letter, it's an SVG component\n       */\n      /[A-Z]/u.test(t))\n    )\n  );\n}\nfunction Kh(t, e, n, { latestValues: s }, i, r = !1) {\n  const a = (Di(t) ? zh : Bh)(e, s, i, t), l = Eh(e, typeof t == \"string\", r), u = t !== mo ? { ...l, ...a, ref: n } : {}, { children: c } = e, d = W(() => ft(c) ? c.get() : c, [c]);\n  return Vl(t, {\n    ...u,\n    children: d\n  });\n}\nfunction br(t) {\n  const e = [{}, {}];\n  return t?.values.forEach((n, s) => {\n    e[0][s] = n.get(), e[1][s] = n.getVelocity();\n  }), e;\n}\nfunction Ci(t, e, n, s) {\n  if (typeof e == \"function\") {\n    const [i, r] = br(s);\n    e = e(n !== void 0 ? n : t.custom, i, r);\n  }\n  if (typeof e == \"string\" && (e = t.variants && t.variants[e]), typeof e == \"function\") {\n    const [i, r] = br(s);\n    e = e(n !== void 0 ? n : t.custom, i, r);\n  }\n  return e;\n}\nfunction vn(t) {\n  return ft(t) ? t.get() : t;\n}\nfunction Gh({ scrapeMotionValuesFromProps: t, createRenderState: e }, n, s, i) {\n  return {\n    latestValues: Hh(n, s, i, t),\n    renderState: e()\n  };\n}\nfunction Hh(t, e, n, s) {\n  const i = {}, r = s(t, {});\n  for (const h in r)\n    i[h] = vn(r[h]);\n  let { initial: o, animate: a } = t;\n  const l = Fn(t), u = Ia(t);\n  e && u && !l && t.inherit !== !1 && (o === void 0 && (o = e.initial), a === void 0 && (a = e.animate));\n  let c = n ? n.initial === !1 : !1;\n  c = c || o === !1;\n  const d = c ? a : o;\n  if (d && typeof d != \"boolean\" && !On(d)) {\n    const h = Array.isArray(d) ? d : [d];\n    for (let f = 0; f < h.length; f++) {\n      const g = Ci(t, h[f]);\n      if (g) {\n        const { transitionEnd: v, transition: y, ...x } = g;\n        for (const T in x) {\n          let b = x[T];\n          if (Array.isArray(b)) {\n            const P = c ? b.length - 1 : 0;\n            b = b[P];\n          }\n          b !== null && (i[T] = b);\n        }\n        for (const T in v)\n          i[T] = v[T];\n      }\n    }\n  }\n  return i;\n}\nconst $a = (t) => (e, n) => {\n  const s = q(Ln), i = q(jn), r = () => Gh(t, e, s, i);\n  return n ? r() : Js(r);\n};\nfunction Ai(t, e, n) {\n  const { style: s } = t, i = {};\n  for (const r in s)\n    (ft(s[r]) || e.style && ft(e.style[r]) || ja(r, t) || n?.getValue(r)?.liveStyle !== void 0) && (i[r] = s[r]);\n  return i;\n}\nconst Xh = /* @__PURE__ */ $a({\n  scrapeMotionValuesFromProps: Ai,\n  createRenderState: Si\n});\nfunction _a(t, e, n) {\n  const s = Ai(t, e, n);\n  for (const i in t)\n    if (ft(t[i]) || ft(e[i])) {\n      const r = Re.indexOf(i) !== -1 ? \"attr\" + i.charAt(0).toUpperCase() + i.substring(1) : i;\n      s[r] = t[i];\n    }\n  return s;\n}\nconst Yh = /* @__PURE__ */ $a({\n  scrapeMotionValuesFromProps: _a,\n  createRenderState: Fa\n}), qh = Symbol.for(\"motionComponentSymbol\");\nfunction ge(t) {\n  return t && typeof t == \"object\" && Object.prototype.hasOwnProperty.call(t, \"current\");\n}\nfunction Jh(t, e, n) {\n  return lt(\n    (s) => {\n      s && t.onMount && t.onMount(s), e && (s ? e.mount(s) : e.unmount()), n && (typeof n == \"function\" ? n(s) : ge(n) && (n.current = s));\n    },\n    /**\n     * Include externalRef in dependencies to ensure the callback updates\n     * when the ref changes, allowing proper ref forwarding.\n     */\n    [e]\n  );\n}\nconst Pi = (t) => t.replace(/([a-z])([A-Z])/gu, \"$1-$2\").toLowerCase(), Zh = \"framerAppearId\", Ua = \"data-\" + Pi(Zh), za = Lt({});\nfunction Qh(t, e, n, s, i) {\n  const { visualElement: r } = q(Ln), o = q(Na), a = q(jn), l = q(xi).reducedMotion, u = j(null);\n  s = s || o.renderer, !u.current && s && (u.current = s(t, {\n    visualState: e,\n    parent: r,\n    props: n,\n    presenceContext: a,\n    blockInitialAnimation: a ? a.initial === !1 : !1,\n    reducedMotionConfig: l\n  }));\n  const c = u.current, d = q(za);\n  c && !c.projection && i && (c.type === \"html\" || c.type === \"svg\") && tf(u.current, n, i, d);\n  const h = j(!1);\n  po(() => {\n    c && h.current && c.update(n, a);\n  });\n  const f = n[Ua], g = j(!!f && !window.MotionHandoffIsComplete?.(f) && window.MotionHasOptimisedAnimation?.(f));\n  return Bo(() => {\n    c && (h.current = !0, window.MotionIsMounted = !0, c.updateFeatures(), c.scheduleRenderMicrotask(), g.current && c.animationState && c.animationState.animateChanges());\n  }), B(() => {\n    c && (!g.current && c.animationState && c.animationState.animateChanges(), g.current && (queueMicrotask(() => {\n      window.MotionHandoffMarkAsComplete?.(f);\n    }), g.current = !1), c.enteringChildren = void 0);\n  }), c;\n}\nfunction tf(t, e, n, s) {\n  const { layoutId: i, layout: r, drag: o, dragConstraints: a, layoutScroll: l, layoutRoot: u, layoutCrossfade: c } = e;\n  t.projection = new n(t.latestValues, e[\"data-framer-portal-id\"] ? void 0 : Wa(t.parent)), t.projection.setOptions({\n    layoutId: i,\n    layout: r,\n    alwaysMeasureLayout: !!o || a && ge(a),\n    visualElement: t,\n    /**\n     * TODO: Update options in an effect. This could be tricky as it'll be too late\n     * to update by the time layout animations run.\n     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,\n     * ensuring it gets called if there's no potential layout animations.\n     *\n     */\n    animationType: typeof r == \"string\" ? r : \"both\",\n    initialPromotionConfig: s,\n    crossfade: c,\n    layoutScroll: l,\n    layoutRoot: u\n  });\n}\nfunction Wa(t) {\n  if (t)\n    return t.options.allowProjection !== !1 ? t.projection : Wa(t.parent);\n}\nfunction Zn(t, { forwardMotionProps: e = !1 } = {}, n, s) {\n  n && Ph(n);\n  const i = Di(t) ? Yh : Xh;\n  function r(a, l) {\n    let u;\n    const c = {\n      ...q(xi),\n      ...a,\n      layoutId: ef(a)\n    }, { isStatic: d } = c, h = Nh(a), f = i(a, d);\n    if (!d && Zs) {\n      nf();\n      const g = sf(c);\n      u = g.MeasureLayout, h.visualElement = Qh(t, f, c, s, g.ProjectionNode);\n    }\n    return p.jsxs(Ln.Provider, { value: h, children: [u && h.visualElement ? p.jsx(u, { visualElement: h.visualElement, ...c }) : null, Kh(t, a, Jh(f, h.visualElement, l), f, d, e)] });\n  }\n  r.displayName = `motion.${typeof t == \"string\" ? t : `create(${t.displayName ?? t.name ?? \"\"})`}`;\n  const o = Nl(r);\n  return o[qh] = t, o;\n}\nfunction ef({ layoutId: t }) {\n  const e = q(qs).id;\n  return e && t !== void 0 ? e + \"-\" + t : t;\n}\nfunction nf(t, e) {\n  q(Na).strict;\n}\nfunction sf(t) {\n  const { drag: e, layout: n } = Se;\n  if (!e && !n)\n    return {};\n  const s = { ...e, ...n };\n  return {\n    MeasureLayout: e?.isEnabled(t) || n?.isEnabled(t) ? s.MeasureLayout : void 0,\n    ProjectionNode: s.ProjectionNode\n  };\n}\nfunction rf(t, e) {\n  if (typeof Proxy > \"u\")\n    return Zn;\n  const n = /* @__PURE__ */ new Map(), s = (r, o) => Zn(r, o, t, e), i = (r, o) => s(r, o);\n  return new Proxy(i, {\n    /**\n     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.\n     * The prop name is passed through as `key` and we can use that to generate a `motion`\n     * DOM component with that name.\n     */\n    get: (r, o) => o === \"create\" ? s : (n.has(o) || n.set(o, Zn(o, void 0, t, e)), n.get(o))\n  });\n}\nfunction Ka({ top: t, left: e, right: n, bottom: s }) {\n  return {\n    x: { min: e, max: n },\n    y: { min: t, max: s }\n  };\n}\nfunction of({ x: t, y: e }) {\n  return { top: e.min, right: t.max, bottom: e.max, left: t.min };\n}\nfunction af(t, e) {\n  if (!e)\n    return t;\n  const n = e({ x: t.left, y: t.top }), s = e({ x: t.right, y: t.bottom });\n  return {\n    top: n.y,\n    left: n.x,\n    bottom: s.y,\n    right: s.x\n  };\n}\nfunction Qn(t) {\n  return t === void 0 || t === 1;\n}\nfunction Ns({ scale: t, scaleX: e, scaleY: n }) {\n  return !Qn(t) || !Qn(e) || !Qn(n);\n}\nfunction ae(t) {\n  return Ns(t) || Ga(t) || t.z || t.rotate || t.rotateX || t.rotateY || t.skewX || t.skewY;\n}\nfunction Ga(t) {\n  return wr(t.x) || wr(t.y);\n}\nfunction wr(t) {\n  return t && t !== \"0%\";\n}\nfunction Rn(t, e, n) {\n  const s = t - n, i = e * s;\n  return n + i;\n}\nfunction Tr(t, e, n, s, i) {\n  return i !== void 0 && (t = Rn(t, i, s)), Rn(t, n, s) + e;\n}\nfunction ks(t, e = 0, n = 1, s, i) {\n  t.min = Tr(t.min, e, n, s, i), t.max = Tr(t.max, e, n, s, i);\n}\nfunction Ha(t, { x: e, y: n }) {\n  ks(t.x, e.translate, e.scale, e.originPoint), ks(t.y, n.translate, n.scale, n.originPoint);\n}\nconst Sr = 0.999999999999, Dr = 1.0000000000001;\nfunction lf(t, e, n, s = !1) {\n  const i = n.length;\n  if (!i)\n    return;\n  e.x = e.y = 1;\n  let r, o;\n  for (let a = 0; a < i; a++) {\n    r = n[a], o = r.projectionDelta;\n    const { visualElement: l } = r.options;\n    l && l.props.style && l.props.style.display === \"contents\" || (s && r.options.layoutScroll && r.scroll && r !== r.root && ve(t, {\n      x: -r.scroll.offset.x,\n      y: -r.scroll.offset.y\n    }), o && (e.x *= o.x.scale, e.y *= o.y.scale, Ha(t, o)), s && ae(r.latestValues) && ve(t, r.latestValues));\n  }\n  e.x < Dr && e.x > Sr && (e.x = 1), e.y < Dr && e.y > Sr && (e.y = 1);\n}\nfunction ye(t, e) {\n  t.min = t.min + e, t.max = t.max + e;\n}\nfunction Cr(t, e, n, s, i = 0.5) {\n  const r = J(t.min, t.max, i);\n  ks(t, e, n, r, s);\n}\nfunction ve(t, e) {\n  Cr(t.x, e.x, e.scaleX, e.scale, e.originX), Cr(t.y, e.y, e.scaleY, e.scale, e.originY);\n}\nfunction Xa(t, e) {\n  return Ka(af(t.getBoundingClientRect(), e));\n}\nfunction cf(t, e, n) {\n  const s = Xa(t, n), { scroll: i } = e;\n  return i && (ye(s.x, i.offset.x), ye(s.y, i.offset.y)), s;\n}\nconst Ar = () => ({\n  translate: 0,\n  scale: 1,\n  origin: 0,\n  originPoint: 0\n}), xe = () => ({\n  x: Ar(),\n  y: Ar()\n}), Pr = () => ({ min: 0, max: 0 }), st = () => ({\n  x: Pr(),\n  y: Pr()\n}), Is = { current: null }, Ya = { current: !1 };\nfunction uf() {\n  if (Ya.current = !0, !!Zs)\n    if (window.matchMedia) {\n      const t = window.matchMedia(\"(prefers-reduced-motion)\"), e = () => Is.current = t.matches;\n      t.addEventListener(\"change\", e), e();\n    } else\n      Is.current = !1;\n}\nconst df = /* @__PURE__ */ new WeakMap();\nfunction hf(t, e, n) {\n  for (const s in e) {\n    const i = e[s], r = n[s];\n    if (ft(i))\n      t.addValue(s, i);\n    else if (ft(r))\n      t.addValue(s, Te(i, { owner: t }));\n    else if (r !== i)\n      if (t.hasValue(s)) {\n        const o = t.getValue(s);\n        o.liveStyle === !0 ? o.jump(i) : o.hasAnimated || o.set(i);\n      } else {\n        const o = t.getStaticValue(s);\n        t.addValue(s, Te(o !== void 0 ? o : i, { owner: t }));\n      }\n  }\n  for (const s in n)\n    e[s] === void 0 && t.removeValue(s);\n  return e;\n}\nconst Rr = [\n  \"AnimationStart\",\n  \"AnimationComplete\",\n  \"Update\",\n  \"BeforeLayoutMeasure\",\n  \"LayoutMeasure\",\n  \"LayoutAnimationStart\",\n  \"LayoutAnimationComplete\"\n];\nclass ff {\n  /**\n   * This method takes React props and returns found MotionValues. For example, HTML\n   * MotionValues will be found within the style prop, whereas for Three.js within attribute arrays.\n   *\n   * This isn't an abstract method as it needs calling in the constructor, but it is\n   * intended to be one.\n   */\n  scrapeMotionValuesFromProps(e, n, s) {\n    return {};\n  }\n  constructor({ parent: e, props: n, presenceContext: s, reducedMotionConfig: i, blockInitialAnimation: r, visualState: o }, a = {}) {\n    this.current = null, this.children = /* @__PURE__ */ new Set(), this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = /* @__PURE__ */ new Map(), this.KeyframeResolver = pi, this.features = {}, this.valueSubscriptions = /* @__PURE__ */ new Map(), this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify(\"Update\", this.latestValues), this.render = () => {\n      this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection));\n    }, this.renderScheduledAt = 0, this.scheduleRender = () => {\n      const h = yt.now();\n      this.renderScheduledAt < h && (this.renderScheduledAt = h, Y.render(this.render, !1, !0));\n    };\n    const { latestValues: l, renderState: u } = o;\n    this.latestValues = l, this.baseTarget = { ...l }, this.initialValues = n.initial ? { ...l } : {}, this.renderState = u, this.parent = e, this.props = n, this.presenceContext = s, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = i, this.options = a, this.blockInitialAnimation = !!r, this.isControllingVariants = Fn(n), this.isVariantNode = Ia(n), this.isVariantNode && (this.variantChildren = /* @__PURE__ */ new Set()), this.manuallyAnimateOnMount = !!(e && e.current);\n    const { willChange: c, ...d } = this.scrapeMotionValuesFromProps(n, {}, this);\n    for (const h in d) {\n      const f = d[h];\n      l[h] !== void 0 && ft(f) && f.set(l[h]);\n    }\n  }\n  mount(e) {\n    this.current = e, df.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((n, s) => this.bindToMotionValue(s, n)), Ya.current || uf(), this.shouldReduceMotion = this.reducedMotionConfig === \"never\" ? !1 : this.reducedMotionConfig === \"always\" ? !0 : Is.current, this.parent?.addChild(this), this.update(this.props, this.presenceContext);\n  }\n  unmount() {\n    this.projection && this.projection.unmount(), ee(this.notifyUpdate), ee(this.render), this.valueSubscriptions.forEach((e) => e()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent?.removeChild(this);\n    for (const e in this.events)\n      this.events[e].clear();\n    for (const e in this.features) {\n      const n = this.features[e];\n      n && (n.unmount(), n.isMounted = !1);\n    }\n    this.current = null;\n  }\n  addChild(e) {\n    this.children.add(e), this.enteringChildren ?? (this.enteringChildren = /* @__PURE__ */ new Set()), this.enteringChildren.add(e);\n  }\n  removeChild(e) {\n    this.children.delete(e), this.enteringChildren && this.enteringChildren.delete(e);\n  }\n  bindToMotionValue(e, n) {\n    this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();\n    const s = Me.has(e);\n    s && this.onBindTransform && this.onBindTransform();\n    const i = n.on(\"change\", (o) => {\n      this.latestValues[e] = o, this.props.onUpdate && Y.preRender(this.notifyUpdate), s && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender();\n    });\n    let r;\n    window.MotionCheckAppearSync && (r = window.MotionCheckAppearSync(this, e, n)), this.valueSubscriptions.set(e, () => {\n      i(), r && r(), n.owner && n.stop();\n    });\n  }\n  sortNodePosition(e) {\n    return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current);\n  }\n  updateFeatures() {\n    let e = \"animation\";\n    for (e in Se) {\n      const n = Se[e];\n      if (!n)\n        continue;\n      const { isEnabled: s, Feature: i } = n;\n      if (!this.features[e] && i && s(this.props) && (this.features[e] = new i(this)), this.features[e]) {\n        const r = this.features[e];\n        r.isMounted ? r.update() : (r.mount(), r.isMounted = !0);\n      }\n    }\n  }\n  triggerBuild() {\n    this.build(this.renderState, this.latestValues, this.props);\n  }\n  /**\n   * Measure the current viewport box with or without transforms.\n   * Only measures axis-aligned boxes, rotate and skew must be manually\n   * removed with a re-render to work.\n   */\n  measureViewportBox() {\n    return this.current ? this.measureInstanceViewportBox(this.current, this.props) : st();\n  }\n  getStaticValue(e) {\n    return this.latestValues[e];\n  }\n  setStaticValue(e, n) {\n    this.latestValues[e] = n;\n  }\n  /**\n   * Update the provided props. Ensure any newly-added motion values are\n   * added to our map, old ones removed, and listeners updated.\n   */\n  update(e, n) {\n    (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = n;\n    for (let s = 0; s < Rr.length; s++) {\n      const i = Rr[s];\n      this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);\n      const r = \"on\" + i, o = e[r];\n      o && (this.propEventSubscriptions[i] = this.on(i, o));\n    }\n    this.prevMotionValues = hf(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue();\n  }\n  getProps() {\n    return this.props;\n  }\n  /**\n   * Returns the variant definition with a given name.\n   */\n  getVariant(e) {\n    return this.props.variants ? this.props.variants[e] : void 0;\n  }\n  /**\n   * Returns the defined default transition on this component.\n   */\n  getDefaultTransition() {\n    return this.props.transition;\n  }\n  getTransformPagePoint() {\n    return this.props.transformPagePoint;\n  }\n  getClosestVariantNode() {\n    return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0;\n  }\n  /**\n   * Add a child visual element to our set of children.\n   */\n  addVariantChild(e) {\n    const n = this.getClosestVariantNode();\n    if (n)\n      return n.variantChildren && n.variantChildren.add(e), () => n.variantChildren.delete(e);\n  }\n  /**\n   * Add a motion value and bind it to this visual element.\n   */\n  addValue(e, n) {\n    const s = this.values.get(e);\n    n !== s && (s && this.removeValue(e), this.bindToMotionValue(e, n), this.values.set(e, n), this.latestValues[e] = n.get());\n  }\n  /**\n   * Remove a motion value and unbind any active subscriptions.\n   */\n  removeValue(e) {\n    this.values.delete(e);\n    const n = this.valueSubscriptions.get(e);\n    n && (n(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState);\n  }\n  /**\n   * Check whether we have a motion value for this key\n   */\n  hasValue(e) {\n    return this.values.has(e);\n  }\n  getValue(e, n) {\n    if (this.props.values && this.props.values[e])\n      return this.props.values[e];\n    let s = this.values.get(e);\n    return s === void 0 && n !== void 0 && (s = Te(n === null ? void 0 : n, { owner: this }), this.addValue(e, s)), s;\n  }\n  /**\n   * If we're trying to animate to a previously unencountered value,\n   * we need to check for it in our state and as a last resort read it\n   * directly from the instance (which might have performance implications).\n   */\n  readValue(e, n) {\n    let s = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : this.getBaseTargetFromProps(this.props, e) ?? this.readValueFromInstance(this.current, e, this.options);\n    return s != null && (typeof s == \"string\" && ($o(s) || Uo(s)) ? s = parseFloat(s) : !xh(s) && ne.test(n) && (s = Da(e, n)), this.setBaseTarget(e, ft(s) ? s.get() : s)), ft(s) ? s.get() : s;\n  }\n  /**\n   * Set the base target to later animate back to. This is currently\n   * only hydrated on creation and when we first read a value.\n   */\n  setBaseTarget(e, n) {\n    this.baseTarget[e] = n;\n  }\n  /**\n   * Find the base target for a value thats been removed from all animation\n   * props.\n   */\n  getBaseTarget(e) {\n    const { initial: n } = this.props;\n    let s;\n    if (typeof n == \"string\" || typeof n == \"object\") {\n      const r = Ci(this.props, n, this.presenceContext?.custom);\n      r && (s = r[e]);\n    }\n    if (n && s !== void 0)\n      return s;\n    const i = this.getBaseTargetFromProps(this.props, e);\n    return i !== void 0 && !ft(i) ? i : this.initialValues[e] !== void 0 && s === void 0 ? void 0 : this.baseTarget[e];\n  }\n  on(e, n) {\n    return this.events[e] || (this.events[e] = new si()), this.events[e].add(n);\n  }\n  notify(e, ...n) {\n    this.events[e] && this.events[e].notify(...n);\n  }\n  scheduleRenderMicrotask() {\n    yi.render(this.render);\n  }\n}\nclass qa extends ff {\n  constructor() {\n    super(...arguments), this.KeyframeResolver = ah;\n  }\n  sortInstanceNodePosition(e, n) {\n    return e.compareDocumentPosition(n) & 2 ? 1 : -1;\n  }\n  getBaseTargetFromProps(e, n) {\n    return e.style ? e.style[n] : void 0;\n  }\n  removeValueFromRenderState(e, { vars: n, style: s }) {\n    delete n[e], delete s[e];\n  }\n  handleChildMotionValue() {\n    this.childSubscription && (this.childSubscription(), delete this.childSubscription);\n    const { children: e } = this.props;\n    ft(e) && (this.childSubscription = e.on(\"change\", (n) => {\n      this.current && (this.current.textContent = `${n}`);\n    }));\n  }\n}\nfunction Ja(t, { style: e, vars: n }, s, i) {\n  const r = t.style;\n  let o;\n  for (o in e)\n    r[o] = e[o];\n  i?.applyProjectionStyles(r, s);\n  for (o in n)\n    r.setProperty(o, n[o]);\n}\nfunction pf(t) {\n  return window.getComputedStyle(t);\n}\nclass mf extends qa {\n  constructor() {\n    super(...arguments), this.type = \"html\", this.renderInstance = Ja;\n  }\n  readValueFromInstance(e, n) {\n    if (Me.has(n))\n      return this.projection?.isProjecting ? Ds(n) : Ad(e, n);\n    {\n      const s = pf(e), i = (na(n) ? s.getPropertyValue(n) : s[n]) || 0;\n      return typeof i == \"string\" ? i.trim() : i;\n    }\n  }\n  measureInstanceViewportBox(e, { transformPagePoint: n }) {\n    return Xa(e, n);\n  }\n  build(e, n, s) {\n    Ti(e, n, s.transformTemplate);\n  }\n  scrapeMotionValuesFromProps(e, n, s) {\n    return Ai(e, n, s);\n  }\n}\nconst Za = /* @__PURE__ */ new Set([\n  \"baseFrequency\",\n  \"diffuseConstant\",\n  \"kernelMatrix\",\n  \"kernelUnitLength\",\n  \"keySplines\",\n  \"keyTimes\",\n  \"limitingConeAngle\",\n  \"markerHeight\",\n  \"markerWidth\",\n  \"numOctaves\",\n  \"targetX\",\n  \"targetY\",\n  \"surfaceScale\",\n  \"specularConstant\",\n  \"specularExponent\",\n  \"stdDeviation\",\n  \"tableValues\",\n  \"viewBox\",\n  \"gradientTransform\",\n  \"pathLength\",\n  \"startOffset\",\n  \"textLength\",\n  \"lengthAdjust\"\n]);\nfunction gf(t, e, n, s) {\n  Ja(t, e, void 0, s);\n  for (const i in e.attrs)\n    t.setAttribute(Za.has(i) ? i : Pi(i), e.attrs[i]);\n}\nclass yf extends qa {\n  constructor() {\n    super(...arguments), this.type = \"svg\", this.isSVGTag = !1, this.measureInstanceViewportBox = st;\n  }\n  getBaseTargetFromProps(e, n) {\n    return e[n];\n  }\n  readValueFromInstance(e, n) {\n    if (Me.has(n)) {\n      const s = Sa(n);\n      return s && s.default || 0;\n    }\n    return n = Za.has(n) ? n : Pi(n), e.getAttribute(n);\n  }\n  scrapeMotionValuesFromProps(e, n, s) {\n    return _a(e, n, s);\n  }\n  build(e, n, s) {\n    Oa(e, n, this.isSVGTag, s.transformTemplate, s.style);\n  }\n  renderInstance(e, n, s, i) {\n    gf(e, n, s, i);\n  }\n  mount(e) {\n    this.isSVGTag = Ba(e.tagName), super.mount(e);\n  }\n}\nconst vf = (t, e) => Di(t) ? new yf(e) : new mf(e, {\n  allowProjection: t !== mo\n});\nfunction we(t, e, n) {\n  const s = t.getProps();\n  return Ci(s, e, n !== void 0 ? n : s.custom, t);\n}\nconst js = (t) => Array.isArray(t);\nfunction xf(t, e, n) {\n  t.hasValue(e) ? t.getValue(e).set(n) : t.addValue(e, Te(n));\n}\nfunction bf(t) {\n  return js(t) ? t[t.length - 1] || 0 : t;\n}\nfunction wf(t, e) {\n  const n = we(t, e);\n  let { transitionEnd: s = {}, transition: i = {}, ...r } = n || {};\n  r = { ...r, ...s };\n  for (const o in r) {\n    const a = bf(r[o]);\n    xf(t, o, a);\n  }\n}\nfunction Tf(t) {\n  return !!(ft(t) && t.add);\n}\nfunction Ls(t, e) {\n  const n = t.getValue(\"willChange\");\n  if (Tf(n))\n    return n.add(e);\n  if (!n && Ht.WillChange) {\n    const s = new Ht.WillChange(\"auto\");\n    t.addValue(\"willChange\", s), s.add(e);\n  }\n}\nfunction Qa(t) {\n  return t.props[Ua];\n}\nconst Sf = (t) => t !== null;\nfunction Df(t, { repeat: e, repeatType: n = \"loop\" }, s) {\n  const i = t.filter(Sf), r = e && n !== \"loop\" && e % 2 === 1 ? 0 : i.length - 1;\n  return i[r];\n}\nconst Cf = {\n  type: \"spring\",\n  stiffness: 500,\n  damping: 25,\n  restSpeed: 10\n}, Af = (t) => ({\n  type: \"spring\",\n  stiffness: 550,\n  damping: t === 0 ? 2 * Math.sqrt(550) : 30,\n  restSpeed: 10\n}), Pf = {\n  type: \"keyframes\",\n  duration: 0.8\n}, Rf = {\n  type: \"keyframes\",\n  ease: [0.25, 0.1, 0.35, 1],\n  duration: 0.3\n}, Mf = (t, { keyframes: e }) => e.length > 2 ? Pf : Me.has(t) ? t.startsWith(\"scale\") ? Af(e[1]) : Cf : Rf;\nfunction Ef({ when: t, delay: e, delayChildren: n, staggerChildren: s, staggerDirection: i, repeat: r, repeatType: o, repeatDelay: a, from: l, elapsed: u, ...c }) {\n  return !!Object.keys(c).length;\n}\nconst Ri = (t, e, n, s = {}, i, r) => (o) => {\n  const a = mi(s, t) || {}, l = a.delay || s.delay || 0;\n  let { elapsed: u = 0 } = s;\n  u = u - /* @__PURE__ */ Ut(l);\n  const c = {\n    keyframes: Array.isArray(n) ? n : [null, n],\n    ease: \"easeOut\",\n    velocity: e.getVelocity(),\n    ...a,\n    delay: -u,\n    onUpdate: (h) => {\n      e.set(h), a.onUpdate && a.onUpdate(h);\n    },\n    onComplete: () => {\n      o(), a.onComplete && a.onComplete();\n    },\n    name: t,\n    motionValue: e,\n    element: r ? void 0 : i\n  };\n  Ef(a) || Object.assign(c, Mf(t, c)), c.duration && (c.duration = /* @__PURE__ */ Ut(c.duration)), c.repeatDelay && (c.repeatDelay = /* @__PURE__ */ Ut(c.repeatDelay)), c.from !== void 0 && (c.keyframes[0] = c.from);\n  let d = !1;\n  if ((c.type === !1 || c.duration === 0 && !c.repeatDelay) && (Ms(c), c.delay === 0 && (d = !0)), (Ht.instantAnimations || Ht.skipAnimations) && (d = !0, Ms(c), c.delay = 0), c.allowFlatten = !a.type && !a.ease, d && !r && e.get() !== void 0) {\n    const h = Df(c.keyframes, a);\n    if (h !== void 0) {\n      Y.update(() => {\n        c.onUpdate(h), c.onComplete();\n      });\n      return;\n    }\n  }\n  return a.isSync ? new fi(c) : new Yd(c);\n};\nfunction Vf({ protectedKeys: t, needsAnimating: e }, n) {\n  const s = t.hasOwnProperty(n) && e[n] !== !0;\n  return e[n] = !1, s;\n}\nfunction tl(t, e, { delay: n = 0, transitionOverride: s, type: i } = {}) {\n  let { transition: r = t.getDefaultTransition(), transitionEnd: o, ...a } = e;\n  s && (r = s);\n  const l = [], u = i && t.animationState && t.animationState.getState()[i];\n  for (const c in a) {\n    const d = t.getValue(c, t.latestValues[c] ?? null), h = a[c];\n    if (h === void 0 || u && Vf(u, c))\n      continue;\n    const f = {\n      delay: n,\n      ...mi(r || {}, c)\n    }, g = d.get();\n    if (g !== void 0 && !d.isAnimating && !Array.isArray(h) && h === g && !f.velocity)\n      continue;\n    let v = !1;\n    if (window.MotionHandoffAnimation) {\n      const x = Qa(t);\n      if (x) {\n        const T = window.MotionHandoffAnimation(x, c, Y);\n        T !== null && (f.startTime = T, v = !0);\n      }\n    }\n    Ls(t, c), d.start(Ri(c, d, h, t.shouldReduceMotion && ba.has(c) ? { type: !1 } : f, t, v));\n    const y = d.animation;\n    y && l.push(y);\n  }\n  return o && Promise.all(l).then(() => {\n    Y.update(() => {\n      o && wf(t, o);\n    });\n  }), l;\n}\nfunction el(t, e, n, s = 0, i = 1) {\n  const r = Array.from(t).sort((u, c) => u.sortNodePosition(c)).indexOf(e), o = t.size, a = (o - 1) * s;\n  return typeof n == \"function\" ? n(r, o) : i === 1 ? r * s : a - r * s;\n}\nfunction Os(t, e, n = {}) {\n  const s = we(t, e, n.type === \"exit\" ? t.presenceContext?.custom : void 0);\n  let { transition: i = t.getDefaultTransition() || {} } = s || {};\n  n.transitionOverride && (i = n.transitionOverride);\n  const r = s ? () => Promise.all(tl(t, s, n)) : () => Promise.resolve(), o = t.variantChildren && t.variantChildren.size ? (l = 0) => {\n    const { delayChildren: u = 0, staggerChildren: c, staggerDirection: d } = i;\n    return Nf(t, e, l, u, c, d, n);\n  } : () => Promise.resolve(), { when: a } = i;\n  if (a) {\n    const [l, u] = a === \"beforeChildren\" ? [r, o] : [o, r];\n    return l().then(() => u());\n  } else\n    return Promise.all([r(), o(n.delay)]);\n}\nfunction Nf(t, e, n = 0, s = 0, i = 0, r = 1, o) {\n  const a = [];\n  for (const l of t.variantChildren)\n    l.notify(\"AnimationStart\", e), a.push(Os(l, e, {\n      ...o,\n      delay: n + (typeof s == \"function\" ? 0 : s) + el(t.variantChildren, l, s, i, r)\n    }).then(() => l.notify(\"AnimationComplete\", e)));\n  return Promise.all(a);\n}\nfunction kf(t, e, n = {}) {\n  t.notify(\"AnimationStart\", e);\n  let s;\n  if (Array.isArray(e)) {\n    const i = e.map((r) => Os(t, r, n));\n    s = Promise.all(i);\n  } else if (typeof e == \"string\")\n    s = Os(t, e, n);\n  else {\n    const i = typeof e == \"function\" ? we(t, e, n.custom) : e;\n    s = Promise.all(tl(t, i, n));\n  }\n  return s.then(() => {\n    t.notify(\"AnimationComplete\", e);\n  });\n}\nfunction nl(t, e) {\n  if (!Array.isArray(e))\n    return !1;\n  const n = e.length;\n  if (n !== t.length)\n    return !1;\n  for (let s = 0; s < n; s++)\n    if (e[s] !== t[s])\n      return !1;\n  return !0;\n}\nconst If = wi.length;\nfunction sl(t) {\n  if (!t)\n    return;\n  if (!t.isControllingVariants) {\n    const n = t.parent ? sl(t.parent) || {} : {};\n    return t.props.initial !== void 0 && (n.initial = t.props.initial), n;\n  }\n  const e = {};\n  for (let n = 0; n < If; n++) {\n    const s = wi[n], i = t.props[s];\n    (Je(i) || i === !1) && (e[s] = i);\n  }\n  return e;\n}\nconst jf = [...bi].reverse(), Lf = bi.length;\nfunction Of(t) {\n  return (e) => Promise.all(e.map(({ animation: n, options: s }) => kf(t, n, s)));\n}\nfunction Ff(t) {\n  let e = Of(t), n = Mr(), s = !0;\n  const i = (l) => (u, c) => {\n    const d = we(t, c, l === \"exit\" ? t.presenceContext?.custom : void 0);\n    if (d) {\n      const { transition: h, transitionEnd: f, ...g } = d;\n      u = { ...u, ...g, ...f };\n    }\n    return u;\n  };\n  function r(l) {\n    e = l(t);\n  }\n  function o(l) {\n    const { props: u } = t, c = sl(t.parent) || {}, d = [], h = /* @__PURE__ */ new Set();\n    let f = {}, g = 1 / 0;\n    for (let y = 0; y < Lf; y++) {\n      const x = jf[y], T = n[x], b = u[x] !== void 0 ? u[x] : c[x], P = Je(b), D = x === l ? T.isActive : null;\n      D === !1 && (g = y);\n      let R = b === c[x] && b !== u[x] && P;\n      if (R && s && t.manuallyAnimateOnMount && (R = !1), T.protectedKeys = { ...f }, // If it isn't active and hasn't *just* been set as inactive\n      !T.isActive && D === null || // If we didn't and don't have any defined prop for this animation type\n      !b && !T.prevProp || // Or if the prop doesn't define an animation\n      On(b) || typeof b == \"boolean\")\n        continue;\n      const m = Bf(T.prevProp, b);\n      let w = m || // If we're making this variant active, we want to always make it active\n      x === l && T.isActive && !R && P || // If we removed a higher-priority variant (i is in reverse order)\n      y > g && P, C = !1;\n      const M = Array.isArray(b) ? b : [b];\n      let S = M.reduce(i(x), {});\n      D === !1 && (S = {});\n      const { prevResolvedValues: N = {} } = T, O = {\n        ...N,\n        ...S\n      }, F = (k) => {\n        w = !0, h.has(k) && (C = !0, h.delete(k)), T.needsAnimating[k] = !0;\n        const U = t.getValue(k);\n        U && (U.liveStyle = !1);\n      };\n      for (const k in O) {\n        const U = S[k], H = N[k];\n        if (f.hasOwnProperty(k))\n          continue;\n        let tt = !1;\n        js(U) && js(H) ? tt = !nl(U, H) : tt = U !== H, tt ? U != null ? F(k) : h.add(k) : U !== void 0 && h.has(k) ? F(k) : T.protectedKeys[k] = !0;\n      }\n      T.prevProp = b, T.prevResolvedValues = S, T.isActive && (f = { ...f, ...S }), s && t.blockInitialAnimation && (w = !1);\n      const G = R && m;\n      w && (!G || C) && d.push(...M.map((k) => {\n        const U = { type: x };\n        if (typeof k == \"string\" && s && !G && t.manuallyAnimateOnMount && t.parent) {\n          const { parent: H } = t, tt = we(H, k);\n          if (H.enteringChildren && tt) {\n            const { delayChildren: et } = tt.transition || {};\n            U.delay = el(H.enteringChildren, t, et);\n          }\n        }\n        return {\n          animation: k,\n          options: U\n        };\n      }));\n    }\n    if (h.size) {\n      const y = {};\n      if (typeof u.initial != \"boolean\") {\n        const x = we(t, Array.isArray(u.initial) ? u.initial[0] : u.initial);\n        x && x.transition && (y.transition = x.transition);\n      }\n      h.forEach((x) => {\n        const T = t.getBaseTarget(x), b = t.getValue(x);\n        b && (b.liveStyle = !0), y[x] = T ?? null;\n      }), d.push({ animation: y });\n    }\n    let v = !!d.length;\n    return s && (u.initial === !1 || u.initial === u.animate) && !t.manuallyAnimateOnMount && (v = !1), s = !1, v ? e(d) : Promise.resolve();\n  }\n  function a(l, u) {\n    if (n[l].isActive === u)\n      return Promise.resolve();\n    t.variantChildren?.forEach((d) => d.animationState?.setActive(l, u)), n[l].isActive = u;\n    const c = o(l);\n    for (const d in n)\n      n[d].protectedKeys = {};\n    return c;\n  }\n  return {\n    animateChanges: o,\n    setActive: a,\n    setAnimateFunction: r,\n    getState: () => n,\n    reset: () => {\n      n = Mr();\n    }\n  };\n}\nfunction Bf(t, e) {\n  return typeof e == \"string\" ? e !== t : Array.isArray(e) ? !nl(e, t) : !1;\n}\nfunction oe(t = !1) {\n  return {\n    isActive: t,\n    protectedKeys: {},\n    needsAnimating: {},\n    prevResolvedValues: {}\n  };\n}\nfunction Mr() {\n  return {\n    animate: oe(!0),\n    whileInView: oe(),\n    whileHover: oe(),\n    whileTap: oe(),\n    whileDrag: oe(),\n    whileFocus: oe(),\n    exit: oe()\n  };\n}\nclass se {\n  constructor(e) {\n    this.isMounted = !1, this.node = e;\n  }\n  update() {\n  }\n}\nclass $f extends se {\n  /**\n   * We dynamically generate the AnimationState manager as it contains a reference\n   * to the underlying animation library. We only want to load that if we load this,\n   * so people can optionally code split it out using the `m` component.\n   */\n  constructor(e) {\n    super(e), e.animationState || (e.animationState = Ff(e));\n  }\n  updateAnimationControlsSubscription() {\n    const { animate: e } = this.node.getProps();\n    On(e) && (this.unmountControls = e.subscribe(this.node));\n  }\n  /**\n   * Subscribe any provided AnimationControls to the component's VisualElement\n   */\n  mount() {\n    this.updateAnimationControlsSubscription();\n  }\n  update() {\n    const { animate: e } = this.node.getProps(), { animate: n } = this.node.prevProps || {};\n    e !== n && this.updateAnimationControlsSubscription();\n  }\n  unmount() {\n    this.node.animationState.reset(), this.unmountControls?.();\n  }\n}\nlet _f = 0;\nclass Uf extends se {\n  constructor() {\n    super(...arguments), this.id = _f++;\n  }\n  update() {\n    if (!this.node.presenceContext)\n      return;\n    const { isPresent: e, onExitComplete: n } = this.node.presenceContext, { isPresent: s } = this.node.prevPresenceContext || {};\n    if (!this.node.animationState || e === s)\n      return;\n    const i = this.node.animationState.setActive(\"exit\", !e);\n    n && !e && i.then(() => {\n      n(this.id);\n    });\n  }\n  mount() {\n    const { register: e, onExitComplete: n } = this.node.presenceContext || {};\n    n && n(this.id), e && (this.unmount = e(this.id));\n  }\n  unmount() {\n  }\n}\nconst zf = {\n  animation: {\n    Feature: $f\n  },\n  exit: {\n    Feature: Uf\n  }\n};\nfunction Ze(t, e, n, s = { passive: !0 }) {\n  return t.addEventListener(e, n, s), () => t.removeEventListener(e, n);\n}\nfunction on(t) {\n  return {\n    point: {\n      x: t.pageX,\n      y: t.pageY\n    }\n  };\n}\nconst Wf = (t) => (e) => vi(e) && t(e, on(e));\nfunction Ue(t, e, n, s) {\n  return Ze(t, e, Wf(n), s);\n}\nconst il = 1e-4, Kf = 1 - il, Gf = 1 + il, rl = 0.01, Hf = 0 - rl, Xf = 0 + rl;\nfunction gt(t) {\n  return t.max - t.min;\n}\nfunction Yf(t, e, n) {\n  return Math.abs(t - e) <= n;\n}\nfunction Er(t, e, n, s = 0.5) {\n  t.origin = s, t.originPoint = J(e.min, e.max, t.origin), t.scale = gt(n) / gt(e), t.translate = J(n.min, n.max, t.origin) - t.originPoint, (t.scale >= Kf && t.scale <= Gf || isNaN(t.scale)) && (t.scale = 1), (t.translate >= Hf && t.translate <= Xf || isNaN(t.translate)) && (t.translate = 0);\n}\nfunction ze(t, e, n, s) {\n  Er(t.x, e.x, n.x, s ? s.originX : void 0), Er(t.y, e.y, n.y, s ? s.originY : void 0);\n}\nfunction Vr(t, e, n) {\n  t.min = n.min + e.min, t.max = t.min + gt(e);\n}\nfunction qf(t, e, n) {\n  Vr(t.x, e.x, n.x), Vr(t.y, e.y, n.y);\n}\nfunction Nr(t, e, n) {\n  t.min = e.min - n.min, t.max = t.min + gt(e);\n}\nfunction Mn(t, e, n) {\n  Nr(t.x, e.x, n.x), Nr(t.y, e.y, n.y);\n}\nfunction At(t) {\n  return [t(\"x\"), t(\"y\")];\n}\nconst ol = ({ current: t }) => t ? t.ownerDocument.defaultView : null, kr = (t, e) => Math.abs(t - e);\nfunction Jf(t, e) {\n  const n = kr(t.x, e.x), s = kr(t.y, e.y);\n  return Math.sqrt(n ** 2 + s ** 2);\n}\nclass al {\n  constructor(e, n, { transformPagePoint: s, contextWindow: i = window, dragSnapToOrigin: r = !1, distanceThreshold: o = 3 } = {}) {\n    if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {\n      if (!(this.lastMoveEvent && this.lastMoveEventInfo))\n        return;\n      const h = es(this.lastMoveEventInfo, this.history), f = this.startEvent !== null, g = Jf(h.offset, { x: 0, y: 0 }) >= this.distanceThreshold;\n      if (!f && !g)\n        return;\n      const { point: v } = h, { timestamp: y } = ut;\n      this.history.push({ ...v, timestamp: y });\n      const { onStart: x, onMove: T } = this.handlers;\n      f || (x && x(this.lastMoveEvent, h), this.startEvent = this.lastMoveEvent), T && T(this.lastMoveEvent, h);\n    }, this.handlePointerMove = (h, f) => {\n      this.lastMoveEvent = h, this.lastMoveEventInfo = ts(f, this.transformPagePoint), Y.update(this.updatePoint, !0);\n    }, this.handlePointerUp = (h, f) => {\n      this.end();\n      const { onEnd: g, onSessionEnd: v, resumeAnimation: y } = this.handlers;\n      if (this.dragSnapToOrigin && y && y(), !(this.lastMoveEvent && this.lastMoveEventInfo))\n        return;\n      const x = es(h.type === \"pointercancel\" ? this.lastMoveEventInfo : ts(f, this.transformPagePoint), this.history);\n      this.startEvent && g && g(h, x), v && v(h, x);\n    }, !vi(e))\n      return;\n    this.dragSnapToOrigin = r, this.handlers = n, this.transformPagePoint = s, this.distanceThreshold = o, this.contextWindow = i || window;\n    const a = on(e), l = ts(a, this.transformPagePoint), { point: u } = l, { timestamp: c } = ut;\n    this.history = [{ ...u, timestamp: c }];\n    const { onSessionStart: d } = n;\n    d && d(e, es(l, this.history)), this.removeListeners = nn(Ue(this.contextWindow, \"pointermove\", this.handlePointerMove), Ue(this.contextWindow, \"pointerup\", this.handlePointerUp), Ue(this.contextWindow, \"pointercancel\", this.handlePointerUp));\n  }\n  updateHandlers(e) {\n    this.handlers = e;\n  }\n  end() {\n    this.removeListeners && this.removeListeners(), ee(this.updatePoint);\n  }\n}\nfunction ts(t, e) {\n  return e ? { point: e(t.point) } : t;\n}\nfunction Ir(t, e) {\n  return { x: t.x - e.x, y: t.y - e.y };\n}\nfunction es({ point: t }, e) {\n  return {\n    point: t,\n    delta: Ir(t, ll(e)),\n    offset: Ir(t, Zf(e)),\n    velocity: Qf(e, 0.1)\n  };\n}\nfunction Zf(t) {\n  return t[0];\n}\nfunction ll(t) {\n  return t[t.length - 1];\n}\nfunction Qf(t, e) {\n  if (t.length < 2)\n    return { x: 0, y: 0 };\n  let n = t.length - 1, s = null;\n  const i = ll(t);\n  for (; n >= 0 && (s = t[n], !(i.timestamp - s.timestamp > /* @__PURE__ */ Ut(e))); )\n    n--;\n  if (!s)\n    return { x: 0, y: 0 };\n  const r = /* @__PURE__ */ Rt(i.timestamp - s.timestamp);\n  if (r === 0)\n    return { x: 0, y: 0 };\n  const o = {\n    x: (i.x - s.x) / r,\n    y: (i.y - s.y) / r\n  };\n  return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o;\n}\nfunction tp(t, { min: e, max: n }, s) {\n  return e !== void 0 && t < e ? t = s ? J(e, t, s.min) : Math.max(t, e) : n !== void 0 && t > n && (t = s ? J(n, t, s.max) : Math.min(t, n)), t;\n}\nfunction jr(t, e, n) {\n  return {\n    min: e !== void 0 ? t.min + e : void 0,\n    max: n !== void 0 ? t.max + n - (t.max - t.min) : void 0\n  };\n}\nfunction ep(t, { top: e, left: n, bottom: s, right: i }) {\n  return {\n    x: jr(t.x, n, i),\n    y: jr(t.y, e, s)\n  };\n}\nfunction Lr(t, e) {\n  let n = e.min - t.min, s = e.max - t.max;\n  return e.max - e.min < t.max - t.min && ([n, s] = [s, n]), { min: n, max: s };\n}\nfunction np(t, e) {\n  return {\n    x: Lr(t.x, e.x),\n    y: Lr(t.y, e.y)\n  };\n}\nfunction sp(t, e) {\n  let n = 0.5;\n  const s = gt(t), i = gt(e);\n  return i > s ? n = /* @__PURE__ */ Xe(e.min, e.max - s, t.min) : s > i && (n = /* @__PURE__ */ Xe(t.min, t.max - i, e.min)), Gt(0, 1, n);\n}\nfunction ip(t, e) {\n  const n = {};\n  return e.min !== void 0 && (n.min = e.min - t.min), e.max !== void 0 && (n.max = e.max - t.min), n;\n}\nconst Fs = 0.35;\nfunction rp(t = Fs) {\n  return t === !1 ? t = 0 : t === !0 && (t = Fs), {\n    x: Or(t, \"left\", \"right\"),\n    y: Or(t, \"top\", \"bottom\")\n  };\n}\nfunction Or(t, e, n) {\n  return {\n    min: Fr(t, e),\n    max: Fr(t, n)\n  };\n}\nfunction Fr(t, e) {\n  return typeof t == \"number\" ? t : t[e] || 0;\n}\nconst op = /* @__PURE__ */ new WeakMap();\nclass ap {\n  constructor(e) {\n    this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = st(), this.latestPointerEvent = null, this.latestPanInfo = null, this.visualElement = e;\n  }\n  start(e, { snapToCursor: n = !1, distanceThreshold: s } = {}) {\n    const { presenceContext: i } = this.visualElement;\n    if (i && i.isPresent === !1)\n      return;\n    const r = (d) => {\n      const { dragSnapToOrigin: h } = this.getProps();\n      h ? this.pauseAnimation() : this.stopAnimation(), n && this.snapToCursor(on(d).point);\n    }, o = (d, h) => {\n      const { drag: f, dragPropagation: g, onDragStart: v } = this.getProps();\n      if (f && !g && (this.openDragLock && this.openDragLock(), this.openDragLock = dh(f), !this.openDragLock))\n        return;\n      this.latestPointerEvent = d, this.latestPanInfo = h, this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), At((x) => {\n        let T = this.getAxisMotionValue(x).get() || 0;\n        if (zt.test(T)) {\n          const { projection: b } = this.visualElement;\n          if (b && b.layout) {\n            const P = b.layout.layoutBox[x];\n            P && (T = gt(P) * (parseFloat(T) / 100));\n          }\n        }\n        this.originPoint[x] = T;\n      }), v && Y.postRender(() => v(d, h)), Ls(this.visualElement, \"transform\");\n      const { animationState: y } = this.visualElement;\n      y && y.setActive(\"whileDrag\", !0);\n    }, a = (d, h) => {\n      this.latestPointerEvent = d, this.latestPanInfo = h;\n      const { dragPropagation: f, dragDirectionLock: g, onDirectionLock: v, onDrag: y } = this.getProps();\n      if (!f && !this.openDragLock)\n        return;\n      const { offset: x } = h;\n      if (g && this.currentDirection === null) {\n        this.currentDirection = lp(x), this.currentDirection !== null && v && v(this.currentDirection);\n        return;\n      }\n      this.updateAxis(\"x\", h.point, x), this.updateAxis(\"y\", h.point, x), this.visualElement.render(), y && y(d, h);\n    }, l = (d, h) => {\n      this.latestPointerEvent = d, this.latestPanInfo = h, this.stop(d, h), this.latestPointerEvent = null, this.latestPanInfo = null;\n    }, u = () => At((d) => this.getAnimationState(d) === \"paused\" && this.getAxisMotionValue(d).animation?.play()), { dragSnapToOrigin: c } = this.getProps();\n    this.panSession = new al(e, {\n      onSessionStart: r,\n      onStart: o,\n      onMove: a,\n      onSessionEnd: l,\n      resumeAnimation: u\n    }, {\n      transformPagePoint: this.visualElement.getTransformPagePoint(),\n      dragSnapToOrigin: c,\n      distanceThreshold: s,\n      contextWindow: ol(this.visualElement)\n    });\n  }\n  /**\n   * @internal\n   */\n  stop(e, n) {\n    const s = e || this.latestPointerEvent, i = n || this.latestPanInfo, r = this.isDragging;\n    if (this.cancel(), !r || !i || !s)\n      return;\n    const { velocity: o } = i;\n    this.startAnimation(o);\n    const { onDragEnd: a } = this.getProps();\n    a && Y.postRender(() => a(s, i));\n  }\n  /**\n   * @internal\n   */\n  cancel() {\n    this.isDragging = !1;\n    const { projection: e, animationState: n } = this.visualElement;\n    e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;\n    const { dragPropagation: s } = this.getProps();\n    !s && this.openDragLock && (this.openDragLock(), this.openDragLock = null), n && n.setActive(\"whileDrag\", !1);\n  }\n  updateAxis(e, n, s) {\n    const { drag: i } = this.getProps();\n    if (!s || !pn(e, i, this.currentDirection))\n      return;\n    const r = this.getAxisMotionValue(e);\n    let o = this.originPoint[e] + s[e];\n    this.constraints && this.constraints[e] && (o = tp(o, this.constraints[e], this.elastic[e])), r.set(o);\n  }\n  resolveConstraints() {\n    const { dragConstraints: e, dragElastic: n } = this.getProps(), s = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : this.visualElement.projection?.layout, i = this.constraints;\n    e && ge(e) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : e && s ? this.constraints = ep(s.layoutBox, e) : this.constraints = !1, this.elastic = rp(n), i !== this.constraints && s && this.constraints && !this.hasMutatedConstraints && At((r) => {\n      this.constraints !== !1 && this.getAxisMotionValue(r) && (this.constraints[r] = ip(s.layoutBox[r], this.constraints[r]));\n    });\n  }\n  resolveRefConstraints() {\n    const { dragConstraints: e, onMeasureDragConstraints: n } = this.getProps();\n    if (!e || !ge(e))\n      return !1;\n    const s = e.current, { projection: i } = this.visualElement;\n    if (!i || !i.layout)\n      return !1;\n    const r = cf(s, i.root, this.visualElement.getTransformPagePoint());\n    let o = np(i.layout.layoutBox, r);\n    if (n) {\n      const a = n(of(o));\n      this.hasMutatedConstraints = !!a, a && (o = Ka(a));\n    }\n    return o;\n  }\n  startAnimation(e) {\n    const { drag: n, dragMomentum: s, dragElastic: i, dragTransition: r, dragSnapToOrigin: o, onDragTransitionEnd: a } = this.getProps(), l = this.constraints || {}, u = At((c) => {\n      if (!pn(c, n, this.currentDirection))\n        return;\n      let d = l && l[c] || {};\n      o && (d = { min: 0, max: 0 });\n      const h = i ? 200 : 1e6, f = i ? 40 : 1e7, g = {\n        type: \"inertia\",\n        velocity: s ? e[c] : 0,\n        bounceStiffness: h,\n        bounceDamping: f,\n        timeConstant: 750,\n        restDelta: 1,\n        restSpeed: 10,\n        ...r,\n        ...d\n      };\n      return this.startAxisValueAnimation(c, g);\n    });\n    return Promise.all(u).then(a);\n  }\n  startAxisValueAnimation(e, n) {\n    const s = this.getAxisMotionValue(e);\n    return Ls(this.visualElement, e), s.start(Ri(e, s, 0, n, this.visualElement, !1));\n  }\n  stopAnimation() {\n    At((e) => this.getAxisMotionValue(e).stop());\n  }\n  pauseAnimation() {\n    At((e) => this.getAxisMotionValue(e).animation?.pause());\n  }\n  getAnimationState(e) {\n    return this.getAxisMotionValue(e).animation?.state;\n  }\n  /**\n   * Drag works differently depending on which props are provided.\n   *\n   * - If _dragX and _dragY are provided, we output the gesture delta directly to those motion values.\n   * - Otherwise, we apply the delta to the x/y motion values.\n   */\n  getAxisMotionValue(e) {\n    const n = `_drag${e.toUpperCase()}`, s = this.visualElement.getProps(), i = s[n];\n    return i || this.visualElement.getValue(e, (s.initial ? s.initial[e] : void 0) || 0);\n  }\n  snapToCursor(e) {\n    At((n) => {\n      const { drag: s } = this.getProps();\n      if (!pn(n, s, this.currentDirection))\n        return;\n      const { projection: i } = this.visualElement, r = this.getAxisMotionValue(n);\n      if (i && i.layout) {\n        const { min: o, max: a } = i.layout.layoutBox[n];\n        r.set(e[n] - J(o, a, 0.5));\n      }\n    });\n  }\n  /**\n   * When the viewport resizes we want to check if the measured constraints\n   * have changed and, if so, reposition the element within those new constraints\n   * relative to where it was before the resize.\n   */\n  scalePositionWithinConstraints() {\n    if (!this.visualElement.current)\n      return;\n    const { drag: e, dragConstraints: n } = this.getProps(), { projection: s } = this.visualElement;\n    if (!ge(n) || !s || !this.constraints)\n      return;\n    this.stopAnimation();\n    const i = { x: 0, y: 0 };\n    At((o) => {\n      const a = this.getAxisMotionValue(o);\n      if (a && this.constraints !== !1) {\n        const l = a.get();\n        i[o] = sp({ min: l, max: l }, this.constraints[o]);\n      }\n    });\n    const { transformTemplate: r } = this.visualElement.getProps();\n    this.visualElement.current.style.transform = r ? r({}, \"\") : \"none\", s.root && s.root.updateScroll(), s.updateLayout(), this.resolveConstraints(), At((o) => {\n      if (!pn(o, e, null))\n        return;\n      const a = this.getAxisMotionValue(o), { min: l, max: u } = this.constraints[o];\n      a.set(J(l, u, i[o]));\n    });\n  }\n  addListeners() {\n    if (!this.visualElement.current)\n      return;\n    op.set(this.visualElement, this);\n    const e = this.visualElement.current, n = Ue(e, \"pointerdown\", (l) => {\n      const { drag: u, dragListener: c = !0 } = this.getProps();\n      u && c && this.start(l);\n    }), s = () => {\n      const { dragConstraints: l } = this.getProps();\n      ge(l) && l.current && (this.constraints = this.resolveRefConstraints());\n    }, { projection: i } = this.visualElement, r = i.addEventListener(\"measure\", s);\n    i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), Y.read(s);\n    const o = Ze(window, \"resize\", () => this.scalePositionWithinConstraints()), a = i.addEventListener(\"didUpdate\", (({ delta: l, hasLayoutChanged: u }) => {\n      this.isDragging && u && (At((c) => {\n        const d = this.getAxisMotionValue(c);\n        d && (this.originPoint[c] += l[c].translate, d.set(d.get() + l[c].translate));\n      }), this.visualElement.render());\n    }));\n    return () => {\n      o(), n(), r(), a && a();\n    };\n  }\n  getProps() {\n    const e = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: s = !1, dragPropagation: i = !1, dragConstraints: r = !1, dragElastic: o = Fs, dragMomentum: a = !0 } = e;\n    return {\n      ...e,\n      drag: n,\n      dragDirectionLock: s,\n      dragPropagation: i,\n      dragConstraints: r,\n      dragElastic: o,\n      dragMomentum: a\n    };\n  }\n}\nfunction pn(t, e, n) {\n  return (e === !0 || e === t) && (n === null || n === t);\n}\nfunction lp(t, e = 10) {\n  let n = null;\n  return Math.abs(t.y) > e ? n = \"y\" : Math.abs(t.x) > e && (n = \"x\"), n;\n}\nclass cp extends se {\n  constructor(e) {\n    super(e), this.removeGroupControls = Mt, this.removeListeners = Mt, this.controls = new ap(e);\n  }\n  mount() {\n    const { dragControls: e } = this.node.getProps();\n    e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || Mt;\n  }\n  unmount() {\n    this.removeGroupControls(), this.removeListeners();\n  }\n}\nconst Br = (t) => (e, n) => {\n  t && Y.postRender(() => t(e, n));\n};\nclass up extends se {\n  constructor() {\n    super(...arguments), this.removePointerDownListener = Mt;\n  }\n  onPointerDown(e) {\n    this.session = new al(e, this.createPanHandlers(), {\n      transformPagePoint: this.node.getTransformPagePoint(),\n      contextWindow: ol(this.node)\n    });\n  }\n  createPanHandlers() {\n    const { onPanSessionStart: e, onPanStart: n, onPan: s, onPanEnd: i } = this.node.getProps();\n    return {\n      onSessionStart: Br(e),\n      onStart: Br(n),\n      onMove: s,\n      onEnd: (r, o) => {\n        delete this.session, i && Y.postRender(() => i(r, o));\n      }\n    };\n  }\n  mount() {\n    this.removePointerDownListener = Ue(this.node.current, \"pointerdown\", (e) => this.onPointerDown(e));\n  }\n  update() {\n    this.session && this.session.updateHandlers(this.createPanHandlers());\n  }\n  unmount() {\n    this.removePointerDownListener(), this.session && this.session.end();\n  }\n}\nconst xn = {\n  /**\n   * Global flag as to whether the tree has animated since the last time\n   * we resized the window\n   */\n  hasAnimatedSinceResize: !0,\n  /**\n   * We set this to true once, on the first update. Any nodes added to the tree beyond that\n   * update will be given a `data-projection-id` attribute.\n   */\n  hasEverUpdated: !1\n};\nlet ns = !1;\nclass dp extends kl {\n  /**\n   * This only mounts projection nodes for components that\n   * need measuring, we might want to do it for all components\n   * in order to incorporate transforms\n   */\n  componentDidMount() {\n    const { visualElement: e, layoutGroup: n, switchLayoutGroup: s, layoutId: i } = this.props, { projection: r } = e;\n    r && (n.group && n.group.add(r), s && s.register && i && s.register(r), ns && r.root.didUpdate(), r.addEventListener(\"animationComplete\", () => {\n      this.safeToRemove();\n    }), r.setOptions({\n      ...r.options,\n      onExitComplete: () => this.safeToRemove()\n    })), xn.hasEverUpdated = !0;\n  }\n  getSnapshotBeforeUpdate(e) {\n    const { layoutDependency: n, visualElement: s, drag: i, isPresent: r } = this.props, { projection: o } = s;\n    return o && (o.isPresent = r, ns = !0, i || e.layoutDependency !== n || n === void 0 || e.isPresent !== r ? o.willUpdate() : this.safeToRemove(), e.isPresent !== r && (r ? o.promote() : o.relegate() || Y.postRender(() => {\n      const a = o.getStack();\n      (!a || !a.members.length) && this.safeToRemove();\n    }))), null;\n  }\n  componentDidUpdate() {\n    const { projection: e } = this.props.visualElement;\n    e && (e.root.didUpdate(), yi.postRender(() => {\n      !e.currentAnimation && e.isLead() && this.safeToRemove();\n    }));\n  }\n  componentWillUnmount() {\n    const { visualElement: e, layoutGroup: n, switchLayoutGroup: s } = this.props, { projection: i } = e;\n    ns = !0, i && (i.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(i), s && s.deregister && s.deregister(i));\n  }\n  safeToRemove() {\n    const { safeToRemove: e } = this.props;\n    e && e();\n  }\n  render() {\n    return null;\n  }\n}\nfunction cl(t) {\n  const [e, n] = Va(), s = q(qs);\n  return p.jsx(dp, { ...t, layoutGroup: s, switchLayoutGroup: q(za), isPresent: e, safeToRemove: n });\n}\nfunction hp(t, e, n) {\n  const s = ft(t) ? t : Te(t);\n  return s.start(Ri(\"\", s, e, n)), s.animation;\n}\nconst fp = (t, e) => t.depth - e.depth;\nclass pp {\n  constructor() {\n    this.children = [], this.isDirty = !1;\n  }\n  add(e) {\n    Qs(this.children, e), this.isDirty = !0;\n  }\n  remove(e) {\n    ti(this.children, e), this.isDirty = !0;\n  }\n  forEach(e) {\n    this.isDirty && this.children.sort(fp), this.isDirty = !1, this.children.forEach(e);\n  }\n}\nfunction mp(t, e) {\n  const n = yt.now(), s = ({ timestamp: i }) => {\n    const r = i - n;\n    r >= e && (ee(s), t(r - e));\n  };\n  return Y.setup(s, !0), () => ee(s);\n}\nconst ul = [\"TopLeft\", \"TopRight\", \"BottomLeft\", \"BottomRight\"], gp = ul.length, $r = (t) => typeof t == \"string\" ? parseFloat(t) : t, _r = (t) => typeof t == \"number\" || I.test(t);\nfunction yp(t, e, n, s, i, r) {\n  i ? (t.opacity = J(0, n.opacity ?? 1, vp(s)), t.opacityExit = J(e.opacity ?? 1, 0, xp(s))) : r && (t.opacity = J(e.opacity ?? 1, n.opacity ?? 1, s));\n  for (let o = 0; o < gp; o++) {\n    const a = `border${ul[o]}Radius`;\n    let l = Ur(e, a), u = Ur(n, a);\n    if (l === void 0 && u === void 0)\n      continue;\n    l || (l = 0), u || (u = 0), l === 0 || u === 0 || _r(l) === _r(u) ? (t[a] = Math.max(J($r(l), $r(u), s), 0), (zt.test(u) || zt.test(l)) && (t[a] += \"%\")) : t[a] = u;\n  }\n  (e.rotate || n.rotate) && (t.rotate = J(e.rotate || 0, n.rotate || 0, s));\n}\nfunction Ur(t, e) {\n  return t[e] !== void 0 ? t[e] : t.borderRadius;\n}\nconst vp = /* @__PURE__ */ dl(0, 0.5, qo), xp = /* @__PURE__ */ dl(0.5, 0.95, Mt);\nfunction dl(t, e, n) {\n  return (s) => s < t ? 0 : s > e ? 1 : n(/* @__PURE__ */ Xe(t, e, s));\n}\nfunction zr(t, e) {\n  t.min = e.min, t.max = e.max;\n}\nfunction kt(t, e) {\n  zr(t.x, e.x), zr(t.y, e.y);\n}\nfunction Wr(t, e) {\n  t.translate = e.translate, t.scale = e.scale, t.originPoint = e.originPoint, t.origin = e.origin;\n}\nfunction Kr(t, e, n, s, i) {\n  return t -= e, t = Rn(t, 1 / n, s), i !== void 0 && (t = Rn(t, 1 / i, s)), t;\n}\nfunction bp(t, e = 0, n = 1, s = 0.5, i, r = t, o = t) {\n  if (zt.test(e) && (e = parseFloat(e), e = J(o.min, o.max, e / 100) - o.min), typeof e != \"number\")\n    return;\n  let a = J(r.min, r.max, s);\n  t === r && (a -= e), t.min = Kr(t.min, e, n, a, i), t.max = Kr(t.max, e, n, a, i);\n}\nfunction Gr(t, e, [n, s, i], r, o) {\n  bp(t, e[n], e[s], e[i], e.scale, r, o);\n}\nconst wp = [\"x\", \"scaleX\", \"originX\"], Tp = [\"y\", \"scaleY\", \"originY\"];\nfunction Hr(t, e, n, s) {\n  Gr(t.x, e, wp, n ? n.x : void 0, s ? s.x : void 0), Gr(t.y, e, Tp, n ? n.y : void 0, s ? s.y : void 0);\n}\nfunction Xr(t) {\n  return t.translate === 0 && t.scale === 1;\n}\nfunction hl(t) {\n  return Xr(t.x) && Xr(t.y);\n}\nfunction Yr(t, e) {\n  return t.min === e.min && t.max === e.max;\n}\nfunction Sp(t, e) {\n  return Yr(t.x, e.x) && Yr(t.y, e.y);\n}\nfunction qr(t, e) {\n  return Math.round(t.min) === Math.round(e.min) && Math.round(t.max) === Math.round(e.max);\n}\nfunction fl(t, e) {\n  return qr(t.x, e.x) && qr(t.y, e.y);\n}\nfunction Jr(t) {\n  return gt(t.x) / gt(t.y);\n}\nfunction Zr(t, e) {\n  return t.translate === e.translate && t.scale === e.scale && t.originPoint === e.originPoint;\n}\nclass Dp {\n  constructor() {\n    this.members = [];\n  }\n  add(e) {\n    Qs(this.members, e), e.scheduleRender();\n  }\n  remove(e) {\n    if (ti(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) {\n      const n = this.members[this.members.length - 1];\n      n && this.promote(n);\n    }\n  }\n  relegate(e) {\n    const n = this.members.findIndex((i) => e === i);\n    if (n === 0)\n      return !1;\n    let s;\n    for (let i = n; i >= 0; i--) {\n      const r = this.members[i];\n      if (r.isPresent !== !1) {\n        s = r;\n        break;\n      }\n    }\n    return s ? (this.promote(s), !0) : !1;\n  }\n  promote(e, n) {\n    const s = this.lead;\n    if (e !== s && (this.prevLead = s, this.lead = e, e.show(), s)) {\n      s.instance && s.scheduleRender(), e.scheduleRender(), e.resumeFrom = s, n && (e.resumeFrom.preserveOpacity = !0), s.snapshot && (e.snapshot = s.snapshot, e.snapshot.latestValues = s.animationValues || s.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0);\n      const { crossfade: i } = e.options;\n      i === !1 && s.hide();\n    }\n  }\n  exitAnimationComplete() {\n    this.members.forEach((e) => {\n      const { options: n, resumingFrom: s } = e;\n      n.onExitComplete && n.onExitComplete(), s && s.options.onExitComplete && s.options.onExitComplete();\n    });\n  }\n  scheduleRender() {\n    this.members.forEach((e) => {\n      e.instance && e.scheduleRender(!1);\n    });\n  }\n  /**\n   * Clear any leads that have been removed this render to prevent them from being\n   * used in future animations and to prevent memory leaks\n   */\n  removeLeadSnapshot() {\n    this.lead && this.lead.snapshot && (this.lead.snapshot = void 0);\n  }\n}\nfunction Cp(t, e, n) {\n  let s = \"\";\n  const i = t.x.translate / e.x, r = t.y.translate / e.y, o = n?.z || 0;\n  if ((i || r || o) && (s = `translate3d(${i}px, ${r}px, ${o}px) `), (e.x !== 1 || e.y !== 1) && (s += `scale(${1 / e.x}, ${1 / e.y}) `), n) {\n    const { transformPerspective: u, rotate: c, rotateX: d, rotateY: h, skewX: f, skewY: g } = n;\n    u && (s = `perspective(${u}px) ${s}`), c && (s += `rotate(${c}deg) `), d && (s += `rotateX(${d}deg) `), h && (s += `rotateY(${h}deg) `), f && (s += `skewX(${f}deg) `), g && (s += `skewY(${g}deg) `);\n  }\n  const a = t.x.scale * e.x, l = t.y.scale * e.y;\n  return (a !== 1 || l !== 1) && (s += `scale(${a}, ${l})`), s || \"none\";\n}\nconst ss = [\"\", \"X\", \"Y\", \"Z\"], Ap = 1e3;\nlet Pp = 0;\nfunction is(t, e, n, s) {\n  const { latestValues: i } = e;\n  i[t] && (n[t] = i[t], e.setStaticValue(t, 0), s && (s[t] = 0));\n}\nfunction pl(t) {\n  if (t.hasCheckedOptimisedAppear = !0, t.root === t)\n    return;\n  const { visualElement: e } = t.options;\n  if (!e)\n    return;\n  const n = Qa(e);\n  if (window.MotionHasOptimisedAnimation(n, \"transform\")) {\n    const { layout: i, layoutId: r } = t.options;\n    window.MotionCancelOptimisedAnimation(n, \"transform\", Y, !(i || r));\n  }\n  const { parent: s } = t;\n  s && !s.hasCheckedOptimisedAppear && pl(s);\n}\nfunction ml({ attachResizeListener: t, defaultParent: e, measureScroll: n, checkIsScrollRoot: s, resetTransform: i }) {\n  return class {\n    constructor(o = {}, a = e?.()) {\n      this.id = Pp++, this.animationId = 0, this.animationCommitId = 0, this.children = /* @__PURE__ */ new Set(), this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = /* @__PURE__ */ new Map(), this.hasTreeAnimated = !1, this.layoutVersion = 0, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {\n        this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots());\n      }, this.updateProjection = () => {\n        this.projectionUpdateScheduled = !1, this.nodes.forEach(Ep), this.nodes.forEach(Ip), this.nodes.forEach(jp), this.nodes.forEach(Vp);\n      }, this.resolvedRelativeTargetAt = 0, this.linkedParentVersion = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = /* @__PURE__ */ new Map(), this.latestValues = o, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0;\n      for (let l = 0; l < this.path.length; l++)\n        this.path[l].shouldResetTransform = !0;\n      this.root === this && (this.nodes = new pp());\n    }\n    addEventListener(o, a) {\n      return this.eventHandlers.has(o) || this.eventHandlers.set(o, new si()), this.eventHandlers.get(o).add(a);\n    }\n    notifyListeners(o, ...a) {\n      const l = this.eventHandlers.get(o);\n      l && l.notify(...a);\n    }\n    hasListeners(o) {\n      return this.eventHandlers.has(o);\n    }\n    /**\n     * Lifecycles\n     */\n    mount(o) {\n      if (this.instance)\n        return;\n      this.isSVG = Ea(o) && !yh(o), this.instance = o;\n      const { layoutId: a, layout: l, visualElement: u } = this.options;\n      if (u && !u.current && u.mount(o), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (l || a) && (this.isLayoutDirty = !0), t) {\n        let c, d = 0;\n        const h = () => this.root.updateBlockedByResize = !1;\n        Y.read(() => {\n          d = window.innerWidth;\n        }), t(o, () => {\n          const f = window.innerWidth;\n          f !== d && (d = f, this.root.updateBlockedByResize = !0, c && c(), c = mp(h, 250), xn.hasAnimatedSinceResize && (xn.hasAnimatedSinceResize = !1, this.nodes.forEach(eo)));\n        });\n      }\n      a && this.root.registerSharedNode(a, this), this.options.animate !== !1 && u && (a || l) && this.addEventListener(\"didUpdate\", ({ delta: c, hasLayoutChanged: d, hasRelativeLayoutChanged: h, layout: f }) => {\n        if (this.isTreeAnimationBlocked()) {\n          this.target = void 0, this.relativeTarget = void 0;\n          return;\n        }\n        const g = this.options.transition || u.getDefaultTransition() || $p, { onLayoutAnimationStart: v, onLayoutAnimationComplete: y } = u.getProps(), x = !this.targetLayout || !fl(this.targetLayout, f), T = !d && h;\n        if (this.options.layoutRoot || this.resumeFrom || T || d && (x || !this.currentAnimation)) {\n          this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0);\n          const b = {\n            ...mi(g, \"layout\"),\n            onPlay: v,\n            onComplete: y\n          };\n          (u.shouldReduceMotion || this.options.layoutRoot) && (b.delay = 0, b.type = !1), this.startAnimation(b), this.setAnimationOrigin(c, T);\n        } else\n          d || eo(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();\n        this.targetLayout = f;\n      });\n    }\n    unmount() {\n      this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);\n      const o = this.getStack();\n      o && o.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), ee(this.updateProjection);\n    }\n    // only on the root\n    blockUpdate() {\n      this.updateManuallyBlocked = !0;\n    }\n    unblockUpdate() {\n      this.updateManuallyBlocked = !1;\n    }\n    isUpdateBlocked() {\n      return this.updateManuallyBlocked || this.updateBlockedByResize;\n    }\n    isTreeAnimationBlocked() {\n      return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1;\n    }\n    // Note: currently only running on root node\n    startUpdate() {\n      this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(Lp), this.animationId++);\n    }\n    getTransformTemplate() {\n      const { visualElement: o } = this.options;\n      return o && o.getProps().transformTemplate;\n    }\n    willUpdate(o = !0) {\n      if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {\n        this.options.onExitComplete && this.options.onExitComplete();\n        return;\n      }\n      if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && pl(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty)\n        return;\n      this.isLayoutDirty = !0;\n      for (let c = 0; c < this.path.length; c++) {\n        const d = this.path[c];\n        d.shouldResetTransform = !0, d.updateScroll(\"snapshot\"), d.options.layoutRoot && d.willUpdate(!1);\n      }\n      const { layoutId: a, layout: l } = this.options;\n      if (a === void 0 && !l)\n        return;\n      const u = this.getTransformTemplate();\n      this.prevTransformTemplateValue = u ? u(this.latestValues, \"\") : void 0, this.updateSnapshot(), o && this.notifyListeners(\"willUpdate\");\n    }\n    update() {\n      if (this.updateScheduled = !1, this.isUpdateBlocked()) {\n        this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(Qr);\n        return;\n      }\n      if (this.animationId <= this.animationCommitId) {\n        this.nodes.forEach(to);\n        return;\n      }\n      this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(kp), this.nodes.forEach(Rp), this.nodes.forEach(Mp)) : this.nodes.forEach(to), this.clearAllSnapshots();\n      const a = yt.now();\n      ut.delta = Gt(0, 1e3 / 60, a - ut.timestamp), ut.timestamp = a, ut.isProcessing = !0, Gn.update.process(ut), Gn.preRender.process(ut), Gn.render.process(ut), ut.isProcessing = !1;\n    }\n    didUpdate() {\n      this.updateScheduled || (this.updateScheduled = !0, yi.read(this.scheduleUpdate));\n    }\n    clearAllSnapshots() {\n      this.nodes.forEach(Np), this.sharedNodes.forEach(Op);\n    }\n    scheduleUpdateProjection() {\n      this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Y.preRender(this.updateProjection, !1, !0));\n    }\n    scheduleCheckAfterUnmount() {\n      Y.postRender(() => {\n        this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed();\n      });\n    }\n    /**\n     * Update measurements\n     */\n    updateSnapshot() {\n      this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !gt(this.snapshot.measuredBox.x) && !gt(this.snapshot.measuredBox.y) && (this.snapshot = void 0));\n    }\n    updateLayout() {\n      if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty))\n        return;\n      if (this.resumeFrom && !this.resumeFrom.instance)\n        for (let l = 0; l < this.path.length; l++)\n          this.path[l].updateScroll();\n      const o = this.layout;\n      this.layout = this.measure(!1), this.layoutVersion++, this.layoutCorrected = st(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners(\"measure\", this.layout.layoutBox);\n      const { visualElement: a } = this.options;\n      a && a.notify(\"LayoutMeasure\", this.layout.layoutBox, o ? o.layoutBox : void 0);\n    }\n    updateScroll(o = \"measure\") {\n      let a = !!(this.options.layoutScroll && this.instance);\n      if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1), a && this.instance) {\n        const l = s(this.instance);\n        this.scroll = {\n          animationId: this.root.animationId,\n          phase: o,\n          isRoot: l,\n          offset: n(this.instance),\n          wasRoot: this.scroll ? this.scroll.isRoot : l\n        };\n      }\n    }\n    resetTransform() {\n      if (!i)\n        return;\n      const o = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, a = this.projectionDelta && !hl(this.projectionDelta), l = this.getTransformTemplate(), u = l ? l(this.latestValues, \"\") : void 0, c = u !== this.prevTransformTemplateValue;\n      o && this.instance && (a || ae(this.latestValues) || c) && (i(this.instance, u), this.shouldResetTransform = !1, this.scheduleRender());\n    }\n    measure(o = !0) {\n      const a = this.measurePageBox();\n      let l = this.removeElementScroll(a);\n      return o && (l = this.removeTransform(l)), _p(l), {\n        animationId: this.root.animationId,\n        measuredBox: a,\n        layoutBox: l,\n        latestValues: {},\n        source: this.id\n      };\n    }\n    measurePageBox() {\n      const { visualElement: o } = this.options;\n      if (!o)\n        return st();\n      const a = o.measureViewportBox();\n      if (!(this.scroll?.wasRoot || this.path.some(Up))) {\n        const { scroll: u } = this.root;\n        u && (ye(a.x, u.offset.x), ye(a.y, u.offset.y));\n      }\n      return a;\n    }\n    removeElementScroll(o) {\n      const a = st();\n      if (kt(a, o), this.scroll?.wasRoot)\n        return a;\n      for (let l = 0; l < this.path.length; l++) {\n        const u = this.path[l], { scroll: c, options: d } = u;\n        u !== this.root && c && d.layoutScroll && (c.wasRoot && kt(a, o), ye(a.x, c.offset.x), ye(a.y, c.offset.y));\n      }\n      return a;\n    }\n    applyTransform(o, a = !1) {\n      const l = st();\n      kt(l, o);\n      for (let u = 0; u < this.path.length; u++) {\n        const c = this.path[u];\n        !a && c.options.layoutScroll && c.scroll && c !== c.root && ve(l, {\n          x: -c.scroll.offset.x,\n          y: -c.scroll.offset.y\n        }), ae(c.latestValues) && ve(l, c.latestValues);\n      }\n      return ae(this.latestValues) && ve(l, this.latestValues), l;\n    }\n    removeTransform(o) {\n      const a = st();\n      kt(a, o);\n      for (let l = 0; l < this.path.length; l++) {\n        const u = this.path[l];\n        if (!u.instance || !ae(u.latestValues))\n          continue;\n        Ns(u.latestValues) && u.updateSnapshot();\n        const c = st(), d = u.measurePageBox();\n        kt(c, d), Hr(a, u.latestValues, u.snapshot ? u.snapshot.layoutBox : void 0, c);\n      }\n      return ae(this.latestValues) && Hr(a, this.latestValues), a;\n    }\n    setTargetDelta(o) {\n      this.targetDelta = o, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0;\n    }\n    setOptions(o) {\n      this.options = {\n        ...this.options,\n        ...o,\n        crossfade: o.crossfade !== void 0 ? o.crossfade : !0\n      };\n    }\n    clearMeasurements() {\n      this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1;\n    }\n    forceRelativeParentToResolveTarget() {\n      this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== ut.timestamp && this.relativeParent.resolveTargetDelta(!0);\n    }\n    resolveTargetDelta(o = !1) {\n      const a = this.getLead();\n      this.isProjectionDirty || (this.isProjectionDirty = a.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = a.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = a.isSharedProjectionDirty);\n      const l = !!this.resumingFrom || this !== a;\n      if (!(o || l && this.isSharedProjectionDirty || this.isProjectionDirty || this.parent?.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize))\n        return;\n      const { layout: c, layoutId: d } = this.options;\n      if (!this.layout || !(c || d))\n        return;\n      this.resolvedRelativeTargetAt = ut.timestamp;\n      const h = this.getClosestProjectingParent();\n      h && this.linkedParentVersion !== h.layoutVersion && !h.options.layoutRoot && this.removeRelativeTarget(), !this.targetDelta && !this.relativeTarget && (h && h.layout ? this.createRelativeTarget(h, this.layout.layoutBox, h.layout.layoutBox) : this.removeRelativeTarget()), !(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = st(), this.targetWithTransforms = st()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), qf(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : kt(this.target, this.layout.layoutBox), Ha(this.target, this.targetDelta)) : kt(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget && (this.attemptToResolveRelativeTarget = !1, h && !!h.resumingFrom == !!this.resumingFrom && !h.options.layoutScroll && h.target && this.animationProgress !== 1 ? this.createRelativeTarget(h, this.target, h.target) : this.relativeParent = this.relativeTarget = void 0));\n    }\n    getClosestProjectingParent() {\n      if (!(!this.parent || Ns(this.parent.latestValues) || Ga(this.parent.latestValues)))\n        return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent();\n    }\n    isProjecting() {\n      return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout);\n    }\n    createRelativeTarget(o, a, l) {\n      this.relativeParent = o, this.linkedParentVersion = o.layoutVersion, this.forceRelativeParentToResolveTarget(), this.relativeTarget = st(), this.relativeTargetOrigin = st(), Mn(this.relativeTargetOrigin, a, l), kt(this.relativeTarget, this.relativeTargetOrigin);\n    }\n    removeRelativeTarget() {\n      this.relativeParent = this.relativeTarget = void 0;\n    }\n    calcProjection() {\n      const o = this.getLead(), a = !!this.resumingFrom || this !== o;\n      let l = !0;\n      if ((this.isProjectionDirty || this.parent?.isProjectionDirty) && (l = !1), a && (this.isSharedProjectionDirty || this.isTransformDirty) && (l = !1), this.resolvedRelativeTargetAt === ut.timestamp && (l = !1), l)\n        return;\n      const { layout: u, layoutId: c } = this.options;\n      if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(u || c))\n        return;\n      kt(this.layoutCorrected, this.layout.layoutBox);\n      const d = this.treeScale.x, h = this.treeScale.y;\n      lf(this.layoutCorrected, this.treeScale, this.path, a), o.layout && !o.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (o.target = o.layout.layoutBox, o.targetWithTransforms = st());\n      const { target: f } = o;\n      if (!f) {\n        this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());\n        return;\n      }\n      !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (Wr(this.prevProjectionDelta.x, this.projectionDelta.x), Wr(this.prevProjectionDelta.y, this.projectionDelta.y)), ze(this.projectionDelta, this.layoutCorrected, f, this.latestValues), (this.treeScale.x !== d || this.treeScale.y !== h || !Zr(this.projectionDelta.x, this.prevProjectionDelta.x) || !Zr(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners(\"projectionUpdate\", f));\n    }\n    hide() {\n      this.isVisible = !1;\n    }\n    show() {\n      this.isVisible = !0;\n    }\n    scheduleRender(o = !0) {\n      if (this.options.visualElement?.scheduleRender(), o) {\n        const a = this.getStack();\n        a && a.scheduleRender();\n      }\n      this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0);\n    }\n    createProjectionDeltas() {\n      this.prevProjectionDelta = xe(), this.projectionDelta = xe(), this.projectionDeltaWithTransform = xe();\n    }\n    setAnimationOrigin(o, a = !1) {\n      const l = this.snapshot, u = l ? l.latestValues : {}, c = { ...this.latestValues }, d = xe();\n      (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;\n      const h = st(), f = l ? l.source : void 0, g = this.layout ? this.layout.source : void 0, v = f !== g, y = this.getStack(), x = !y || y.members.length <= 1, T = !!(v && !x && this.options.crossfade === !0 && !this.path.some(Bp));\n      this.animationProgress = 0;\n      let b;\n      this.mixTargetDelta = (P) => {\n        const D = P / 1e3;\n        no(d.x, o.x, D), no(d.y, o.y, D), this.setTargetDelta(d), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (Mn(h, this.layout.layoutBox, this.relativeParent.layout.layoutBox), Fp(this.relativeTarget, this.relativeTargetOrigin, h, D), b && Sp(this.relativeTarget, b) && (this.isProjectionDirty = !1), b || (b = st()), kt(b, this.relativeTarget)), v && (this.animationValues = c, yp(c, u, this.latestValues, D, T, x)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = D;\n      }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0);\n    }\n    startAnimation(o) {\n      this.notifyListeners(\"animationStart\"), this.currentAnimation?.stop(), this.resumingFrom?.currentAnimation?.stop(), this.pendingAnimation && (ee(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Y.update(() => {\n        xn.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = Te(0)), this.currentAnimation = hp(this.motionValue, [0, 1e3], {\n          ...o,\n          velocity: 0,\n          isSync: !0,\n          onUpdate: (a) => {\n            this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a);\n          },\n          onStop: () => {\n          },\n          onComplete: () => {\n            o.onComplete && o.onComplete(), this.completeAnimation();\n          }\n        }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0;\n      });\n    }\n    completeAnimation() {\n      this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);\n      const o = this.getStack();\n      o && o.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners(\"animationComplete\");\n    }\n    finishAnimation() {\n      this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(Ap), this.currentAnimation.stop()), this.completeAnimation();\n    }\n    applyTransformsToTarget() {\n      const o = this.getLead();\n      let { targetWithTransforms: a, target: l, layout: u, latestValues: c } = o;\n      if (!(!a || !l || !u)) {\n        if (this !== o && this.layout && u && gl(this.options.animationType, this.layout.layoutBox, u.layoutBox)) {\n          l = this.target || st();\n          const d = gt(this.layout.layoutBox.x);\n          l.x.min = o.target.x.min, l.x.max = l.x.min + d;\n          const h = gt(this.layout.layoutBox.y);\n          l.y.min = o.target.y.min, l.y.max = l.y.min + h;\n        }\n        kt(a, l), ve(a, c), ze(this.projectionDeltaWithTransform, this.layoutCorrected, a, c);\n      }\n    }\n    registerSharedNode(o, a) {\n      this.sharedNodes.has(o) || this.sharedNodes.set(o, new Dp()), this.sharedNodes.get(o).add(a);\n      const u = a.options.initialPromotionConfig;\n      a.promote({\n        transition: u ? u.transition : void 0,\n        preserveFollowOpacity: u && u.shouldPreserveFollowOpacity ? u.shouldPreserveFollowOpacity(a) : void 0\n      });\n    }\n    isLead() {\n      const o = this.getStack();\n      return o ? o.lead === this : !0;\n    }\n    getLead() {\n      const { layoutId: o } = this.options;\n      return o ? this.getStack()?.lead || this : this;\n    }\n    getPrevLead() {\n      const { layoutId: o } = this.options;\n      return o ? this.getStack()?.prevLead : void 0;\n    }\n    getStack() {\n      const { layoutId: o } = this.options;\n      if (o)\n        return this.root.sharedNodes.get(o);\n    }\n    promote({ needsReset: o, transition: a, preserveFollowOpacity: l } = {}) {\n      const u = this.getStack();\n      u && u.promote(this, l), o && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a });\n    }\n    relegate() {\n      const o = this.getStack();\n      return o ? o.relegate(this) : !1;\n    }\n    resetSkewAndRotation() {\n      const { visualElement: o } = this.options;\n      if (!o)\n        return;\n      let a = !1;\n      const { latestValues: l } = o;\n      if ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = !0), !a)\n        return;\n      const u = {};\n      l.z && is(\"z\", o, u, this.animationValues);\n      for (let c = 0; c < ss.length; c++)\n        is(`rotate${ss[c]}`, o, u, this.animationValues), is(`skew${ss[c]}`, o, u, this.animationValues);\n      o.render();\n      for (const c in u)\n        o.setStaticValue(c, u[c]), this.animationValues && (this.animationValues[c] = u[c]);\n      o.scheduleRender();\n    }\n    applyProjectionStyles(o, a) {\n      if (!this.instance || this.isSVG)\n        return;\n      if (!this.isVisible) {\n        o.visibility = \"hidden\";\n        return;\n      }\n      const l = this.getTransformTemplate();\n      if (this.needsReset) {\n        this.needsReset = !1, o.visibility = \"\", o.opacity = \"\", o.pointerEvents = vn(a?.pointerEvents) || \"\", o.transform = l ? l(this.latestValues, \"\") : \"none\";\n        return;\n      }\n      const u = this.getLead();\n      if (!this.projectionDelta || !this.layout || !u.target) {\n        this.options.layoutId && (o.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, o.pointerEvents = vn(a?.pointerEvents) || \"\"), this.hasProjected && !ae(this.latestValues) && (o.transform = l ? l({}, \"\") : \"none\", this.hasProjected = !1);\n        return;\n      }\n      o.visibility = \"\";\n      const c = u.animationValues || u.latestValues;\n      this.applyTransformsToTarget();\n      let d = Cp(this.projectionDeltaWithTransform, this.treeScale, c);\n      l && (d = l(c, d)), o.transform = d;\n      const { x: h, y: f } = this.projectionDelta;\n      o.transformOrigin = `${h.origin * 100}% ${f.origin * 100}% 0`, u.animationValues ? o.opacity = u === this ? c.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : c.opacityExit : o.opacity = u === this ? c.opacity !== void 0 ? c.opacity : \"\" : c.opacityExit !== void 0 ? c.opacityExit : 0;\n      for (const g in Vs) {\n        if (c[g] === void 0)\n          continue;\n        const { correct: v, applyTo: y, isCSSVariable: x } = Vs[g], T = d === \"none\" ? c[g] : v(c[g], u);\n        if (y) {\n          const b = y.length;\n          for (let P = 0; P < b; P++)\n            o[y[P]] = T;\n        } else\n          x ? this.options.visualElement.renderState.vars[g] = T : o[g] = T;\n      }\n      this.options.layoutId && (o.pointerEvents = u === this ? vn(a?.pointerEvents) || \"\" : \"none\");\n    }\n    clearSnapshot() {\n      this.resumeFrom = this.snapshot = void 0;\n    }\n    // Only run on root\n    resetTree() {\n      this.root.nodes.forEach((o) => o.currentAnimation?.stop()), this.root.nodes.forEach(Qr), this.root.sharedNodes.clear();\n    }\n  };\n}\nfunction Rp(t) {\n  t.updateLayout();\n}\nfunction Mp(t) {\n  const e = t.resumeFrom?.snapshot || t.snapshot;\n  if (t.isLead() && t.layout && e && t.hasListeners(\"didUpdate\")) {\n    const { layoutBox: n, measuredBox: s } = t.layout, { animationType: i } = t.options, r = e.source !== t.layout.source;\n    i === \"size\" ? At((c) => {\n      const d = r ? e.measuredBox[c] : e.layoutBox[c], h = gt(d);\n      d.min = n[c].min, d.max = d.min + h;\n    }) : gl(i, e.layoutBox, n) && At((c) => {\n      const d = r ? e.measuredBox[c] : e.layoutBox[c], h = gt(n[c]);\n      d.max = d.min + h, t.relativeTarget && !t.currentAnimation && (t.isProjectionDirty = !0, t.relativeTarget[c].max = t.relativeTarget[c].min + h);\n    });\n    const o = xe();\n    ze(o, n, e.layoutBox);\n    const a = xe();\n    r ? ze(a, t.applyTransform(s, !0), e.measuredBox) : ze(a, n, e.layoutBox);\n    const l = !hl(o);\n    let u = !1;\n    if (!t.resumeFrom) {\n      const c = t.getClosestProjectingParent();\n      if (c && !c.resumeFrom) {\n        const { snapshot: d, layout: h } = c;\n        if (d && h) {\n          const f = st();\n          Mn(f, e.layoutBox, d.layoutBox);\n          const g = st();\n          Mn(g, n, h.layoutBox), fl(f, g) || (u = !0), c.options.layoutRoot && (t.relativeTarget = g, t.relativeTargetOrigin = f, t.relativeParent = c);\n        }\n      }\n    }\n    t.notifyListeners(\"didUpdate\", {\n      layout: n,\n      snapshot: e,\n      delta: a,\n      layoutDelta: o,\n      hasLayoutChanged: l,\n      hasRelativeLayoutChanged: u\n    });\n  } else if (t.isLead()) {\n    const { onExitComplete: n } = t.options;\n    n && n();\n  }\n  t.options.transition = void 0;\n}\nfunction Ep(t) {\n  t.parent && (t.isProjecting() || (t.isProjectionDirty = t.parent.isProjectionDirty), t.isSharedProjectionDirty || (t.isSharedProjectionDirty = !!(t.isProjectionDirty || t.parent.isProjectionDirty || t.parent.isSharedProjectionDirty)), t.isTransformDirty || (t.isTransformDirty = t.parent.isTransformDirty));\n}\nfunction Vp(t) {\n  t.isProjectionDirty = t.isSharedProjectionDirty = t.isTransformDirty = !1;\n}\nfunction Np(t) {\n  t.clearSnapshot();\n}\nfunction Qr(t) {\n  t.clearMeasurements();\n}\nfunction to(t) {\n  t.isLayoutDirty = !1;\n}\nfunction kp(t) {\n  const { visualElement: e } = t.options;\n  e && e.getProps().onBeforeLayoutMeasure && e.notify(\"BeforeLayoutMeasure\"), t.resetTransform();\n}\nfunction eo(t) {\n  t.finishAnimation(), t.targetDelta = t.relativeTarget = t.target = void 0, t.isProjectionDirty = !0;\n}\nfunction Ip(t) {\n  t.resolveTargetDelta();\n}\nfunction jp(t) {\n  t.calcProjection();\n}\nfunction Lp(t) {\n  t.resetSkewAndRotation();\n}\nfunction Op(t) {\n  t.removeLeadSnapshot();\n}\nfunction no(t, e, n) {\n  t.translate = J(e.translate, 0, n), t.scale = J(e.scale, 1, n), t.origin = e.origin, t.originPoint = e.originPoint;\n}\nfunction so(t, e, n, s) {\n  t.min = J(e.min, n.min, s), t.max = J(e.max, n.max, s);\n}\nfunction Fp(t, e, n, s) {\n  so(t.x, e.x, n.x, s), so(t.y, e.y, n.y, s);\n}\nfunction Bp(t) {\n  return t.animationValues && t.animationValues.opacityExit !== void 0;\n}\nconst $p = {\n  duration: 0.45,\n  ease: [0.4, 0, 0.1, 1]\n}, io = (t) => typeof navigator < \"u\" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(t), ro = io(\"applewebkit/\") && !io(\"chrome/\") ? Math.round : Mt;\nfunction oo(t) {\n  t.min = ro(t.min), t.max = ro(t.max);\n}\nfunction _p(t) {\n  oo(t.x), oo(t.y);\n}\nfunction gl(t, e, n) {\n  return t === \"position\" || t === \"preserve-aspect\" && !Yf(Jr(e), Jr(n), 0.2);\n}\nfunction Up(t) {\n  return t !== t.root && t.scroll?.wasRoot;\n}\nconst zp = ml({\n  attachResizeListener: (t, e) => Ze(t, \"resize\", e),\n  measureScroll: () => ({\n    x: document.documentElement.scrollLeft || document.body.scrollLeft,\n    y: document.documentElement.scrollTop || document.body.scrollTop\n  }),\n  checkIsScrollRoot: () => !0\n}), rs = {\n  current: void 0\n}, yl = ml({\n  measureScroll: (t) => ({\n    x: t.scrollLeft,\n    y: t.scrollTop\n  }),\n  defaultParent: () => {\n    if (!rs.current) {\n      const t = new zp({});\n      t.mount(window), t.setOptions({ layoutScroll: !0 }), rs.current = t;\n    }\n    return rs.current;\n  },\n  resetTransform: (t, e) => {\n    t.style.transform = e !== void 0 ? e : \"none\";\n  },\n  checkIsScrollRoot: (t) => window.getComputedStyle(t).position === \"fixed\"\n}), Wp = {\n  pan: {\n    Feature: up\n  },\n  drag: {\n    Feature: cp,\n    ProjectionNode: yl,\n    MeasureLayout: cl\n  }\n};\nfunction ao(t, e, n) {\n  const { props: s } = t;\n  t.animationState && s.whileHover && t.animationState.setActive(\"whileHover\", n === \"Start\");\n  const i = \"onHover\" + n, r = s[i];\n  r && Y.postRender(() => r(e, on(e)));\n}\nclass Kp extends se {\n  mount() {\n    const { current: e } = this.node;\n    e && (this.unmount = hh(e, (n, s) => (ao(this.node, s, \"Start\"), (i) => ao(this.node, i, \"End\"))));\n  }\n  unmount() {\n  }\n}\nclass Gp extends se {\n  constructor() {\n    super(...arguments), this.isActive = !1;\n  }\n  onFocus() {\n    let e = !1;\n    try {\n      e = this.node.current.matches(\":focus-visible\");\n    } catch {\n      e = !0;\n    }\n    !e || !this.node.animationState || (this.node.animationState.setActive(\"whileFocus\", !0), this.isActive = !0);\n  }\n  onBlur() {\n    !this.isActive || !this.node.animationState || (this.node.animationState.setActive(\"whileFocus\", !1), this.isActive = !1);\n  }\n  mount() {\n    this.unmount = nn(Ze(this.node.current, \"focus\", () => this.onFocus()), Ze(this.node.current, \"blur\", () => this.onBlur()));\n  }\n  unmount() {\n  }\n}\nfunction lo(t, e, n) {\n  const { props: s } = t;\n  if (t.current instanceof HTMLButtonElement && t.current.disabled)\n    return;\n  t.animationState && s.whileTap && t.animationState.setActive(\"whileTap\", n === \"Start\");\n  const i = \"onTap\" + (n === \"End\" ? \"\" : n), r = s[i];\n  r && Y.postRender(() => r(e, on(e)));\n}\nclass Hp extends se {\n  mount() {\n    const { current: e } = this.node;\n    e && (this.unmount = gh(e, (n, s) => (lo(this.node, s, \"Start\"), (i, { success: r }) => lo(this.node, i, r ? \"End\" : \"Cancel\")), { useGlobalTarget: this.node.props.globalTapTarget }));\n  }\n  unmount() {\n  }\n}\nconst Bs = /* @__PURE__ */ new WeakMap(), os = /* @__PURE__ */ new WeakMap(), Xp = (t) => {\n  const e = Bs.get(t.target);\n  e && e(t);\n}, Yp = (t) => {\n  t.forEach(Xp);\n};\nfunction qp({ root: t, ...e }) {\n  const n = t || document;\n  os.has(n) || os.set(n, {});\n  const s = os.get(n), i = JSON.stringify(e);\n  return s[i] || (s[i] = new IntersectionObserver(Yp, { root: t, ...e })), s[i];\n}\nfunction Jp(t, e, n) {\n  const s = qp(e);\n  return Bs.set(t, n), s.observe(t), () => {\n    Bs.delete(t), s.unobserve(t);\n  };\n}\nconst Zp = {\n  some: 0,\n  all: 1\n};\nclass Qp extends se {\n  constructor() {\n    super(...arguments), this.hasEnteredView = !1, this.isInView = !1;\n  }\n  startObserver() {\n    this.unmount();\n    const { viewport: e = {} } = this.node.getProps(), { root: n, margin: s, amount: i = \"some\", once: r } = e, o = {\n      root: n ? n.current : void 0,\n      rootMargin: s,\n      threshold: typeof i == \"number\" ? i : Zp[i]\n    }, a = (l) => {\n      const { isIntersecting: u } = l;\n      if (this.isInView === u || (this.isInView = u, r && !u && this.hasEnteredView))\n        return;\n      u && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive(\"whileInView\", u);\n      const { onViewportEnter: c, onViewportLeave: d } = this.node.getProps(), h = u ? c : d;\n      h && h(l);\n    };\n    return Jp(this.node.current, o, a);\n  }\n  mount() {\n    this.startObserver();\n  }\n  update() {\n    if (typeof IntersectionObserver > \"u\")\n      return;\n    const { props: e, prevProps: n } = this.node;\n    [\"amount\", \"margin\", \"root\"].some(tm(e, n)) && this.startObserver();\n  }\n  unmount() {\n  }\n}\nfunction tm({ viewport: t = {} }, { viewport: e = {} } = {}) {\n  return (n) => t[n] !== e[n];\n}\nconst em = {\n  inView: {\n    Feature: Qp\n  },\n  tap: {\n    Feature: Hp\n  },\n  focus: {\n    Feature: Gp\n  },\n  hover: {\n    Feature: Kp\n  }\n}, nm = {\n  layout: {\n    ProjectionNode: yl,\n    MeasureLayout: cl\n  }\n}, sm = {\n  ...zf,\n  ...em,\n  ...Wp,\n  ...nm\n}, as = /* @__PURE__ */ rf(sm, vf);\nclass im {\n  // 不再需要 getClient，因為現在通過後端 API 調用\n  async searchPlaces(e, n, s) {\n    try {\n      const i = await fetch(\"/api/itinerary/search-places\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        credentials: \"include\",\n        body: JSON.stringify({ query: e, latitude: n, longitude: s })\n      });\n      if (!i.ok) {\n        const o = await i.json();\n        throw new Error(o.error || \"Failed to search places\");\n      }\n      return (await i.json()).data || [];\n    } catch (i) {\n      return console.error(\"Gemini Search Error:\", i), [];\n    }\n  }\n  async optimizeDayPlan(e) {\n    try {\n      const n = await fetch(\"/api/itinerary/optimize-day-plan\", {\n        method: \"POST\",\n        headers: { \"Content-Type\": \"application/json\" },\n        credentials: \"include\",\n        body: JSON.stringify({ places: e })\n      });\n      if (!n.ok) {\n        const i = await n.json();\n        throw new Error(i.error || \"Failed to optimize day plan\");\n      }\n      return (await n.json()).data || null;\n    } catch (n) {\n      return console.error(\"Gemini Optimization Error:\", n), null;\n    }\n  }\n}\nlet ls = null;\nconst rm = () => (ls || (ls = new im()), ls), co = new Proxy({}, {\n  get(t, e) {\n    return rm()[e];\n  }\n});\nclass om {\n  constructor(e = \"/api\") {\n    this.baseURL = e, this.defaultHeaders = {\n      \"Content-Type\": \"application/json\"\n    };\n  }\n  /**\n   * 設定認證 token\n   */\n  setAuthToken(e) {\n    if (e)\n      this.defaultHeaders = {\n        ...this.defaultHeaders,\n        Authorization: `Bearer ${e}`\n      };\n    else {\n      const { Authorization: n, ...s } = this.defaultHeaders;\n      this.defaultHeaders = s;\n    }\n  }\n  /**\n   * 從 cookie 或 localStorage 獲取 session\n   */\n  getSessionToken() {\n    const e = document.cookie.split(\";\");\n    for (const n of e) {\n      const [s, i] = n.trim().split(\"=\");\n      if (s === \"session_id\" || s === \"session\")\n        return i;\n    }\n    return localStorage.getItem(\"session_token\");\n  }\n  /**\n   * 建立完整的請求 URL\n   */\n  buildURL(e) {\n    if (e.startsWith(\"http://\") || e.startsWith(\"https://\"))\n      return e;\n    const n = e.startsWith(\"/\") ? e.slice(1) : e;\n    return `${this.baseURL}/${n}`;\n  }\n  /**\n   * 處理 API 回應\n   */\n  async handleResponse(e) {\n    const n = e.headers.get(\"content-type\"), s = n && n.includes(\"application/json\");\n    let i;\n    try {\n      i = s ? await e.json() : await e.text();\n    } catch {\n      return {\n        success: !1,\n        error: \"Failed to parse response\"\n      };\n    }\n    return e.ok ? {\n      success: !0,\n      data: i.data !== void 0 ? i.data : i,\n      message: i.message\n    } : {\n      success: !1,\n      error: i.error || i.message || `HTTP ${e.status}: ${e.statusText}`,\n      message: i.message\n    };\n  }\n  /**\n   * 通用請求方法\n   */\n  async request(e, n = {}) {\n    const s = this.buildURL(e), i = this.getSessionToken(), r = {\n      ...this.defaultHeaders,\n      ...n.headers\n    };\n    i && !r.Authorization && (r.Authorization = `Bearer ${i}`);\n    try {\n      const o = await fetch(s, {\n        ...n,\n        headers: r,\n        credentials: \"include\"\n        // 包含 cookies\n      });\n      return await this.handleResponse(o);\n    } catch (o) {\n      return console.error(\"[APIClient] Request failed:\", o), {\n        success: !1,\n        error: o instanceof Error ? o.message : \"Network error\"\n      };\n    }\n  }\n  /**\n   * GET 請求\n   */\n  async get(e, n) {\n    return this.request(e, {\n      ...n,\n      method: \"GET\"\n    });\n  }\n  /**\n   * POST 請求\n   */\n  async post(e, n, s) {\n    return this.request(e, {\n      ...s,\n      method: \"POST\",\n      body: n ? JSON.stringify(n) : void 0\n    });\n  }\n  /**\n   * PUT 請求\n   */\n  async put(e, n, s) {\n    return this.request(e, {\n      ...s,\n      method: \"PUT\",\n      body: n ? JSON.stringify(n) : void 0\n    });\n  }\n  /**\n   * PATCH 請求\n   */\n  async patch(e, n, s) {\n    return this.request(e, {\n      ...s,\n      method: \"PATCH\",\n      body: n ? JSON.stringify(n) : void 0\n    });\n  }\n  /**\n   * DELETE 請求\n   */\n  async delete(e, n) {\n    return this.request(e, {\n      ...n,\n      method: \"DELETE\"\n    });\n  }\n}\nlet cs = null;\nconst Mi = () => (cs || (cs = new om()), cs);\nnew Proxy({}, {\n  get(t, e) {\n    return Mi()[e];\n  }\n});\nclass am {\n  constructor(e) {\n    this.apiClient = e || Mi();\n  }\n  /**\n   * 搜尋地點\n   */\n  async searchLocations(e) {\n    return this.apiClient.post(\"/location/search\", e);\n  }\n  /**\n   * 獲取地點詳情\n   */\n  async getLocationDetails(e) {\n    return this.apiClient.get(`/location/${e}`);\n  }\n  /**\n   * 獲取地點詳情（使用 Google Place ID）\n   */\n  async getLocationByGooglePlaceId(e) {\n    return this.apiClient.get(`/location/google/${e}`);\n  }\n  /**\n   * 設定用戶地點互動狀態\n   */\n  async setUserLocationStatus(e, n, s) {\n    return this.apiClient.post(`/location/${e}/interaction`, {\n      status: n,\n      notes: s\n    });\n  }\n  /**\n   * 獲取用戶的地點互動狀態\n   */\n  async getUserLocationStatus(e) {\n    return this.apiClient.get(`/location/${e}/interaction`);\n  }\n  /**\n   * 收藏地點\n   */\n  async favoriteLocation(e) {\n    return this.apiClient.post(`/location/${e}/favorite`);\n  }\n  /**\n   * 取消收藏地點\n   */\n  async unfavoriteLocation(e) {\n    return this.apiClient.delete(`/location/${e}/favorite`);\n  }\n  /**\n   * 獲取用戶收藏的地點列表\n   */\n  async getFavoriteLocations() {\n    return this.apiClient.get(\"/location/favorites\");\n  }\n  /**\n   * 獲取用戶訪問過的地點列表\n   */\n  async getVisitedLocations() {\n    return this.apiClient.get(\"/location/visited\");\n  }\n  /**\n   * 獲取用戶個人地點收藏\n   * @param status - 篩選狀態：'visited' | 'want_to_visit' | 'want_to_revisit'\n   * @param category - 篩選分類：'restaurant' | 'attraction' | 'hotel' | etc.\n   */\n  async getPersonalLocations(e, n) {\n    const s = new URLSearchParams();\n    e && s.append(\"status\", e), n && s.append(\"category\", n);\n    const i = s.toString();\n    return this.apiClient.get(`/itinerary/location/personal${i ? \"?\" + i : \"\"}`);\n  }\n  /**\n   * 獲取地點評論\n   */\n  async getLocationComments(e) {\n    return this.apiClient.get(`/location/${e}/comments`);\n  }\n  /**\n   * 新增地點評論\n   */\n  async addLocationComment(e, n, s) {\n    return this.apiClient.post(`/location/${e}/comments`, {\n      comment: n,\n      rating: s\n    });\n  }\n}\nlet us = null;\nconst lm = () => (us || (us = new am()), us), _t = new Proxy({}, {\n  get(t, e) {\n    return lm()[e];\n  }\n});\nclass cm {\n  constructor(e) {\n    this.apiClient = e || Mi();\n  }\n  /**\n   * 使用 Google OAuth 登入\n   */\n  async loginWithGoogle() {\n    window.location.href = \"/api/auth/google\";\n  }\n  /**\n   * 處理 Google OAuth 回調\n   */\n  async handleGoogleCallback(e) {\n    return this.apiClient.post(\"/auth/google/callback\", { code: e });\n  }\n  /**\n   * 使用電子郵件和密碼登入\n   */\n  async loginWithPassword(e) {\n    const n = await this.apiClient.post(\"/auth/login\", e);\n    return n.success && n.data && (this.saveSession(n.data.session), this.saveUser(n.data.user)), n;\n  }\n  /**\n   * 註冊新用戶\n   */\n  async register(e) {\n    return this.apiClient.post(\"/auth/register\", e);\n  }\n  /**\n   * 登出\n   */\n  async logout() {\n    const e = await this.apiClient.post(\"/auth/logout\");\n    return this.clearSession(), this.clearUser(), e;\n  }\n  /**\n   * 獲取當前用戶\n   */\n  async getCurrentUser() {\n    return this.apiClient.get(\"/auth/me\");\n  }\n  /**\n   * 檢查是否已登入\n   */\n  isAuthenticated() {\n    const e = this.getSession();\n    return e ? e.expiresAt && e.expiresAt < Date.now() ? (this.clearSession(), !1) : !0 : !1;\n  }\n  /**\n   * 獲取當前用戶（從本地儲存）\n   */\n  getCurrentUserLocal() {\n    try {\n      const e = localStorage.getItem(\"user\");\n      return e ? JSON.parse(e) : null;\n    } catch (e) {\n      return console.error(\"[AuthService] Failed to get user from local storage:\", e), null;\n    }\n  }\n  /**\n   * 儲存會話到 localStorage\n   */\n  saveSession(e) {\n    try {\n      localStorage.setItem(\"session\", JSON.stringify(e)), localStorage.setItem(\"session_id\", e.id);\n    } catch (n) {\n      console.error(\"[AuthService] Failed to save session:\", n);\n    }\n  }\n  /**\n   * 從 localStorage 獲取會話\n   */\n  getSession() {\n    try {\n      const e = localStorage.getItem(\"session\");\n      return e ? JSON.parse(e) : null;\n    } catch (e) {\n      return console.error(\"[AuthService] Failed to get session from local storage:\", e), null;\n    }\n  }\n  /**\n   * 儲存用戶資訊到 localStorage\n   */\n  saveUser(e) {\n    try {\n      localStorage.setItem(\"user\", JSON.stringify(e));\n    } catch (n) {\n      console.error(\"[AuthService] Failed to save user:\", n);\n    }\n  }\n  /**\n   * 清除會話\n   */\n  clearSession() {\n    localStorage.removeItem(\"session\"), localStorage.removeItem(\"session_id\");\n  }\n  /**\n   * 清除用戶資訊\n   */\n  clearUser() {\n    localStorage.removeItem(\"user\");\n  }\n}\nlet ds = null;\nconst um = () => (ds || (ds = new cm()), ds), vl = new Proxy({}, {\n  get(t, e) {\n    return um()[e];\n  }\n}), uo = ({ place: t, onClick: e, showInteractions: n = !0 }) => {\n  const [s, i] = L(null), [r, o] = L(!1), [a, l] = L(!1), [u, c] = L(!1);\n  B(() => {\n    (async () => {\n      const v = vl.isAuthenticated();\n      c(v), v && t.id && n && await d();\n    })();\n  }, [t.id, n]);\n  const d = async () => {\n    if (t.id)\n      try {\n        const g = await _t.getUserLocationStatus(t.id);\n        g.success && g.data && i(g.data.status);\n      } catch (g) {\n        console.error(\"[PlaceCard] Error loading user status:\", g);\n      }\n  }, h = async (g, v) => {\n    if (g.stopPropagation(), !(!u || !t.id || a)) {\n      l(!0);\n      try {\n        (await _t.setUserLocationStatus(t.id, v)).success && i(v);\n      } catch (y) {\n        console.error(\"[PlaceCard] Error setting status:\", y);\n      } finally {\n        l(!1);\n      }\n    }\n  }, f = async (g) => {\n    if (g.stopPropagation(), !(!u || !t.id || a)) {\n      l(!0);\n      try {\n        r ? (await _t.unfavoriteLocation(t.id), o(!1)) : (await _t.favoriteLocation(t.id), o(!0));\n      } catch (v) {\n        console.error(\"[PlaceCard] Error toggling favorite:\", v);\n      } finally {\n        l(!1);\n      }\n    }\n  };\n  return /* @__PURE__ */ p.jsx(\n    \"div\",\n    {\n      onClick: e,\n      className: \"bg-white rounded-2xl border border-slate-100 p-4 transition-all hover:bg-slate-50 hover:border-blue-200 cursor-pointer group\",\n      children: /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex items-center justify-between gap-3\", children: [\n        /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex-1 min-w-0\", children: [\n          /* @__PURE__ */ p.jsx(\"h3\", { className: \"font-bold text-slate-800 truncate text-sm group-hover:text-blue-600 transition-colors\", children: t.name }),\n          t.address && /* @__PURE__ */ p.jsxs(\"p\", { className: \"text-[10px] text-slate-400 mt-1 truncate font-medium\", children: [\n            /* @__PURE__ */ p.jsx(\"i\", { className: \"fas fa-map-marker-alt mr-1 text-slate-300\" }),\n            \" \",\n            t.address\n          ] }),\n          t.rating && /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex items-center gap-1 mt-1\", children: [\n            /* @__PURE__ */ p.jsx(\"i\", { className: \"fas fa-star text-amber-400 text-[9px]\" }),\n            /* @__PURE__ */ p.jsx(\"span\", { className: \"text-[9px] text-slate-500 font-bold\", children: t.rating }),\n            t.userRatingCount && /* @__PURE__ */ p.jsxs(\"span\", { className: \"text-[8px] text-slate-400\", children: [\n              \"(\",\n              t.userRatingCount,\n              \")\"\n            ] })\n          ] })\n        ] }),\n        /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex items-center gap-2\", children: [\n          u && n && /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex items-center gap-1\", children: [\n            /* @__PURE__ */ p.jsx(\n              \"button\",\n              {\n                onClick: (g) => h(g, \"visited\"),\n                disabled: a,\n                className: `w-7 h-7 rounded-lg flex items-center justify-center transition-all ${s === \"visited\" ? \"bg-blue-600 text-white\" : \"bg-slate-50 text-slate-400 hover:bg-blue-50 hover:text-blue-600\"}`,\n                title: \"來過\",\n                children: /* @__PURE__ */ p.jsx(\"i\", { className: \"fas fa-check text-[9px]\" })\n              }\n            ),\n            /* @__PURE__ */ p.jsx(\n              \"button\",\n              {\n                onClick: (g) => h(g, \"want_to_visit\"),\n                disabled: a,\n                className: `w-7 h-7 rounded-lg flex items-center justify-center transition-all ${s === \"want_to_visit\" ? \"bg-emerald-600 text-white\" : \"bg-slate-50 text-slate-400 hover:bg-emerald-50 hover:text-emerald-600\"}`,\n                title: \"想來\",\n                children: /* @__PURE__ */ p.jsx(\"i\", { className: \"fas fa-heart text-[9px]\" })\n              }\n            ),\n            /* @__PURE__ */ p.jsx(\n              \"button\",\n              {\n                onClick: (g) => h(g, \"want_to_revisit\"),\n                disabled: a,\n                className: `w-7 h-7 rounded-lg flex items-center justify-center transition-all ${s === \"want_to_revisit\" ? \"bg-purple-600 text-white\" : \"bg-slate-50 text-slate-400 hover:bg-purple-50 hover:text-purple-600\"}`,\n                title: \"想再來\",\n                children: /* @__PURE__ */ p.jsx(\"i\", { className: \"fas fa-redo text-[9px]\" })\n              }\n            ),\n            /* @__PURE__ */ p.jsx(\n              \"button\",\n              {\n                onClick: f,\n                disabled: a,\n                className: `w-7 h-7 rounded-lg flex items-center justify-center transition-all ${r ? \"bg-amber-500 text-white\" : \"bg-slate-50 text-slate-400 hover:bg-amber-50 hover:text-amber-500\"}`,\n                title: \"收藏\",\n                children: /* @__PURE__ */ p.jsx(\"i\", { className: \"fas fa-star text-[9px]\" })\n              }\n            )\n          ] }),\n          /* @__PURE__ */ p.jsx(\"div\", { className: \"w-8 h-8 rounded-full bg-slate-50 text-slate-300 flex items-center justify-center group-hover:bg-blue-600 group-hover:text-white transition-all\", children: /* @__PURE__ */ p.jsx(\"i\", { className: \"fas fa-chevron-right text-[10px]\" }) })\n        ] })\n      ] })\n    }\n  );\n}, ho = ({\n  item: t,\n  onRemove: e,\n  onTimeUpdate: n,\n  onClick: s,\n  isLast: i,\n  travelTimeToNext: r,\n  travelMode: o = \"DRIVING\",\n  nextPlace: a\n}) => {\n  const [l, u] = L(!1), [c, d] = L(t.startTime), h = j(null), {\n    attributes: f,\n    listeners: g,\n    setNodeRef: v,\n    transform: y,\n    transition: x,\n    isDragging: T\n  } = xu({ id: t.id }), b = {\n    transform: Ge.Transform.toString(y),\n    transition: x,\n    zIndex: T ? 50 : l ? 100 : 1,\n    opacity: T ? 0.3 : 1\n  }, P = o === \"DRIVING\" ? \"blue\" : \"emerald\", D = (S) => {\n    const [N, O] = S.split(\":\"), F = parseInt(N), G = F >= 12 ? \"下午\" : \"上午\", _ = F % 12 || 12;\n    return { ampm: G, h: _.toString().padStart(2, \"0\"), m: O };\n  }, { ampm: R, h: m, m: w } = D(t.startTime), C = () => {\n    u(!1), n && c !== t.startTime && n(t.id, c);\n  };\n  B(() => {\n    const S = (N) => {\n      h.current && !h.current.contains(N.target) && l && C();\n    };\n    return l && document.addEventListener(\"mousedown\", S), () => document.removeEventListener(\"mousedown\", S);\n  }, [l, c]);\n  const M = (S) => {\n    if (S.stopPropagation(), !a) return;\n    const N = t.place.location ? `${t.place.location.lat},${t.place.location.lng}` : encodeURIComponent(t.place.name), O = a.location ? `${a.location.lat},${a.location.lng}` : encodeURIComponent(a.name), F = o === \"DRIVING\" ? \"driving\" : \"walking\";\n    window.open(`https://www.google.com/maps/dir/?api=1&origin=${N}&destination=${O}&travelmode=${F}`, \"_blank\");\n  };\n  return /* @__PURE__ */ p.jsxs(\n    \"div\",\n    {\n      ref: v,\n      style: b,\n      className: \"relative flex flex-col group w-full\",\n      children: [\n        l && /* @__PURE__ */ p.jsx(\"div\", { className: \"fixed inset-0 bg-slate-900/5 backdrop-blur-[1px] z-[90] pointer-events-none\" }),\n        /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex items-start gap-4 sm:gap-6 w-full relative\", children: [\n          /* @__PURE__ */ p.jsxs(\"div\", { className: \"relative flex flex-col items-center flex-shrink-0\", children: [\n            /* @__PURE__ */ p.jsx(\"div\", { className: \"w-4 h-4 rounded-full bg-white border-4 border-blue-600 shadow-xl z-20 relative group-hover:scale-125 transition-all duration-500\" }),\n            !i && /* @__PURE__ */ p.jsx(\"div\", { className: \"absolute top-12 bottom-[-54px] w-[2px] bg-gradient-to-b from-blue-600/30 via-slate-100 to-slate-100 z-10\" })\n          ] }),\n          /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex-1 min-w-0 flex flex-col gap-3\", children: [\n            /* @__PURE__ */ p.jsx(\"div\", { ref: h, className: \"flex-shrink-0 relative z-[101]\", children: l ? (\n              /* 時間選擇器彈窗 */\n              /* @__PURE__ */ p.jsxs(\"div\", { className: \"absolute top-0 left-0 z-[110] bg-[#1e1e1e] rounded-[2rem] p-4 shadow-[0_30px_60px_-12px_rgba(0,0,0,0.45)] border border-slate-700 w-44 animate-in fade-in zoom-in slide-in-from-left-4 duration-300\", children: [\n                /* @__PURE__ */ p.jsx(\"div\", { className: \"absolute top-6 -left-2 w-4 h-4 bg-[#1e1e1e] border-l border-t border-slate-700 rotate-[-45deg]\" }),\n                /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex flex-col gap-4 relative\", children: [\n                  /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex items-center justify-between px-1\", children: [\n                    /* @__PURE__ */ p.jsx(\"span\", { className: \"text-[10px] font-black text-slate-500 uppercase tracking-[0.2em]\", children: \"行程時間\" }),\n                    /* @__PURE__ */ p.jsx(\"button\", { onClick: C, className: \"text-[10px] font-black text-blue-400 hover:text-white transition-colors\", children: \"儲存\" })\n                  ] }),\n                  /* @__PURE__ */ p.jsxs(\"div\", { className: \"space-y-3\", children: [\n                    /* @__PURE__ */ p.jsx(\"div\", { className: \"relative group\", children: /* @__PURE__ */ p.jsx(\n                      \"input\",\n                      {\n                        type: \"time\",\n                        autoFocus: !0,\n                        value: c,\n                        onChange: (S) => d(S.target.value),\n                        className: \"w-full bg-[#2a2d31] text-white border-2 border-transparent focus:border-blue-500 rounded-2xl py-3 px-4 text-2xl font-black tabular-nums outline-none transition-all shadow-inner text-center\"\n                      }\n                    ) }),\n                    /* @__PURE__ */ p.jsxs(\"p\", { className: \"text-[9px] text-slate-500 font-bold leading-tight px-1\", children: [\n                      /* @__PURE__ */ p.jsx(\"i\", { className: \"fas fa-info-circle mr-1\" }),\n                      \" 修改將自動順延後續行程\"\n                    ] })\n                  ] })\n                ] })\n              ] })\n            ) : /* @__PURE__ */ p.jsxs(\n              \"button\",\n              {\n                onClick: (S) => {\n                  S.stopPropagation(), u(!0);\n                },\n                className: \"group/time relative flex items-center gap-3 px-4 py-2.5 rounded-2xl bg-slate-50 hover:bg-white hover:ring-2 hover:ring-blue-500 transition-all duration-300 w-fit shadow-sm\",\n                children: [\n                  /* @__PURE__ */ p.jsx(\"span\", { className: \"text-[11px] font-black text-slate-400 uppercase tracking-tighter\", children: R }),\n                  /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex items-center gap-2\", children: [\n                    /* @__PURE__ */ p.jsxs(\"span\", { className: \"text-[18px] font-black text-blue-600 tabular-nums leading-none tracking-tighter\", children: [\n                      m,\n                      \":\",\n                      w\n                    ] }),\n                    /* @__PURE__ */ p.jsx(\"div\", { className: \"w-5 h-5 rounded-lg bg-blue-50 flex items-center justify-center group-hover/time:bg-blue-600 transition-colors\", children: /* @__PURE__ */ p.jsx(\"i\", { className: \"fas fa-pencil text-[8px] text-blue-400 group-hover/time:text-white\" }) })\n                  ] })\n                ]\n              }\n            ) }),\n            /* @__PURE__ */ p.jsxs(\n              \"div\",\n              {\n                onClick: s,\n                className: `bg-white p-5 rounded-[2.5rem] shadow-[0_4px_30px_rgba(0,0,0,0.02)] border border-slate-100 flex items-center justify-between hover:border-blue-400 hover:shadow-[0_25px_60px_rgba(37,99,235,0.12)] transition-all duration-500 cursor-pointer active:scale-[0.98] overflow-hidden ${l ? \"opacity-30\" : \"\"}`,\n                children: [\n                  /* @__PURE__ */ p.jsx(\"div\", { ...f, ...g, onClick: (S) => S.stopPropagation(), className: \"cursor-grab active:cursor-grabbing mr-4 text-slate-200 hover:text-blue-500 transition-colors p-2 flex-shrink-0\", children: /* @__PURE__ */ p.jsx(\"i\", { className: \"fas fa-grip-vertical text-sm\" }) }),\n                  /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex-1 min-w-0\", children: [\n                    /* @__PURE__ */ p.jsx(\"h4\", { className: \"font-black text-slate-900 text-[16px] sm:text-[18px] leading-tight break-words whitespace-normal group-hover:text-blue-600 transition-colors tracking-tight\", children: t.place.name }),\n                    /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex flex-wrap items-center gap-x-4 gap-y-2 mt-3\", children: [\n                      /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex items-center gap-2 px-3 py-1.5 bg-blue-50/60 rounded-xl\", children: [\n                        /* @__PURE__ */ p.jsx(\"i\", { className: \"fas fa-hourglass-start text-blue-500 text-[10px]\" }),\n                        /* @__PURE__ */ p.jsx(\"span\", { className: \"text-[11px] text-blue-700 font-black\", children: \"停留 1.5h\" })\n                      ] }),\n                      /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex items-center gap-1.5\", children: [\n                        /* @__PURE__ */ p.jsx(\"i\", { className: \"fas fa-location-dot text-slate-200 text-[11px]\" }),\n                        /* @__PURE__ */ p.jsx(\"span\", { className: \"text-[11px] text-slate-400 font-bold truncate max-w-[160px]\", children: t.place.address?.split(\" \")[0] || \"澎湖縣\" })\n                      ] })\n                    ] })\n                  ] }),\n                  /* @__PURE__ */ p.jsx(\"button\", { onClick: (S) => {\n                    S.stopPropagation(), e(t.id);\n                  }, className: \"ml-4 w-10 h-10 rounded-2xl flex items-center justify-center text-slate-200 hover:bg-red-50 hover:text-red-500 transition-all duration-300 flex-shrink-0\", children: /* @__PURE__ */ p.jsx(\"i\", { className: \"fas fa-trash-alt text-[12px]\" }) })\n                ]\n              }\n            )\n          ] })\n        ] }),\n        !i && /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex items-center gap-4 sm:gap-6 h-[100px] pointer-events-none w-full mt-2\", children: [\n          /* @__PURE__ */ p.jsx(\"div\", { className: \"w-4 flex-shrink-0\" }),\n          /* @__PURE__ */ p.jsx(\"div\", { className: \"relative flex-1 flex items-center justify-start min-w-0\", children: r && /* @__PURE__ */ p.jsxs(\"button\", { onClick: M, className: \"pointer-events-auto group/nav relative flex items-center gap-4 bg-white border border-slate-50 py-3.5 px-6 rounded-[2rem] shadow-[0_12px_40px_rgba(0,0,0,0.06)] hover:shadow-2xl hover:border-blue-300 hover:-translate-y-1 transition-all duration-500 max-w-[260px]\", children: [\n            /* @__PURE__ */ p.jsx(\"div\", { className: `w-10 h-10 rounded-2xl bg-${P}-600 flex items-center justify-center text-white text-[13px] shadow-lg group-hover/nav:rotate-12 transition-all`, children: /* @__PURE__ */ p.jsx(\"i\", { className: `fas fa-${o === \"DRIVING\" ? \"car-side\" : \"person-walking\"}` }) }),\n            /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex flex-col items-start min-w-0\", children: [\n              /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex items-center gap-2\", children: [\n                /* @__PURE__ */ p.jsx(\"span\", { className: \"text-[16px] font-black text-slate-900 tabular-nums leading-none\", children: r }),\n                /* @__PURE__ */ p.jsx(\"div\", { className: \"w-2 h-2 rounded-full bg-blue-500 animate-pulse\" })\n              ] }),\n              /* @__PURE__ */ p.jsx(\"span\", { className: `text-[9px] font-black text-${P}-500 uppercase tracking-widest leading-none mt-1.5 whitespace-nowrap`, children: \"點擊開啟導覽\" })\n            ] })\n          ] }) })\n        ] })\n      ]\n    }\n  );\n}, dm = ({\n  items: t,\n  center: e,\n  travelMode: n = \"DRIVING\",\n  onAddPlaceFromMap: s,\n  selectedPlace: i,\n  onInfoWindowClose: r,\n  onTravelDataUpdate: o\n}) => {\n  const a = j(null), l = j(null), u = j([]), c = j([]), d = j([]), h = j(null), [f, g] = L(!1), [v, y] = L(null);\n  B(() => {\n    (async () => {\n      try {\n        const w = await fetch(\"/api/itinerary/maps-api-key\", {\n          method: \"GET\",\n          credentials: \"include\"\n        });\n        if (w.ok) {\n          const C = await w.json();\n          C.success && C.apiKey && y(C.apiKey);\n        }\n      } catch (w) {\n        console.error(\"[MapView] Failed to fetch Google Maps API key:\", w);\n      }\n    })();\n  }, []), B(() => ((async () => {\n    if (!a.current || !v) return;\n    const w = (C) => {\n      var M, S, N, O = \"The Google Maps JavaScript API\", F = \"google\", G = \"importLibrary\", _ = \"__googleMapsCallback__\", k = document, U = window;\n      U = U[F] || (U[F] = {});\n      var H = U.maps || (U.maps = {}), tt = /* @__PURE__ */ new Set(), et = new URLSearchParams(), X = () => M || (M = new Promise(async (dt, xt) => {\n        await (S = k.createElement(\"script\")), S.async = !0, et.set(\"libraries\", [...tt] + \"\");\n        for (N in C) et.set(N.replace(/[A-Z]/g, (Ot) => \"_\" + Ot[0].toLowerCase()), C[N]);\n        et.set(\"callback\", F + \".maps.\" + _), S.src = \"https://maps.googleapis.com/maps/api/js?\" + et, H[_] = dt, S.onerror = () => M = xt(Error(O + \" could not load.\")), k.head.append(S);\n      }));\n      H[G] ? console.warn(O + \" only loads once. Re-trying:\", C) : H[G] = (dt, ...xt) => tt.add(dt) && X().then(() => H[G](dt, ...xt));\n    };\n    window.google?.maps?.importLibrary || w({ key: v, v: \"weekly\", loading: \"async\" });\n    try {\n      const { Map: C, InfoWindow: M } = await window.google.maps.importLibrary(\"maps\"), S = e || { lat: 23.5713, lng: 119.5793 };\n      l.current = new C(a.current, {\n        center: S,\n        zoom: 12,\n        mapId: \"DEMO_MAP_ID\",\n        disableDefaultUI: !0,\n        zoomControl: !0,\n        clickableIcons: !0,\n        gestureHandling: \"greedy\"\n        // 允許滾動縮放，不需要按 command\n      }), h.current = new M(), h.current.addListener(\"closeclick\", () => {\n        r && r();\n      }), l.current.addListener(\"click\", async (N) => {\n        N.placeId ? (N.stop(), x(N.placeId)) : r && r();\n      }), g(!0);\n    } catch (C) {\n      console.error(\"Failed to load Google Maps libraries:\", C);\n    }\n  })(), () => b()), [v]), B(() => {\n    f && R();\n  }, [t, f, n]), B(() => {\n    (async () => {\n      if (!f || !l.current || !i) {\n        f && !i && h.current && h.current.close();\n        return;\n      }\n      if (i.location)\n        l.current.panTo(i.location), l.current.setZoom(16), T(i);\n      else\n        try {\n          const { Place: w } = await window.google.maps.importLibrary(\"places\"), C = {\n            textQuery: i.name,\n            fields: [\"displayName\", \"formattedAddress\", \"location\", \"id\", \"rating\", \"userRatingCount\", \"nationalPhoneNumber\", \"websiteURI\", \"types\"],\n            maxResultCount: 1,\n            locationBias: l.current.getCenter()\n          }, { places: M } = await w.searchByText(C);\n          if (M && M.length > 0) {\n            const S = M[0], N = {\n              ...i,\n              id: S.id || i.id,\n              location: { lat: S.location.lat(), lng: S.location.lng() },\n              address: S.formattedAddress || i.address,\n              formatted_address: S.formattedAddress || i.address,\n              rating: S.rating,\n              userRatingCount: S.userRatingCount,\n              phoneNumber: S.nationalPhoneNumber,\n              website: S.websiteURI,\n              types: S.types,\n              // 添加 Google Place 相關欄位\n              google_place_id: S.id || i.id,\n              place_id: S.id || i.id,\n              latitude: S.location.lat(),\n              longitude: S.location.lng(),\n              lat: S.location.lat(),\n              lng: S.location.lng(),\n              google_rating: S.rating,\n              user_ratings_total: S.userRatingCount\n            };\n            l.current.panTo(N.location), l.current.setZoom(16), T(N);\n          }\n        } catch (w) {\n          console.error(\"Resolve place error:\", w);\n        }\n    })();\n  }, [i, f]);\n  const x = async (m) => {\n    try {\n      const { Place: w } = await window.google.maps.importLibrary(\"places\"), C = new w({ id: m });\n      await C.fetchFields({\n        fields: [\"displayName\", \"formattedAddress\", \"location\", \"rating\", \"userRatingCount\", \"nationalPhoneNumber\", \"websiteURI\", \"regularOpeningHours\", \"types\", \"priceLevel\"]\n      });\n      const M = {\n        id: m,\n        name: C.displayName || \"未知地點\",\n        address: C.formattedAddress,\n        formatted_address: C.formattedAddress,\n        rating: C.rating,\n        userRatingCount: C.userRatingCount,\n        phoneNumber: C.nationalPhoneNumber,\n        website: C.websiteURI,\n        types: C.types,\n        location: { lat: C.location.lat(), lng: C.location.lng() },\n        // 添加 Google Place 相關欄位\n        google_place_id: m,\n        place_id: m,\n        latitude: C.location.lat(),\n        longitude: C.location.lng(),\n        lat: C.location.lat(),\n        lng: C.location.lng(),\n        google_rating: C.rating,\n        user_ratings_total: C.userRatingCount\n      };\n      T(M);\n    } catch (w) {\n      console.error(\"Error fetching place details:\", w);\n    }\n  }, T = async (m) => {\n    if (!l.current || !h.current) return;\n    const w = vl.isAuthenticated();\n    let C = null, M = !1;\n    if (w && m.id)\n      try {\n        const _ = await _t.getUserLocationStatus(m.id);\n        _.success && _.data && (C = _.data.status);\n      } catch (_) {\n        console.error(\"[MapView] Error loading user status:\", _);\n      }\n    const S = document.createElement(\"div\");\n    S.className = \"p-0 min-w-[300px] max-w-[340px] font-sans overflow-hidden rounded-3xl bg-white\";\n    const N = m.rating ? Array(5).fill(0).map((_, k) => {\n      const U = Math.min(Math.max(m.rating - k, 0), 1);\n      return `<i class=\"fas fa-star ${U >= 0.8 ? \"text-amber-400\" : U >= 0.3 ? \"text-amber-400/60\" : \"text-slate-100\"}\" style=\"font-size: 11px;\"></i>`;\n    }).join(\"\") : \"\", O = m.rating ? `<div class=\"flex items-center gap-2 mb-4 bg-amber-50/50 p-2.5 rounded-2xl border border-amber-100/50\">\n           <div class=\"flex gap-0.5\">${N}</div>\n           <span class=\"text-amber-700 text-xs font-black\">${m.rating}</span>\n           <span class=\"text-amber-600/50 text-[10px] font-bold\">/ ${m.userRatingCount?.toLocaleString()} 則評論</span>\n         </div>` : \"\", F = m.types ? `<div class=\"flex flex-wrap gap-1.5 mb-5\">\n           ${m.types.slice(0, 3).map((_) => `<span class=\"px-2.5 py-1 bg-slate-50 text-slate-500 rounded-xl text-[9px] font-black uppercase tracking-widest border border-slate-100 shadow-sm\">${_.replace(\"_\", \" \")}</span>`).join(\"\")}\n         </div>` : \"\", G = w && m.id ? `\n      <div class=\"flex items-center gap-2 mb-4 pt-4 border-t border-slate-50\">\n        <button id=\"btn-status-visited-${m.id}\" class=\"flex-1 py-2.5 px-3 rounded-xl text-[10px] font-black transition-all ${C === \"visited\" ? \"bg-blue-600 text-white\" : \"bg-slate-50 text-slate-400 hover:bg-blue-50 hover:text-blue-600\"}\">\n          <i class=\"fas fa-check mr-1\"></i>來過\n        </button>\n        <button id=\"btn-status-want-${m.id}\" class=\"flex-1 py-2.5 px-3 rounded-xl text-[10px] font-black transition-all ${C === \"want_to_visit\" ? \"bg-emerald-600 text-white\" : \"bg-slate-50 text-slate-400 hover:bg-emerald-50 hover:text-emerald-600\"}\">\n          <i class=\"fas fa-heart mr-1\"></i>想來\n        </button>\n        <button id=\"btn-status-revisit-${m.id}\" class=\"flex-1 py-2.5 px-3 rounded-xl text-[10px] font-black transition-all ${C === \"want_to_revisit\" ? \"bg-purple-600 text-white\" : \"bg-slate-50 text-slate-400 hover:bg-purple-50 hover:text-purple-600\"}\">\n          <i class=\"fas fa-redo mr-1\"></i>想再來\n        </button>\n        <button id=\"btn-favorite-${m.id}\" class=\"w-10 h-10 rounded-xl flex items-center justify-center transition-all bg-slate-50 text-slate-400 hover:bg-amber-50 hover:text-amber-500\">\n          <i class=\"fas fa-star text-[10px]\"></i>\n        </button>\n      </div>\n    ` : \"\";\n    S.innerHTML = `\n      <div class=\"p-6\">\n        <div class=\"flex justify-between items-start mb-5\">\n           <div class=\"flex items-center gap-3\">\n             <div class=\"w-10 h-10 rounded-2xl bg-gradient-to-br from-blue-600 to-indigo-700 flex items-center justify-center text-white text-[14px] shadow-xl shadow-blue-200\">\n               <i class=\"fas fa-location-dot\"></i>\n             </div>\n             <div class=\"flex flex-col\">\n               <span class=\"text-blue-600 text-[10px] font-black uppercase tracking-[0.25em] leading-none mb-1\">Discover Place</span>\n               <div class=\"w-8 h-1 bg-blue-100 rounded-full\"></div>\n             </div>\n           </div>\n        </div>\n        <div class=\"font-black text-2xl text-slate-900 leading-tight mb-2 tracking-tighter\">${m.name}</div>\n        ${O}\n        ${F}\n        <div class=\"space-y-4 pt-5 border-t border-slate-50\">\n          ${m.phoneNumber ? `<div class=\"flex items-center gap-4 group\"><div class=\"w-8 h-8 rounded-full bg-blue-50 flex items-center justify-center text-blue-600 shadow-sm\"><i class=\"fas fa-phone text-[10px]\"></i></div><span class=\"text-[13px] text-slate-700 font-bold\">${m.phoneNumber}</span></div>` : \"\"}\n          ${m.website ? `<a href=\"${m.website}\" target=\"_blank\" class=\"flex items-center gap-4 group transition-all\"><div class=\"w-8 h-8 rounded-full bg-indigo-50 flex items-center justify-center text-indigo-600 group-hover:bg-indigo-600 group-hover:text-white transition-all shadow-sm\"><i class=\"fas fa-link text-[10px]\"></i></div><span class=\"text-[13px] text-indigo-600 font-black group-hover:underline\">造訪官方網站</span></a>` : \"\"}\n          <div class=\"flex items-start gap-4\"><div class=\"w-8 h-8 rounded-full bg-slate-50 flex items-center justify-center text-slate-400 shadow-sm\"><i class=\"fas fa-map text-[10px]\"></i></div><span class=\"text-[12px] text-slate-500 font-medium leading-relaxed\">${m.address || \"地址資訊\"}</span></div>\n        </div>\n        ${G}\n        <button id=\"btn-add-${m.id}\" class=\"mt-4 w-full py-4.5 bg-slate-900 hover:bg-blue-600 text-white rounded-[1.25rem] text-[12px] font-black uppercase tracking-widest transition-all shadow-2xl shadow-slate-200 active:scale-[0.96] flex items-center justify-center gap-3 overflow-hidden group relative\">\n          <span class=\"relative z-10\"><i class=\"fas fa-plus-circle mr-1\"></i> 加入此行程</span>\n          <div class=\"absolute inset-0 bg-gradient-to-r from-blue-600 to-indigo-600 opacity-0 group-hover:opacity-100 transition-opacity\"></div>\n        </button>\n      </div>\n    `, h.current.setContent(S), h.current.setPosition(m.location), h.current.open(l.current), setTimeout(() => {\n      const _ = document.getElementById(`btn-add-${m.id}`);\n      if (_ && (_.onclick = (k) => {\n        k.preventDefault(), s(m), h.current.close();\n      }), w && m.id) {\n        const k = document.getElementById(`btn-status-visited-${m.id}`), U = document.getElementById(`btn-status-want-${m.id}`), H = document.getElementById(`btn-status-revisit-${m.id}`), tt = document.getElementById(`btn-favorite-${m.id}`);\n        k && (k.onclick = async (et) => {\n          et.preventDefault();\n          try {\n            await _t.setUserLocationStatus(m.id, \"visited\"), T(m);\n          } catch (X) {\n            console.error(\"[MapView] Error setting status:\", X);\n          }\n        }), U && (U.onclick = async (et) => {\n          et.preventDefault();\n          try {\n            await _t.setUserLocationStatus(m.id, \"want_to_visit\"), T(m);\n          } catch (X) {\n            console.error(\"[MapView] Error setting status:\", X);\n          }\n        }), H && (H.onclick = async (et) => {\n          et.preventDefault();\n          try {\n            await _t.setUserLocationStatus(m.id, \"want_to_revisit\"), T(m);\n          } catch (X) {\n            console.error(\"[MapView] Error setting status:\", X);\n          }\n        }), tt && (tt.onclick = async (et) => {\n          et.preventDefault();\n          try {\n            M || await _t.favoriteLocation(m.id), T(m);\n          } catch (X) {\n            console.error(\"[MapView] Error toggling favorite:\", X);\n          }\n        });\n      }\n    }, 10);\n  }, b = () => {\n    u.current.forEach((m) => m.setMap(null)), u.current = [], c.current.forEach((m) => m.setMap(null)), c.current = [], d.current.forEach((m) => m.setMap(null)), d.current = [];\n  }, P = (m, w) => {\n    const M = (w.lat - m.lat) * Math.PI / 180, S = (w.lng - m.lng) * Math.PI / 180, N = Math.sin(M / 2) * Math.sin(M / 2) + Math.cos(m.lat * Math.PI / 180) * Math.cos(w.lat * Math.PI / 180) * Math.sin(S / 2) * Math.sin(S / 2), k = 6371 * (2 * Math.atan2(Math.sqrt(N), Math.sqrt(1 - N))) * (n === \"DRIVING\" ? 1.45 : 1.2) / (n === \"DRIVING\" ? 40 : 5);\n    return { text: `${Math.max(3, Math.round(k * 60))} 分鐘`, isEstimated: !0, status: \"預估\" };\n  }, D = async (m) => {\n    if (m.length < 2) return [];\n    const w = [], C = new window.google.maps.DirectionsService();\n    for (let M = 0; M < m.length - 1; M++)\n      try {\n        const S = await new Promise((O, F) => {\n          C.route({\n            origin: m[M],\n            destination: m[M + 1],\n            travelMode: n === \"DRIVING\" ? google.maps.TravelMode.DRIVING : google.maps.TravelMode.WALKING\n          }, (G, _) => {\n            _ === \"OK\" ? O(G) : F(_);\n          });\n        }), N = S.routes[0].legs[0];\n        w.push({\n          index: M,\n          duration: N.duration.text,\n          status: n === \"DRIVING\" ? \"行車\" : \"步行\",\n          isEstimated: !1,\n          midpoint: N.steps[Math.floor(N.steps.length / 2)].end_location,\n          overview_path: S.routes[0].overview_path\n        });\n      } catch {\n        const N = P(m[M], m[M + 1]);\n        w.push({\n          index: M,\n          duration: N.text,\n          status: \"預估\",\n          isEstimated: !0,\n          midpoint: { lat: (m[M].lat + m[M + 1].lat) / 2, lng: (m[M].lng + m[M + 1].lng) / 2 },\n          overview_path: [m[M], m[M + 1]]\n        });\n      }\n    return w;\n  }, R = async () => {\n    if (!l.current || !f) return;\n    b();\n    const { AdvancedMarkerElement: m, PinElement: w } = await window.google.maps.importLibrary(\"marker\"), { Polyline: C } = await window.google.maps.importLibrary(\"maps\"), M = new window.google.maps.LatLngBounds(), S = [];\n    t.forEach((N, O) => {\n      if (N.place.location) {\n        const F = new w({ background: \"#2563eb\", borderColor: \"#ffffff\", glyphColor: \"#ffffff\", glyphText: (O + 1).toString(), scale: 1.1 }), G = new m({ map: l.current, position: N.place.location, title: N.place.name, content: F.element });\n        G.addListener(\"click\", () => T(N.place)), u.current.push(G), S.push(N.place.location), M.extend(N.place.location);\n      }\n    }), S.length > 1 ? D(S).then((N) => {\n      o && o(N.map((O) => O.duration)), N.forEach((O) => {\n        const F = new C({\n          path: O.overview_path,\n          geodesic: !0,\n          strokeColor: n === \"DRIVING\" ? \"#2563eb\" : \"#10b981\",\n          strokeOpacity: 0.6,\n          strokeWeight: 6,\n          map: l.current\n        });\n        d.current.push(F);\n        const G = document.createElement(\"div\");\n        G.className = \"pointer-events-none group\";\n        const _ = n === \"DRIVING\" ? \"blue\" : \"emerald\";\n        G.innerHTML = `\n            <div class=\"bg-white/95 backdrop-blur-md px-4 py-2 rounded-2xl shadow-2xl border border-${_}-100 flex items-center gap-3 transform transition-all duration-500 hover:scale-110\">\n              <div class=\"w-7 h-7 rounded-xl bg-${_}-600 flex items-center justify-center shadow-lg\">\n                <i class=\"fas fa-${n === \"DRIVING\" ? \"car-side\" : \"person-walking\"} text-[10px] text-white\"></i>\n              </div>\n              <div class=\"flex flex-col\">\n                <span class=\"text-[12px] font-black text-slate-800 leading-none mb-0.5\">${O.duration}</span>\n                <span class=\"text-[8px] font-black text-${_}-500 uppercase tracking-widest leading-none\">${O.status}路徑</span>\n              </div>\n            </div>`;\n        const k = new m({ map: l.current, position: O.midpoint, content: G, zIndex: 200 });\n        c.current.push(k);\n      });\n    }) : o && o([]), S.length > 0 && !i && l.current.fitBounds(M, { padding: 140 });\n  };\n  return /* @__PURE__ */ p.jsxs(\"div\", { className: \"absolute inset-0 bg-slate-100 overflow-hidden\", children: [\n    /* @__PURE__ */ p.jsx(\"div\", { ref: a, className: \"w-full h-full\" }),\n    !f && /* @__PURE__ */ p.jsx(\"div\", { className: \"absolute inset-0 flex items-center justify-center bg-slate-50/90 backdrop-blur-xl z-50\", children: /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex flex-col items-center gap-6\", children: [\n      /* @__PURE__ */ p.jsxs(\"div\", { className: \"relative w-16 h-16\", children: [\n        /* @__PURE__ */ p.jsx(\"div\", { className: \"absolute inset-0 border-4 border-blue-100 rounded-full\" }),\n        /* @__PURE__ */ p.jsx(\"div\", { className: \"absolute inset-0 border-4 border-blue-600 border-t-transparent rounded-full animate-spin\" })\n      ] }),\n      /* @__PURE__ */ p.jsxs(\"div\", { className: \"text-center\", children: [\n        /* @__PURE__ */ p.jsx(\"p\", { className: \"text-sm font-black text-slate-800 uppercase tracking-[0.3em] mb-1\", children: \"PENGHU AI MAP\" }),\n        /* @__PURE__ */ p.jsx(\"p\", { className: \"text-[10px] text-slate-400 font-bold uppercase tracking-widest animate-pulse\", children: \"Initializing Smart Interface...\" })\n      ] })\n    ] }) })\n  ] });\n}, hs = (t) => {\n  const [e, n] = t.split(\":\").map(Number);\n  return e * 60 + n;\n}, hm = (t) => {\n  const e = (t % 1440 + 1440) % 1440, n = Math.floor(e / 60), s = e % 60;\n  return `${n.toString().padStart(2, \"0\")}:${s.toString().padStart(2, \"0\")}`;\n}, gm = ({\n  initialItinerary: t,\n  userItineraries: e = [],\n  currentUser: n,\n  onSave: s\n}) => {\n  const [i, r] = L(\"\"), [o, a] = L([]), [l, u] = L(!1), [c, d] = L(!1), [h, f] = L(0), [g, v] = L(\"DRIVING\"), [y, x] = L(() => {\n    if (t && t.dayPlans)\n      return t.dayPlans.map((V, E) => {\n        if (V.date && (V.date.includes(\"第\") || V.date.includes(\"天\"))) {\n          const z = /* @__PURE__ */ new Date();\n          return z.setDate(z.getDate() + E), { ...V, date: z.toISOString().split(\"T\")[0] };\n        }\n        return V;\n      });\n    const A = /* @__PURE__ */ new Date();\n    return [\n      { date: A.toISOString().split(\"T\")[0], items: [] },\n      { date: new Date(A.getTime() + 1440 * 60 * 1e3).toISOString().split(\"T\")[0], items: [] },\n      { date: new Date(A.getTime() + 2880 * 60 * 1e3).toISOString().split(\"T\")[0], items: [] }\n    ];\n  }), [T, b] = L([]), [P, D] = L(null), [R, m] = L(), [w, C] = L(\"low\"), [M, S] = L(\n    t?.id || null\n  ), [N, O] = L(!1), F = mt.useRef(null), [G, _] = L(!1), [k, U] = L([]), [H, tt] = L(!1), et = Jl(\n    Oi(Xs, { activationConstraint: { distance: 8 } }),\n    Oi(Gs, { coordinateGetter: Tu })\n  );\n  B(() => {\n    navigator.geolocation && navigator.geolocation.getCurrentPosition(\n      (A) => m({ lat: A.coords.latitude, lng: A.coords.longitude }),\n      () => console.warn(\"Location permission denied\")\n    );\n  }, []), B(() => {\n    if (!(!s || !n))\n      return F.current && clearTimeout(F.current), F.current = setTimeout(async () => {\n        if (!N) {\n          O(!0);\n          try {\n            const A = {\n              title: `澎湖行程 ${(/* @__PURE__ */ new Date()).toLocaleDateString(\"zh-TW\")}`,\n              dayPlans: y\n            };\n            M && (A.id = M);\n            const V = await s(A);\n            V && V.id && (S(V.id), typeof window < \"u\" && window.showToast && window.showToast(\"行程已自動儲存\", \"success\"));\n          } catch (A) {\n            console.error(\"[App] Auto-save failed:\", A), typeof window < \"u\" && window.showToast && window.showToast(\"自動儲存失敗，請稍後再試\", \"error\");\n          } finally {\n            O(!1);\n          }\n        }\n      }, 3e3), () => {\n        F.current && clearTimeout(F.current);\n      };\n  }, [y, s, n, M, N]);\n  const X = async () => {\n    if (!i.trim()) return;\n    u(!0);\n    const A = await co.searchPlaces(i, R?.lat, R?.lng);\n    a(A), u(!1);\n  }, dt = async () => {\n    if (n) {\n      tt(!0);\n      try {\n        const A = await _t.getPersonalLocations();\n        if (A.success && A.data) {\n          const V = A.data.map((E) => ({\n            id: E.id,\n            name: E.name,\n            address: E.address,\n            location: E.latitude && E.longitude ? {\n              lat: E.latitude,\n              lng: E.longitude\n            } : void 0,\n            rating: E.google_rating,\n            userRatingCount: E.google_user_ratings_total,\n            phoneNumber: E.phone_number,\n            website: E.website,\n            types: typeof E.google_types == \"string\" ? JSON.parse(E.google_types) : E.google_types,\n            thumbnail: E.thumbnail_url,\n            google_place_id: E.google_place_id,\n            place_id: E.google_place_id,\n            latitude: E.latitude,\n            longitude: E.longitude,\n            lat: E.latitude,\n            lng: E.longitude,\n            google_rating: E.google_rating,\n            user_ratings_total: E.google_user_ratings_total\n          }));\n          U(V), _(!0);\n        }\n      } catch (A) {\n        console.error(\"[App] Error loading personal locations:\", A), typeof window < \"u\" && window.showToast && window.showToast(\"載入個人地點失敗\", \"error\");\n      } finally {\n        tt(!1);\n      }\n    }\n  }, xt = (A) => {\n    const V = y[h].items;\n    let E = \"09:00\";\n    if (V.length > 0) {\n      const z = V[V.length - 1], [Z, rt] = z.startTime.split(\":\").map(Number);\n      E = `${((Z + 1) % 24).toString().padStart(2, \"0\")}:${rt.toString().padStart(2, \"0\")}`;\n    }\n    return {\n      id: `item-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,\n      place: A,\n      startTime: E,\n      duration: 60\n    };\n  }, Ot = (A) => {\n    x((V) => {\n      const E = [...V], z = E[h].items;\n      return z.some((Z) => Z.place.id === A.id) ? V : (E[h].items = [...z, xt(A)], E);\n    }), a([]), r(\"\"), D(null);\n  }, pt = (A) => {\n    x((V) => {\n      const E = [...V];\n      return E[h].items = E[h].items.filter((z) => z.id !== A), E;\n    });\n  }, ie = (A, V) => {\n    x((E) => {\n      const z = [...E], Z = [...z[h].items], rt = Z.findIndex((Nt) => Nt.id === A);\n      if (rt === -1) return E;\n      const ot = hs(Z[rt].startTime), Dt = hs(V) - ot;\n      for (let Nt = rt; Nt < Z.length; Nt++) {\n        const an = hs(Z[Nt].startTime);\n        Z[Nt] = {\n          ...Z[Nt],\n          startTime: Nt === rt ? V : hm(an + Dt)\n        };\n      }\n      return z[h].items = Z, z;\n    });\n  }, Ft = (A) => {\n    const { active: V, over: E } = A;\n    E && V.id !== E.id && x((z) => {\n      const Z = [...z], rt = Z[h].items, ot = rt.findIndex((Dt) => Dt.id === V.id), Vt = rt.findIndex((Dt) => Dt.id === E.id);\n      return Z[h].items = Ys(rt, ot, Vt), Z;\n    });\n  }, Et = () => {\n    const A = y.length + 1, V = y.length > 0 && y[0].date ? new Date(y[0].date) : /* @__PURE__ */ new Date();\n    if (y.length > 0 && y[0].date && !y[0].date.includes(\"第\")) {\n      const E = new Date(y[0].date);\n      E.setDate(E.getDate() + (A - 1)), x((z) => [...z, { date: E.toISOString().split(\"T\")[0], items: [] }]);\n    } else {\n      const E = new Date(V);\n      E.setDate(E.getDate() + (A - 1)), x((z) => [...z, { date: E.toISOString().split(\"T\")[0], items: [] }]);\n    }\n    f(y.length);\n  }, K = (A, V) => {\n    x((E) => {\n      const z = [...E];\n      return z[A] = { ...z[A], date: V }, z;\n    });\n  }, re = (A) => {\n    if (!A) return \"未設定日期\";\n    if (A.includes(\"第\") && A.includes(\"天\")) return A;\n    try {\n      const V = new Date(A);\n      if (isNaN(V.getTime())) return A;\n      const E = V.getFullYear(), z = String(V.getMonth() + 1).padStart(2, \"0\"), Z = String(V.getDate()).padStart(2, \"0\"), ot = [\"日\", \"一\", \"二\", \"三\", \"四\", \"五\", \"六\"][V.getDay()];\n      return `${E}/${z}/${Z} (${ot})`;\n    } catch {\n      return A;\n    }\n  }, St = async () => {\n    const A = y[h].items;\n    if (A.length < 2) return;\n    d(!0);\n    const V = await co.optimizeDayPlan(A.map((E) => E.place));\n    V && V.itinerary && x((E) => {\n      const z = [...E], Z = [...z[h].items], rt = V.itinerary.map((ot) => {\n        const Vt = Z.find((Dt) => Dt.place.name === ot.placeName);\n        return Vt ? { ...Vt, startTime: ot.recommendedTime || Vt.startTime } : null;\n      }).filter(Boolean);\n      return rt.length > 0 && (z[h].items = rt), z;\n    }), d(!1);\n  }, Xt = () => {\n    D(null), a([]);\n  };\n  return /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex flex-col lg:flex-row h-[100dvh] w-full bg-slate-50 overflow-hidden font-sans relative\", children: [\n    N && /* @__PURE__ */ p.jsxs(\"div\", { className: \"fixed top-4 left-1/2 -translate-x-1/2 z-50 bg-blue-600 text-white px-4 py-2 rounded-full shadow-lg flex items-center gap-2 animate-pulse\", children: [\n      /* @__PURE__ */ p.jsx(\"i\", { className: \"fas fa-spinner fa-spin text-sm\" }),\n      /* @__PURE__ */ p.jsx(\"span\", { className: \"text-sm font-bold\", children: \"正在儲存...\" })\n    ] }),\n    /* @__PURE__ */ p.jsxs(\"aside\", { className: \"hidden lg:flex flex-col w-[30%] xl:w-[28%] bg-white border-r border-slate-100 shadow-2xl z-20 relative\", children: [\n      /* @__PURE__ */ p.jsxs(\"div\", { className: \"p-6 xl:p-8 pb-4\", children: [\n        /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex items-center justify-between mb-8\", children: [\n          /* @__PURE__ */ p.jsx(\"h1\", { className: \"text-2xl xl:text-3xl font-black text-blue-600 tracking-tighter leading-none\", children: \"行程規劃\" }),\n          /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex items-center gap-1.5 overflow-x-auto no-scrollbar\", children: [\n            y.map((A, V) => /* @__PURE__ */ p.jsxs(\"button\", { onClick: () => {\n              f(V), b([]);\n            }, className: `px-4 py-2 rounded-full text-[11px] font-black transition-all duration-300 ${h === V ? \"bg-blue-600 text-white shadow-xl shadow-blue-200\" : \"bg-slate-50 text-slate-400 hover:bg-slate-100\"}`, children: [\n              \"D\",\n              V + 1\n            ] }, V)),\n            /* @__PURE__ */ p.jsx(\"button\", { onClick: Et, className: \"w-10 h-10 rounded-full bg-blue-50 text-blue-600 hover:bg-blue-600 hover:text-white transition-all flex items-center justify-center flex-shrink-0 shadow-sm\", children: /* @__PURE__ */ p.jsx(\"i\", { className: \"fas fa-plus text-[10px]\" }) })\n          ] })\n        ] }),\n        /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex bg-slate-100 p-1.5 rounded-2xl mb-6\", children: [\n          /* @__PURE__ */ p.jsxs(\"button\", { onClick: () => v(\"DRIVING\"), className: `flex-1 flex items-center justify-center gap-2 py-3 rounded-xl text-[11px] font-black transition-all ${g === \"DRIVING\" ? \"bg-white text-blue-600 shadow-md\" : \"text-slate-400\"}`, children: [\n            /* @__PURE__ */ p.jsx(\"i\", { className: \"fas fa-car-side\" }),\n            \" 行車\"\n          ] }),\n          /* @__PURE__ */ p.jsxs(\"button\", { onClick: () => v(\"WALKING\"), className: `flex-1 flex items-center justify-center gap-2 py-3 rounded-xl text-[11px] font-black transition-all ${g === \"WALKING\" ? \"bg-white text-emerald-600 shadow-md\" : \"text-slate-400\"}`, children: [\n            /* @__PURE__ */ p.jsx(\"i\", { className: \"fas fa-person-walking\" }),\n            \" 步行\"\n          ] })\n        ] })\n      ] }),\n      /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex-1 overflow-y-auto overflow-x-visible px-4 xl:px-8 py-4 custom-scrollbar bg-[#fdfdfe] relative\", children: [\n        /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex items-center justify-between mb-8 px-2\", children: [\n          /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex items-center gap-3\", children: [\n            /* @__PURE__ */ p.jsxs(\"h2\", { className: \"text-[12px] font-black text-slate-400 uppercase tracking-[0.4em] whitespace-nowrap\", children: [\n              re(y[h].date),\n              \" 行程規劃\"\n            ] }),\n            /* @__PURE__ */ p.jsx(\n              \"input\",\n              {\n                type: \"date\",\n                value: y[h].date.includes(\"第\") ? \"\" : y[h].date,\n                onChange: (A) => K(h, A.target.value),\n                className: \"text-[10px] px-2 py-1 border border-slate-200 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:border-transparent\",\n                title: \"選擇日期\"\n              }\n            )\n          ] }),\n          /* @__PURE__ */ p.jsx(\"div\", { className: \"h-[1px] flex-1 bg-slate-100 ml-4\" })\n        ] }),\n        /* @__PURE__ */ p.jsx(\"div\", { className: \"w-full relative\", children: y[h].items.length === 0 ? /* @__PURE__ */ p.jsxs(\"div\", { className: \"py-24 text-center border-2 border-dashed border-slate-100 rounded-[3.5rem] bg-white\", children: [\n          /* @__PURE__ */ p.jsx(\"i\", { className: \"fas fa-map-location-dot text-slate-200 text-4xl mb-4\" }),\n          /* @__PURE__ */ p.jsx(\"p\", { className: \"text-[12px] font-black text-slate-300 uppercase tracking-widest px-8\", children: \"搜尋景點開始你的澎湖冒險\" })\n        ] }) : /* @__PURE__ */ p.jsx(Qc, { sensors: et, collisionDetection: Ql, onDragEnd: Ft, children: /* @__PURE__ */ p.jsx(hu, { items: y[h].items.map((A) => A.id), strategy: uu, children: /* @__PURE__ */ p.jsx(\"div\", { className: \"space-y-0 w-full relative\", children: y[h].items.map((A, V) => /* @__PURE__ */ p.jsx(ho, { item: A, onRemove: pt, onTimeUpdate: ie, onClick: () => D({ ...A.place }), isLast: V === y[h].items.length - 1, travelTimeToNext: T[V], travelMode: g, nextPlace: y[h].items[V + 1]?.place }, A.id)) }) }) }) })\n      ] }),\n      /* @__PURE__ */ p.jsx(\"div\", { className: \"p-8 bg-white border-t border-slate-50 relative z-30\", children: /* @__PURE__ */ p.jsxs(\"button\", { onClick: St, disabled: y[h].items.length < 2 || c, className: \"w-full py-5 bg-slate-900 text-white rounded-[2rem] font-black text-xs uppercase tracking-widest shadow-2xl hover:bg-blue-600 transition-all flex items-center justify-center gap-3 active:scale-[0.97] disabled:opacity-30\", children: [\n        c ? /* @__PURE__ */ p.jsx(\"i\", { className: \"fas fa-spinner fa-spin\" }) : /* @__PURE__ */ p.jsx(\"i\", { className: \"fas fa-magic\" }),\n        \" AI 智慧優化排序\"\n      ] }) })\n    ] }),\n    /* @__PURE__ */ p.jsxs(\"main\", { className: \"flex-1 relative bg-slate-100 overflow-hidden h-full\", children: [\n      /* @__PURE__ */ p.jsxs(\"div\", { className: \"absolute top-8 left-1/2 -translate-x-1/2 w-[90%] lg:w-[540px] z-30\", children: [\n        /* @__PURE__ */ p.jsxs(\"div\", { className: \"bg-white/95 backdrop-blur-3xl rounded-[2.5rem] shadow-[0_30px_80px_rgba(0,0,0,0.15)] border border-white p-2 flex items-center gap-4 transition-all focus-within:ring-4 focus-within:ring-blue-500/10\", children: [\n          /* @__PURE__ */ p.jsx(\"div\", { className: \"w-14 h-14 rounded-3xl bg-gradient-to-br from-blue-600 to-indigo-700 text-white flex items-center justify-center flex-shrink-0 shadow-lg shadow-blue-200\", children: /* @__PURE__ */ p.jsx(\"i\", { className: \"fas fa-search text-lg\" }) }),\n          /* @__PURE__ */ p.jsx(\"input\", { type: \"text\", placeholder: \"搜尋澎湖秘境、美食...\", className: \"flex-1 bg-transparent border-none outline-none text-base font-bold text-slate-700 placeholder:text-slate-400\", value: i, onChange: (A) => r(A.target.value), onKeyDown: (A) => A.key === \"Enter\" && X() }),\n          /* @__PURE__ */ p.jsx(\n            \"button\",\n            {\n              onClick: dt,\n              disabled: H || !n,\n              className: \"w-14 h-14 rounded-3xl bg-gradient-to-br from-emerald-500 to-teal-600 text-white flex items-center justify-center flex-shrink-0 shadow-lg shadow-emerald-200 hover:shadow-emerald-300 transition-all disabled:opacity-50\",\n              title: \"我的地點收藏\",\n              children: H ? /* @__PURE__ */ p.jsx(\"i\", { className: \"fas fa-spinner fa-spin text-lg\" }) : /* @__PURE__ */ p.jsx(\"i\", { className: \"fas fa-bookmark text-lg\" })\n            }\n          )\n        ] }),\n        /* @__PURE__ */ p.jsxs(Ah, { children: [\n          o.length > 0 && /* @__PURE__ */ p.jsx(as.div, { initial: { opacity: 0, y: 15 }, animate: { opacity: 1, y: 0 }, exit: { opacity: 0, y: 15 }, className: \"absolute top-full mt-5 w-full bg-white/95 rounded-[2.5rem] shadow-2xl border border-white overflow-hidden max-h-[50vh] flex flex-col p-4 gap-2\", children: o.map((A) => /* @__PURE__ */ p.jsx(uo, { place: A, onClick: () => {\n            D({ ...A }), a([]), window.innerWidth < 1024 && C(\"low\");\n          } }, A.id)) }),\n          G && k.length > 0 && /* @__PURE__ */ p.jsxs(as.div, { initial: { opacity: 0, y: 15 }, animate: { opacity: 1, y: 0 }, exit: { opacity: 0, y: 15 }, className: \"absolute top-full mt-5 w-full bg-white/95 rounded-[2.5rem] shadow-2xl border border-white overflow-hidden max-h-[50vh] flex flex-col\", children: [\n            /* @__PURE__ */ p.jsxs(\"div\", { className: \"p-4 border-b border-slate-100 flex items-center justify-between\", children: [\n              /* @__PURE__ */ p.jsxs(\"h3\", { className: \"text-sm font-black text-slate-700\", children: [\n                \"我的地點收藏 (\",\n                k.length,\n                \")\"\n              ] }),\n              /* @__PURE__ */ p.jsx(\n                \"button\",\n                {\n                  onClick: () => {\n                    _(!1), U([]);\n                  },\n                  className: \"w-8 h-8 rounded-full bg-slate-100 text-slate-400 hover:bg-slate-200 flex items-center justify-center transition-all\",\n                  children: /* @__PURE__ */ p.jsx(\"i\", { className: \"fas fa-times text-xs\" })\n                }\n              )\n            ] }),\n            /* @__PURE__ */ p.jsx(\"div\", { className: \"overflow-y-auto max-h-[calc(50vh-60px)] p-4 gap-2 flex flex-col\", children: k.map((A) => /* @__PURE__ */ p.jsx(uo, { place: A, onClick: () => {\n              Ot(A), _(!1), U([]), typeof window < \"u\" && window.showToast && window.showToast(\"已加入行程\", \"success\");\n            } }, A.id)) })\n          ] })\n        ] })\n      ] }),\n      /* @__PURE__ */ p.jsx(\"div\", { className: \"w-full h-full\", children: /* @__PURE__ */ p.jsx(dm, { items: y[h].items, center: R, travelMode: g, onAddPlaceFromMap: Ot, selectedPlace: P, onInfoWindowClose: Xt, onTravelDataUpdate: (A) => b(A) }) }),\n      /* @__PURE__ */ p.jsxs(as.div, { className: \"lg:hidden fixed bottom-0 left-0 right-0 bg-white rounded-t-[3.5rem] shadow-2xl z-40 overflow-hidden flex flex-col\", animate: { height: w === \"high\" ? \"85%\" : \"25%\" }, transition: { type: \"spring\", damping: 25 }, children: [\n        /* @__PURE__ */ p.jsx(\"div\", { className: \"w-full h-12 flex flex-col items-center justify-center cursor-pointer\", onClick: () => C(w === \"low\" ? \"high\" : \"low\"), children: /* @__PURE__ */ p.jsx(\"div\", { className: \"w-14 h-1.5 bg-slate-100 rounded-full\" }) }),\n        /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex-1 overflow-y-auto px-6 pb-28 custom-scrollbar\", children: [\n          /* @__PURE__ */ p.jsxs(\"div\", { className: \"flex items-center justify-between mb-8 px-2\", children: [\n            /* @__PURE__ */ p.jsx(\"h2\", { className: \"text-2xl font-black text-slate-900\", children: y[h].date }),\n            /* @__PURE__ */ p.jsx(\"div\", { className: \"flex gap-2\", children: y.map((A, V) => /* @__PURE__ */ p.jsxs(\"button\", { onClick: () => {\n              f(V), b([]);\n            }, className: `w-11 h-11 rounded-full text-[11px] font-black ${h === V ? \"bg-blue-600 text-white shadow-lg shadow-blue-200\" : \"bg-slate-100 text-slate-400\"}`, children: [\n              \"D\",\n              V + 1\n            ] }, V)) })\n          ] }),\n          /* @__PURE__ */ p.jsx(\"div\", { className: \"space-y-0 w-full relative\", children: y[h].items.map((A, V) => /* @__PURE__ */ p.jsx(ho, { item: A, onRemove: pt, onTimeUpdate: ie, onClick: () => {\n            D({ ...A.place }), C(\"low\");\n          }, isLast: V === y[h].items.length - 1, travelTimeToNext: T[V], travelMode: g, nextPlace: y[h].items[V + 1]?.place }, A.id)) })\n        ] })\n      ] })\n    ] }),\n    /* @__PURE__ */ p.jsx(\"style\", { children: `\n        .custom-scrollbar::-webkit-scrollbar { width: 4px; }\n        .custom-scrollbar::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 10px; }\n        .no-scrollbar::-webkit-scrollbar { display: none; }\n      ` })\n  ] });\n};\nexport {\n  gm as App,\n  gm as default\n};\n",
  "styles/design-tokens.css": "/**\n * Design Tokens - 統一設計系統\n * 用於確保前端和後端 UI 的一致性\n */\n\n:root {\n  /* 色彩系統 */\n  --color-primary: #2563eb;\n  --color-primary-light: #3b82f6;\n  --color-primary-dark: #1d4ed8;\n  --color-secondary: #10b981;\n  --color-accent: #8b5cf6;\n  \n  /* 中性色 */\n  --color-gray-50: #f9fafb;\n  --color-gray-100: #f3f4f6;\n  --color-gray-200: #e5e7eb;\n  --color-gray-300: #d1d5db;\n  --color-gray-400: #9ca3af;\n  --color-gray-500: #6b7280;\n  --color-gray-600: #4b5563;\n  --color-gray-700: #374151;\n  --color-gray-800: #1f2937;\n  --color-gray-900: #111827;\n  \n  /* 語義色彩 */\n  --color-success: #10b981;\n  --color-error: #ef4444;\n  --color-warning: #f59e0b;\n  --color-info: #3b82f6;\n  \n  /* 間距系統 */\n  --spacing-xs: 0.25rem;   /* 4px */\n  --spacing-sm: 0.5rem;    /* 8px */\n  --spacing-md: 1rem;      /* 16px */\n  --spacing-lg: 1.5rem;    /* 24px */\n  --spacing-xl: 2rem;      /* 32px */\n  --spacing-2xl: 3rem;     /* 48px */\n  --spacing-3xl: 4rem;     /* 64px */\n  \n  /* 圓角系統 */\n  --radius-sm: 0.375rem;   /* 6px */\n  --radius-md: 0.5rem;     /* 8px */\n  --radius-lg: 0.75rem;    /* 12px */\n  --radius-xl: 1rem;      /* 16px */\n  --radius-2xl: 1.5rem;    /* 24px */\n  --radius-3xl: 2rem;      /* 32px */\n  --radius-full: 9999px;\n  \n  /* 陰影系統 */\n  --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);\n  --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);\n  --shadow-lg: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);\n  --shadow-xl: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);\n  --shadow-2xl: 0 25px 50px -12px rgba(0, 0, 0, 0.25);\n  \n  /* 字體系統 */\n  --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans TC', 'Roboto', 'Helvetica Neue', Arial, sans-serif;\n  --font-mono: 'SF Mono', Monaco, 'Cascadia Code', 'Roboto Mono', Consolas, 'Courier New', monospace;\n  \n  /* 字體大小 */\n  --text-xs: 0.75rem;      /* 12px */\n  --text-sm: 0.875rem;     /* 14px */\n  --text-base: 1rem;       /* 16px */\n  --text-lg: 1.125rem;     /* 18px */\n  --text-xl: 1.25rem;     /* 20px */\n  --text-2xl: 1.5rem;      /* 24px */\n  --text-3xl: 1.875rem;    /* 30px */\n  --text-4xl: 2.25rem;     /* 36px */\n  \n  /* 字體粗細 */\n  --font-light: 300;\n  --font-normal: 400;\n  --font-medium: 500;\n  --font-semibold: 600;\n  --font-bold: 700;\n  --font-black: 900;\n  \n  /* 動畫時間 */\n  --duration-fast: 150ms;\n  --duration-normal: 300ms;\n  --duration-slow: 500ms;\n  \n  /* 動畫緩動 */\n  --ease-in: cubic-bezier(0.4, 0, 1, 1);\n  --ease-out: cubic-bezier(0, 0, 0.2, 1);\n  --ease-in-out: cubic-bezier(0.4, 0, 0.2, 1);\n  \n  /* Z-index 層級 */\n  --z-base: 0;\n  --z-dropdown: 1000;\n  --z-sticky: 1020;\n  --z-fixed: 1030;\n  --z-modal-backdrop: 1040;\n  --z-modal: 1050;\n  --z-popover: 1060;\n  --z-tooltip: 1070;\n}\n\n/* 深色模式支援（未來擴展） */\n@media (prefers-color-scheme: dark) {\n  :root {\n    --color-gray-50: #111827;\n    --color-gray-100: #1f2937;\n    --color-gray-200: #374151;\n    --color-gray-300: #4b5563;\n    --color-gray-400: #6b7280;\n    --color-gray-500: #9ca3af;\n    --color-gray-600: #d1d5db;\n    --color-gray-700: #e5e7eb;\n    --color-gray-800: #f3f4f6;\n    --color-gray-900: #f9fafb;\n  }\n}\n\n",
  "styles/responsive.css": "/**\n * Responsive Design Utilities\n * 響應式設計輔助類別和斷點\n */\n\n/* 斷點定義 */\n/* sm: 640px, md: 768px, lg: 1024px, xl: 1280px, 2xl: 1536px */\n\n/* 觸控優化 */\n@media (hover: none) and (pointer: coarse) {\n  /* 行動裝置觸控優化 */\n  button, a, [role=\"button\"] {\n    min-height: 44px;\n    min-width: 44px;\n  }\n  \n  /* 增加點擊目標大小 */\n  .touch-target {\n    min-height: 44px;\n    min-width: 44px;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n  }\n}\n\n/* 平板優化 */\n@media (min-width: 768px) and (max-width: 1023px) {\n  /* 平板特定樣式 */\n  .tablet-optimized {\n    padding: 1.5rem;\n  }\n}\n\n/* 行動裝置優化 */\n@media (max-width: 767px) {\n  /* 隱藏桌面專用元素 */\n  .desktop-only {\n    display: none !important;\n  }\n  \n  /* 行動裝置專用間距 */\n  .mobile-spacing {\n    padding: 1rem;\n  }\n  \n  /* 行動裝置字體大小調整 */\n  .mobile-text {\n    font-size: 0.875rem;\n  }\n  \n  /* 行動裝置按鈕全寬 */\n  .mobile-full-width {\n    width: 100%;\n  }\n}\n\n/* 桌面優化 */\n@media (min-width: 1024px) {\n  /* 隱藏行動裝置專用元素 */\n  .mobile-only {\n    display: none !important;\n  }\n  \n  /* 桌面專用間距 */\n  .desktop-spacing {\n    padding: 2rem;\n  }\n}\n\n/* 大螢幕優化 */\n@media (min-width: 1536px) {\n  /* 限制最大寬度以保持可讀性 */\n  .container-xl {\n    max-width: 1400px;\n    margin: 0 auto;\n  }\n}\n\n/* 橫向模式優化 */\n@media (orientation: landscape) and (max-height: 500px) {\n  /* 橫向模式下的特殊處理 */\n  .landscape-compact {\n    padding: 0.5rem;\n  }\n}\n\n/* 高解析度螢幕優化 */\n@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 192dpi) {\n  /* 高解析度螢幕的邊框和陰影調整 */\n  .retina-border {\n    border-width: 0.5px;\n  }\n}\n\n/* 可訪問性優化 */\n@media (prefers-reduced-motion: reduce) {\n  *,\n  *::before,\n  *::after {\n    animation-duration: 0.01ms !important;\n    animation-iteration-count: 1 !important;\n    transition-duration: 0.01ms !important;\n  }\n}\n\n/* 列印樣式 */\n@media print {\n  .no-print {\n    display: none !important;\n  }\n  \n  .print-break {\n    page-break-after: always;\n  }\n}\n\n"
};

export function getItineraryAsset(path) {
  return itineraryAssets[path] || null;
}

export function getAllItineraryAssets() {
  return itineraryAssets;
}
