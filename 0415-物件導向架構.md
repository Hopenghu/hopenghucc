以下是以 React 的物件導向思想進行優化的建議方案，採用模塊化與類別封裝的方式重構程式碼：

### 1. 核心模塊拆分（Class-based Modules）
```javascript
// auth/SessionManager.js
export class SessionManager {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    // 封裝原有 getSession 邏輯
  }

  async createSession(userId) {
    // 封裝會話創建邏輯
  }

  async destroySession(sessionId) {
    // 封裝會話銷毀邏輯
  }
}

// auth/AuthService.js
export class AuthService {
  constructor(env) {
    this.googleClientId = env.GOOGLE_CLIENT_ID;
  }

  async handleGoogleCallback(request) {
    // 拆分為多個步驟方法
  }

  #verifyToken() { /* ... */ }
  #findOrCreateUser() { /* ... */ }
  #updateUserData() { /* ... */ }
}
```

### 2. 路由處理器抽象（Route Handlers）
```javascript
// routes/BaseHandler.js
export class BaseHandler {
  constructor(env, sessionManager) {
    this.env = env;
    this.sessionManager = sessionManager;
  }

  async handle(request) {
    throw new Error('Not implemented');
  }
}

// routes/ApiHandler.js
export class ApiHandler extends BaseHandler {
  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

// routes/PageHandler.js
export class PageHandler extends BaseHandler {
  async handle(request) {
    // 封裝頁面渲染邏輯
    const templateRenderer = new TemplateRenderer(this.env);
    return templateRenderer.render(request);
  }
}
```

### 3. 模板渲染組件化（Template Components）
```javascript
// templates/TemplateRenderer.js
export class TemplateRenderer {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}
```

### 4. 資料存取層抽象（Data Access Layer）
```javascript
// database/UserRepository.js
export class UserRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM users WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM users WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}
```

### 5. 中間件管道處理（Middleware Pipeline）
```javascript
// middlewares/Pipeline.js
export class Pipeline {
  constructor() {
    this.middlewares = [];
  }

  use(middleware) {
    this.middlewares.push(middleware);
  }

  async execute(request, env) {
    let result;
    const context = { request, env };
    
    for (const middleware of this.middlewares) {
      result = await middleware(context);
      if (result) break; // 短路處理
    }
    
    return result || new Response('Not Found', { status: 404 });
  }
}

// 使用方式
const pipeline = new Pipeline();
pipeline.use(new AuthMiddleware());
pipeline.use(new ApiMiddleware());
pipeline.use(new PageMiddleware());
```

### 6. 錯誤處理統一化（Error Boundary）
```javascript
// errors/ErrorHandler.js
export class ErrorHandler {
  static handle(error) {
    console.error('Global Error:', error);
    return new Response(this.#userFriendlyMessage(error), {
      status: this.#statusCodeFor(error),
      headers: { 'Content-Type': 'application/json' }
    });
  }

  static #statusCodeFor(error) {
    const codes = {
      DatabaseError: 503,
      AuthError: 401,
      NotFoundError: 404
    };
    return codes[error.constructor.name] || 500;
  }

  static #userFriendlyMessage(error) {
    // 轉換技術性錯誤為用戶友好訊息
  }
}
```

### 主要優化點：
1. **職責分離**：將不同功能拆分成獨立類別，符合單一職責原則
2. **依賴注入**：通過構造函數注入環境變數和依賴項
3. **策略模式**：用於處理不同 API 資源和頁面路由
4. **模板方法**：基礎模板封裝與具體頁面組件實現
5. **中間件模式**：實現請求處理管道化
6. **統一錯誤處理**：通過全局錯誤邊界捕獲異常
7. **數據存取抽象**：Repository 模式封裝數據庫操作

### 使用範例：
```javascript
export default {
  async fetch(request, env, ctx) {
    try {
      const sessionManager = new SessionManager(env);
      const pipeline = new Pipeline();

      // 註冊中間件
      pipeline.use(new AuthMiddleware(sessionManager));
      pipeline.use(new ApiHandler(env));
      pipeline.use(new PageHandler(env));

      return await pipeline.execute(request, env);
    } catch (error) {
      return ErrorHandler.handle(error);
    }
  }
};
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

### 主要優化點：
1. **職責分離**：將不同功能拆分成獨立類別，符合單一職責原則
2. **依賴注入**：通過構造函數注入環境變數和依賴項
3. **策略模式**：用於處理不同 API 資源和頁面路由
4. **模板方法**：基礎模板封裝與具體頁面組件實現
5. **中間件模式**：實現請求處理管道化
6. **統一錯誤處理**：通過全局錯誤邊界捕獲異常
7. **數據存取抽象**：Repository 模式封裝數據庫操作

### 使用範例：
```javascript
export default {
  async fetch(request, env, ctx) {
    try {
      const sessionManager = new SessionManager(env);
      const pipeline = new Pipeline();

      // 註冊中間件
      pipeline.use(new AuthMiddleware(sessionManager));
      pipeline.use(new ApiHandler(env));
      pipeline.use(new PageHandler(env));

      return await pipeline.execute(request, env);
    } catch (error) {
      return ErrorHandler.handle(error);
    }
  }
};
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService } from './services/RouterService';

export default {
  async fetch(request, env, ctx) {
    try {
      const security = new SecurityService();
      const session = new SessionService(env);
      const router = new RouterService(env, security, session);

      const response = await router.handleRequest(request);
      
      // 添加安全標頭
      const headers = new Headers(response.headers);
      const securityHeaders = security.getCSPHeaders();
      
      for (const [key, value] of Object.entries(securityHeaders)) {
        headers.set(key, value);
      }

      return new Response(response.body, {
        status: response.status,
        statusText: response.statusText,
        headers
      });
    } catch (error) {
      console.error('Fetch Error:', error);
      return new Response(JSON.stringify({ 
        error: 'Internal Server Error',
        message: error.message
      }), { 
        status: 500,
        headers: { 'Content-Type': 'application/json;charset=UTF-8' }
      });
    }
  }
};
```

### 4. 資料存取層（第二優先）
// database/PlaceRepository.js
export class PlaceRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM places WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM places WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

// database/EventRepository.js
export class EventRepository {
  constructor(db) {
    this.db = db;
  }

  async findById(id) {
    return this.db.prepare('SELECT * FROM events WHERE id = ?').bind(id);
  }

  async findByEmail(email) {
    return this.db.prepare('SELECT * FROM events WHERE email = ?').bind(email);
  }

  async updateUser(userData) {
    // 封裝更新邏輯
  }
}

### 5. 控制器層（第三優先）
// controllers/AuthController.js
export class AuthController {
  constructor(env) {
    this.env = env;
  }

  async handleGoogleCallback(request) {
    // 實現 Google 登入處理邏輯
  }
}

// controllers/PageController.js
export class PageController {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    // 實現頁面渲染邏輯
  }
}

// controllers/ApiController.js
export class ApiController {
  constructor(env) {
    this.env = env;
  }

  async handle(request) {
    const url = new URL(request.url);
    const pathParts = url.pathname.split('/').filter(p => p);
    
    // 使用策略模式處理不同資源
    const resourceHandlers = {
      users: new UsersHandler(this.env),
      events: new EventsHandler(this.env),
      places: new PlacesHandler(this.env)
    };

    const handler = resourceHandlers[pathParts[1]];
    return handler ? handler.handle(request) : new Response('Not Found', { status: 404 });
  }
}

### 6. 視圖層（最後）
// templates/TemplateService.js
export class TemplateService {
  constructor(env) {
    this.env = env;
  }

  async render(request) {
    const url = new URL(request.url);
    const pageComponent = this.#getPageComponent(url.pathname);
    return this.#wrapBaseTemplate(pageComponent);
  }

  #getPageComponent(pathname) {
    const components = {
      '/': HomePage,
      '/admin': AdminPage,
      '/login': LoginPage
    };
    return components[pathname] || NotFoundPage;
  }

  #wrapBaseTemplate(content) {
    // 封裝基礎模板結構
    return `
      <!DOCTYPE html>
      <html>
        <head>${this.#headContent()}</head>
        <body>${content}</body>
      </html>
    `;
  }
}

// templates/ComponentService.js
export class ComponentService {
  constructor(env) {
    this.env = env;
  }

  // 其他模板相關方法
}
```

此重構方案將原本 procedural 的程式碼轉換為物件導向架構，具有以下優勢：
- **可測試性**：每個類別可獨立測試
- **可維護性**：功能模塊邊界清晰
- **擴展性**：新增功能只需擴展對應類別
- **復用性**：通用邏輯封裝成可重用模塊
- **錯誤隔離**：錯誤處理集中化管理

需注意 Cloudflare Worker 的環境限制，必要時需配合 Workers 的模塊系統調整導入方式。

### 1. 首先建立核心服務類別
// src/services/SessionService.js
export class SessionService {
  constructor(env) {
    this.env = env;
  }

  async getSession(request) {
    const cookies = request.headers.get('cookie');
    if (!cookies) return null;
    
    const sessionMatch = cookies.match(/session=([^;]+)/);
    if (!sessionMatch) return null;

    const sessionId = sessionMatch[1];
    return await this.env.DB.prepare(
      'SELECT id, user_id as userId, expires_at as expiresAt FROM sessions WHERE id = ? AND expires_at > datetime("now")'
    ).bind(sessionId).first();
  }
}

// 2. 建立安全配置管理器
// src/services/SecurityService.js
export class SecurityService {
  constructor() {
    this.nonce = null;
  }

  generateNonce() {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    this.nonce = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
    return this.nonce;
  }

  getCSPHeaders() {
    if (!this.nonce) this.generateNonce();
    
    return {
      'Content-Security-Policy': [
        "default-src 'self'",
        `script-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://apis.google.com`,
        `style-src 'self' 'nonce-${this.nonce}' 'unsafe-inline' https://fonts.googleapis.com`,
        "font-src 'self' data: https://fonts.gstatic.com",
        "img-src 'self' data: https:",
        "connect-src 'self' https://apis.google.com",
        "frame-src 'self' https://accounts.google.com",
        "base-uri 'self'",
        "form-action 'self'",
        "frame-ancestors 'none'",
        "object-src 'none'"
      ].join('; ')
    };
  }
}
```

### 3. 修改 worker.js
```javascript
// src/worker.js
import { SessionService } from './services/SessionService';
import { SecurityService } from './services/SecurityService';
import { RouterService